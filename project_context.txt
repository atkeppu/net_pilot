================================================================================
FILE: app_logic.py
================================================================================

"""
Facade Module for Application Logic.

This module collects and exposes all the necessary business logic functions
from the `logic` subpackage. This provides a single, clean entry point for the
GUI layer to import from, decoupling it from the internal structure of the
logic package.
"""

# From logger_setup
from logger_setup import get_dist_path

# From logic.system
from logic.system import (
    flush_dns_cache,
    is_admin,
    release_renew_ip,
    reset_network_stack,
    relaunch_as_admin,
    terminate_process_by_pid,
)

# From logic.adapters
from logic.adapters import (
    disconnect_wifi_and_disable_adapter,
    get_adapter_details,
    set_network_adapter_status_windows,
)

# From logic.diagnostics
from logic.diagnostics import (
    get_active_connections,
    get_network_diagnostics,
    get_raw_network_stats,
    run_traceroute
)

# From logic.wifi
from logic.wifi import (
    disconnect_wifi,
    get_current_wifi_details,
    get_saved_wifi_profiles,
    list_wifi_networks,
)

# From logic.wifi_profile_manager
from logic.wifi_profile_manager import (
    connect_to_wifi_network,
    connect_with_profile_name,
    delete_wifi_profile
)

# From github_integration
from github_integration import (
    create_github_release,
    get_repo_from_git_config,
    check_github_cli_auth
)

# Explicitly define the public API of this facade module.
__all__ = [
    # logger_setup
    'get_dist_path',
    # system
    'flush_dns_cache',
    'is_admin',
    'release_renew_ip',
    'reset_network_stack',
    'relaunch_as_admin',
    'terminate_process_by_pid',
    # adapters
    'disconnect_wifi_and_disable_adapter',
    'get_adapter_details',
    'set_network_adapter_status_windows',
    # diagnostics
    'get_active_connections',
    'get_network_diagnostics',
    'get_raw_network_stats',
    'run_traceroute',
    # wifi
    'disconnect_wifi',
    'get_current_wifi_details',
    'get_saved_wifi_profiles',
    'list_wifi_networks',
    # wifi_profile_manager
    'connect_to_wifi_network',
    'connect_with_profile_name',
    'delete_wifi_profile',
    # github_integration
    'create_github_release',
    'get_repo_from_git_config',
    'check_github_cli_auth'
]

================================================================================
FILE: ARCHITECTURE.md
================================================================================

# NetPilot - Sovelluksen Arkkitehtuuri

Tämä dokumentti kuvaa NetPilot-sovelluksen arkkitehtuurin, sen pääkomponentit ja niiden väliset tietovirrat. Arkkitehtuuri on suunniteltu modulaariseksi ja vankaksi, erottaen selkeästi käyttöliittymän, tilanhallinnan ja järjestelmätason toiminnot.

## Yleiskatsaus

NetPilot noudattaa modernia työpöytäsovelluksen arkkitehtuuria, jossa on seuraavat pääperiaatteet:

1.  **Yksisuuntainen tietovirta:** Taustalla suoritettavat toiminnot eivät koskaan muokkaa käyttöliittymää suoraan. Sen sijaan ne lähettävät viestejä keskitettyyn jonoon, josta käyttöliittymä ne käsittelee turvallisesti.
2.  **Vastuun eriyttäminen (Separation of Concerns):**
    *   **GUI-kerros (`gui/`)**: Vastaa vain siitä, miltä sovellus näyttää ja käyttäjän syötteiden vastaanottamisesta.
    *   **Ohjain- ja hallintakerros (`gui/`):** Sisältää luokkia, jotka orkestroivat toimintoja ja hallinnoivat sovelluksen tilaa (`AppContext`, `MainController`, `ActionHandler`, `PollingManager`).
    *   **Logiikkakerros (`logic/`)**: Sisältää kaiken "likaisen työn", kuten järjestelmäkomentojen ja PowerShell-skriptien ajamisen.
3.  **Asynkroninen suoritus:** Hitaat verkkotoiminnot suoritetaan aina taustasäikeissä, jotta käyttöliittymä pysyy jatkuvasti reagoivana.

## Arkkitehtuurikaavio (Mermaid)

```
NetPilot/
├── gui/
│   └── main_window.py      # Pääikkuna ja kaikki UI-komponentit
├── logic/
│   ├── system.py           # Järjestelmätason tarkistukset (esim. admin-oikeudet)
│   └── ...                 # Muu sovelluslogiikka (tulevaisuudessa network_utils.py)
├── logs/                   # (luodaan ajon aikana)
│   └── debug.log           # Oletuslokitiedosto
├── main.py                 # Sovelluksen käynnistystiedosto (entry point)
├── logger_setup.py         # Lokituksen alustus ja konfigurointi
├── build.py                # Skripti .exe-paketin rakentamiseen
├── README.md               # Projektin päädokumentaatio
└── ARCHITECTURE.md         # Tämä tiedosto
```

## Tärkeimmät Komponentit

1.  **`main.py` (Käynnistyspiste)**
    *   Vastaa sovelluksen käynnistämisestä.
    *   Alustaa lokituksen kutsumalla `logger_setup.py`:tä.
    *   Suorittaa esitarkastukset (ns. "pre-flight checks"):
        *   Varmistaa, että sovellus ajetaan Windows-ympäristössä.
        *   Tarkistaa ylläpitäjän oikeudet (`logic/system.py`).
    *   Jos tarkistukset menevät läpi, luo ja käynnistää pääikkunan (`gui/main_window.py`).
    *   Käsittelee ylimmän tason poikkeukset ja kirjaa kriittiset virheet.

2.  **`gui/main_window.py` (Käyttöliittymä)**
    *   Sisältää `NetworkManagerApp`-luokan, joka periytyy `tk.Tk`:sta.
    *   Rakentaa koko graafisen käyttöliittymän: välilehdet, painikkeet, tekstikentät ja muut elementit.
    *   Käsittelee käyttäjän syötteitä (esim. napin painallukset).
    *   Kutsuu `logic`-kerroksen funktioita suorittamaan varsinaiset toiminnot (esim. verkkosovittimen poistaminen käytöstä).
    *   Päivittää käyttöliittymää `logic`-kerroksesta saatujen tulosten perusteella.

3.  **`logic/` (Sovelluslogiikka)**
    *   **`system.py`**: Sisältää käyttöjärjestelmästä riippuvia apufunktioita, kuten `is_admin()`, joka tarkistaa ylläpitäjän oikeudet.
    *   **`network_utils.py` (oletettu)**: Tänne on keskitetty kaikki verkkotoiminnot, jotka suoritetaan komentorivikomennoilla (esim. `netsh`, `ipconfig`, `wmic`). Funktiot palauttavat jäsenneltyä dataa, jonka GUI-kerros voi näyttää käyttäjälle. Tämä eriyttäminen tekee koodista testattavamman ja helpommin ylläpidettävän.

4.  **`logger_setup.py` (Lokitus)**
    *   Konfiguroi keskitetyn `logging`-moduulin, joka kirjoittaa tapahtumat sekä konsoliin että `logs/debug.log`-tiedostoon. Tämä on tärkeää vianjäljityksen kannalta.

## Toimintalogiikka (Data Flow)

1.  Käyttäjä käynnistää `main.py`:n.
2.  Esitarkastukset suoritetaan. Virhetilanteessa näytetään `messagebox` ja sovellus suljetaan.
3.  `NetworkManagerApp`-olio luodaan, ja se rakentaa käyttöliittymän.
4.  Käyttäjä tekee toiminnon, esim. painaa "Disable Adapter" -nappia.
5.  `main_window.py`:n tapahtumankäsittelijä kutsuu vastaavaa funktiota `logic/network_utils.py`:ssä.
6.  `network_utils`-funktio suorittaa tarvittavan järjestelmäkomennon (`subprocess.run`).
7.  Tulos (onnistuminen/virhe ja mahdollinen data) palautetaan `main_window.py`:lle.
8.  Käyttöliittymä päivitetään näyttämään tulos (esim. tilaviesti tai päivitetty sovitinlista).

## Arkkitehtuurikaavio (Mermaid)

```mermaid
graph LR
    subgraph "Käyttöliittymä (GUI)"
        direction TB
        subgraph "Pääikkuna (NetworkManagerApp)"
            MW[main_window.py]
            ALF[AdapterListFrame]
            ADF[AdapterDetailsFrame]
            WSF[WifiStatusFrame]
            DF[DiagnosticsFrame]
            MW --> ALF & ADF & WSF & DF
        end
        subgraph "Erilliset ikkunat (Toplevel)"
            WW[WifiConnectWindow]
            TW[TracerouteWindow]
            NW[NetstatWindow]
            PW[PublishWindow]
        end
        MW -- "Avaa" --> WW & TW & NW & PW
    end

    subgraph "Sovelluslogiikka (Logic)"
        direction TB
        LA[adapters.py]
        LW[wifi.py]
        LD[diagnostics.py]
        LS[system.py]
    end

    subgraph "Tietovirta"
        GUI -- "1. Käynnistää taustatehtävän" --> Thread[Worker-säie]
        Thread -- "2. Kutsuu logiikkaa" --> Logic
        Logic -- "3. Suorittaa komennon" --> CMD["Järjestelmäkomennot <br/>(PowerShell, netsh)"]
        CMD -- "4. Tulos" --> Logic
        Logic -- "5. Tulos" --> Thread
        Thread -- "6. Lähettää viestin" --> Queue(Task Queue)
        Queue -- "7. Käsittelee viestin" --> GUI
        GUI -- "8. Päivittää UI:n" --> GUI
    end

```

================================================================================
FILE: build.py
================================================================================

import subprocess
import sys
import os
import argparse

from pathlib import Path
import re
import shutil
import json

# Define app name directly in the build script to avoid import-related file locks.
APP_NAME = "NetPilot"
ENTRY_POINT = "main.py"
ICON_FILE = "icon.ico"
MANIFEST_FILE = "admin.manifest"
VERSION_FILE = "version.txt"

def increment_version(part_to_increment: str):
    """Increments the project version in the VERSION file."""  # noqa: E501
    print(f"-> Päivitetään versionumeroa (osa: {part_to_increment})...")
    version_path = Path.cwd() / "VERSION"
    try:
        current_version = version_path.read_text(encoding="utf-8").strip()
        major, minor, patch = map(int, current_version.split('.'))

        if part_to_increment == 'major':
            major += 1
            minor = 0
            patch = 0
        elif part_to_increment == 'minor':
            minor += 1
            patch = 0
        elif part_to_increment == 'patch':
            patch += 1
        
        new_version = f"{major}.{minor}.{patch}"
        version_path.write_text(new_version, encoding="utf-8")
        print(f"   ...OK: Versio päivitetty: {current_version} -> {new_version}")

    except (FileNotFoundError, ValueError) as e:
        raise RuntimeError(
            f"VERSION-tiedoston lukeminen tai jäsentäminen epäonnistui: {e}")


def get_app_version() -> str:
    """Reads the app version from the VERSION file."""
    try:
        version_path = Path.cwd() / "VERSION"
        version = version_path.read_text(encoding="utf-8").strip()
        print(f"   ...Löydetty versio: {version}")
        return version
    except FileNotFoundError:
        raise RuntimeError("VERSION file not found in the project root.")

def find_iscc() -> Path | None:
    """
    Finds the Inno Setup Compiler (ISCC.exe) from common installation paths.
    Checks Program Files (x86) and Program Files directories.
    """
    program_files = os.environ.get("ProgramFiles(x86)", "")
    program_files_64 = os.environ.get("ProgramW6432", "")

    search_paths = [
        Path(program_files) / "Inno Setup 6",
        Path(program_files_64) / "Inno Setup 6",
    ]

    for path in search_paths:
        iscc_path = path / "ISCC.exe"
        if iscc_path.is_file():
            print(f"   ...Löytyi Inno Setup -kääntäjä: {iscc_path}")
            return iscc_path
    return None

def find_upx() -> Path | None:
    """Finds the UPX executable in the system's PATH."""
    upx_path = shutil.which("upx")
    if upx_path:
        upx_dir = Path(upx_path).parent
        print(f"   ...Löytyi UPX-pakkaaja kansiosta: {upx_dir}")
        return upx_dir
    else:
        print("\n-> ⚠️  Varoitus: UPX-pakkaajaa ei löytynyt järjestelmästä.")
        print("   .exe-tiedoston kokoa ei pienennetä. Koko voi olla ~30-40 MB.")  # noqa: E501
        print(
            "   Asenna UPX (https://upx.github.io/) ja lisää se "
            "PATH-ympäristömuuttujaan pienentääksesi tiedostokoon ~15 MB:iin.")
        return None


def create_version_file(version: str):
    """Creates a version file for PyInstaller."""
    print("-> Luodaan versiotiedostoa...")
    version_info_template = """
# UTF-8
VSVersionInfo(
  ffi=FixedFileInfo(
    filevers=({file_version}, 0),
    prodvers=({prod_version}, 0),
    mask=0x3f,
    flags=0x0,
    OS=0x40004,
    fileType=0x1,
    subtype=0x0,
    date=(0, 0)
  ),
  kids=[
    StringFileInfo([
      StringTable(
        u'040904B0', [
            StringStruct(u'FileDescription', u'{app_name}'),
            StringStruct(u'FileVersion', u'{version_str}'),
            StringStruct(u'InternalName', u'{app_name}'),
            StringStruct(u'LegalCopyright', u'© Sami Turpeinen. All rights reserved.'),
            StringStruct(u'OriginalFilename', u'{app_name}.exe'),
            StringStruct(u'ProductName', u'{app_name}'),
            StringStruct(u'ProductVersion', u'{version_str}')
        ])
    ]),
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)
"""
    version_info = version_info_template.format(
        file_version=version.replace('.', ','),
        prod_version=version.replace('.', ','),
        app_name=APP_NAME,
        version_str=version
    )
    with open(VERSION_FILE, "w", encoding="utf-8") as f:
        f.write(version_info)
    print(f"   ...{VERSION_FILE} luotu.")

def run_command(command: list[str], description: str):
    """Runs a command line command, shows its status, and handles errors."""
    print(f"-> {description}...")
    try:
        # Komennon suorittaminen ilman shell=True on turvallisempaa.
        process = subprocess.run(
            command, 
            check=True, 
            capture_output=True, 
            text=True, 
            encoding='utf-8'
        )
        print("   ...OK: Valmis.")
        # Print PyInstaller's final summary, it's often useful.
        if "pyinstaller" in " ".join(command).lower():
             print("\n--- PyInstaller Yhteenveto ---")
             print(process.stdout)
             print("--------------------------")

    except FileNotFoundError:
        print(
            f"   ...ERROR: Komentoa '{command[0]}' ei löytynyt. Varmista, "
            f"että se on asennettu ja sen sijainti on lisätty järjestelmän "
            f"PATH-ympäristömuuttujaan.", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"   ...FAIL: Komento '{' '.join(command)}' "
              f"palautti virhekoodin.", file=sys.stderr)
        print("\n--- VIRHE ---", file=sys.stderr)
        # Show the error message, which is often more useful than just the exit code.
        error_output = e.stderr.strip() or e.stdout.strip()
        print(error_output, file=sys.stderr)
        print("-------------", file=sys.stderr) # type: ignore
        sys.exit(1)

def clean_previous_builds():
    """Removes old build artifacts."""
    print("-> Siivotaan aiempia build-jäämiä...")
    project_root = Path.cwd()
    
    for path_item in [project_root / 'build', project_root / 'dist']:
        if path_item.exists():
            # ignore_errors=True helps prevent crashes from locked files
            # (e.g., by antivirus).
            shutil.rmtree(path_item, ignore_errors=True)
            print(f"   ...INFO: Yritetty poistaa kansio: {path_item}")
    
    for spec_file in project_root.glob('*.spec'):
        spec_file.unlink()
        print(f"   ...INFO: Poistettu tiedosto: {spec_file}")
    
    if os.path.exists(VERSION_FILE):
        os.remove(VERSION_FILE)
        print(f"   ...INFO: Poistettu tiedosto: {VERSION_FILE}")
    print("   ...Valmis.")

def run_inno_setup(iscc_path: Path, version: str) -> str | None:
    """Runs the Inno Setup compiler if the script file exists."""
    setup_script = Path.cwd() / "setup.iss"
    if not setup_script.is_file():
        print(
            f"-> ⚠️ Varoitus: Inno Setup -skriptiä '{setup_script.name}' "
            f"ei löytynyt. Ohitetaan asennusohjelman luonti.")
        return None

    # Define the versioned filename in the main dist directory.
    # Inno Setup script creates the file without the 'v' prefix.
    final_installer_name = f"{APP_NAME}-{version}-setup.exe"
    final_installer_path = Path.cwd() / "dist" / final_installer_name

    # Clean up any old installers from the dist directory before building a new one.
    dist_dir = Path.cwd() / "dist"
    for old_installer in dist_dir.glob("*-setup.exe"):
        print(f"   ...Poistetaan vanha asennustiedosto: {old_installer.name}")
        old_installer.unlink()

    # Run Inno Setup
    # Pass the version number directly to the Inno Setup compiler. This is
    # more reliable than having Inno Setup read it from the .exe file
    # properties. The /D flag defines a variable that can be used in the .iss
    # script.
    command = [str(iscc_path), f"/DAppVersion={version}", str(setup_script)]
    run_command(command, "Rakennetaan asennusohjelmaa Inno Setupilla")

    # Inno Setup script is configured to output directly to the dist folder
    # with the correct name.
    # We just need to verify it was created.
    if final_installer_path.is_file():
        print(
            f"   ...OK: Asennusohjelma luotu onnistuneesti: "
            f"{final_installer_path}")
        return str(final_installer_path)
    else:
        print(f"   ...ERROR: Odotettua asennustiedostoa ei löytynyt sijainnista: {final_installer_path}", file=sys.stderr)
        return None

def create_git_info_file():
    """
    Reads the git remote URL, extracts the repo name, and saves it to a JSON
    file in the dist directory. This allows the packaged app to know its repo
    without git.
    """
    print("-> Luodaan git_info.json-tiedostoa...")
    try:
        # This command is run in the build environment, where git is available.
        result = subprocess.run(
            ["git", "remote", "get-url", "origin"],
            capture_output=True, text=True, check=True)
        url = result.stdout.strip()
        match = re.search(r'github\.com[/:]([\w-]+/[\w.-]+?)(\.git)?$', url)
        if match:
            repo_name = match.group(1).replace('.git', '')
            info = {"repository": repo_name}
            (Path.cwd() / "dist" /
             "git_info.json").write_text(json.dumps(info), encoding='utf-8')
            print(f"   ...OK: Tallennettu repository: {repo_name}")
    except (subprocess.CalledProcessError, FileNotFoundError, IndexError):
        print("   ...⚠️ Varoitus: Ei voitu tunnistaa Git-repositorya. Julkaisutoiminto ei välttämättä toimi paketoidussa sovelluksessa.")

def generate_changelog(version: str):
    """
    Generates a changelog from git commits since the last tag.
    Saves the output to dist/CHANGELOG.md.
    """
    print("-> Generoidaan muutoslokia (changelog)...")
    try:
        # Find the most recent tag. If no tags, it will error out.
        latest_tag_cmd = ["git", "describe", "--tags", "--abbrev=0"]
        latest_tag = subprocess.check_output(
            latest_tag_cmd, text=True, encoding='utf-8',
            stderr=subprocess.PIPE).strip()
        print(f"   ...Löytyi edellinen tagi: {latest_tag}")
        commit_range = f"{latest_tag}..HEAD"
    except subprocess.CalledProcessError:
        # No tags found, this is likely the first release. Log all commits.
        print(
            "   ...⚠️ Varoitus: Aiempia tageja ei löytynyt. Generoidaan loki "
            "kaikista commiteista. (Tämä on normaalia ensimmäisellä julkaisulla)")
        commit_range = "HEAD"

    try:
        # Get commit subjects since the last tag in a nice bulleted list
        # format.
        log_cmd = ["git", "log", commit_range, "--pretty=format:- %s (%h)"]
        changelog_content = subprocess.check_output(
            log_cmd, text=True, encoding='utf-8').strip()

        if not changelog_content:
            changelog_content = "- Ei havaittuja muutoksia edellisen version jälkeen."

        changelog_path = Path.cwd() / "CHANGELOG.md"  # noqa: E501
        changelog_path.write_text(
            f"# Muutokset versiossa {version}\n\n{changelog_content}\n",
            encoding='utf-8')
        print(f"   ...OK: Muutosloki tallennettu tiedostoon: {changelog_path}")
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("   ...ERROR: Muutoslokin generointi epäonnistui. Varmista, että olet Git-repositoriossa.", file=sys.stderr)

def format_size(size_bytes: int) -> str:
    """Formats a size in bytes to a human-readable string (KB, MB)."""
    if not isinstance(size_bytes, int) or size_bytes < 0:
        return "N/A"
    if size_bytes < 1024:
        return f"{size_bytes} B"
    if size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.2f} KB"
    return f"{size_bytes / (1024 * 1024):.2f} MB"

def print_summary(files_to_summarize: list[Path | None]):
    """Prints a summary of created files and their sizes."""
    print("\n--- Yhteenveto luoduista tiedostoista ---")
    for file_path in files_to_summarize:
        if file_path and file_path.exists():
            size = file_path.stat().st_size  # noqa: E501
            print(
                f"  OK: {file_path.name:<35} ({format_size(size):>10}) -> {file_path.parent}")
    print("-------------------------------------------")

def get_pyinstaller_command(version_file: str, upx_dir: Path | None) -> list[str]:
    """Constructs the PyInstaller command list."""
    command = [
        sys.executable,
        "-m", "PyInstaller",
        "--noconfirm",
        "--onefile",
        "--windowed",
        f"--icon={ICON_FILE}",
        f"--manifest={MANIFEST_FILE}",
        # Exclude pygame, as it's being incorrectly included and bloating the
        # exe.
        "--exclude-module", "pygame",
        "--hidden-import=requests",
        "--add-data", f"logic{os.pathsep}logic",
        "--add-data", f"{ICON_FILE}{os.pathsep}.",
        f"--version-file={version_file}",
        f"--name={APP_NAME}",
        ENTRY_POINT
    ]
    if upx_dir:
        command.append("--upx-dir")
        command.append(str(upx_dir))
    return command

def main():
    """Main function that builds the executable file."""
    parser = argparse.ArgumentParser(
        description=f"Build script for {APP_NAME}.")
    parser.add_argument(
        '--increment', 
        choices=['patch', 'minor', 'major'], 
        help="Increment the version number before building."
    )
    args = parser.parse_args()

    print(f"--- Aloitetaan {APP_NAME}.exe-tiedoston rakentaminen ---")

    # 1. Handle version increment if requested
    if args.increment:
        increment_version(args.increment)

    # 2. Ensure PyInstaller is installed
    try:
        import PyInstaller
    except ImportError:
        print("PyInstalleria ei löytynyt. Asennetaan se nyt...")
        run_command([sys.executable, "-m", "pip", "install", "pyinstaller"],
                    "Asennetaan PyInstaller")
    try:
        # 2. Clean up old artifacts before building
        clean_previous_builds()

        # 3. Get version and create version file
        app_version = get_app_version()
        create_version_file(app_version)

        # 4. Find UPX and construct the PyInstaller command
        upx_dir = find_upx()
        pyinstaller_command = get_pyinstaller_command(VERSION_FILE, upx_dir)
        run_command(pyinstaller_command, "Rakennetaan .exe-tiedostoa PyInstallerilla")

        # Create the git_info.json file inside the 'dist' directory
        create_git_info_file()

        # Generate a changelog from git history
        generate_changelog(app_version)
        
        # 5. Find and run Inno Setup compiler
        iscc_path = find_iscc()
        installer_path = None
        installer_path_obj = None
        if iscc_path:
            installer_path = run_inno_setup(iscc_path, app_version)
            if installer_path:
                installer_path_obj = Path(installer_path)
        else:
            print("\n-> ⚠️ Varoitus: Inno Setup -kääntäjää (ISCC.exe) ei löytynyt.")
            print(
                "   Asenna Inno Setup (https://jrsoftware.org/isinfo.php) ja "
                "varmista, että se on asennettu oletussijaintiin, jotta "
                "asennusohjelma voidaan luoda automaattisesti.")

        # 6. Print final summary
        dist_dir = Path.cwd() / 'dist'
        files = [dist_dir / f"{APP_NAME}.exe",
                 installer_path_obj, Path.cwd() / "CHANGELOG.md"]
        print_summary(files)
    finally:
        # Final cleanup: Ensure the temporary version file is always removed.
        if os.path.exists(VERSION_FILE):
            os.remove(VERSION_FILE)
            print(f"-> INFO: Siivottu väliaikainen tiedosto: {VERSION_FILE}")

if __name__ == "__main__":
    main()

================================================================================
FILE: config.ini
================================================================================

[Settings]
language = fi



================================================================================
FILE: coverage.xml
================================================================================

<?xml version="1.0" ?>
<coverage version="7.11.3" timestamp="1765191042229" lines-valid="3563" lines-covered="2346" line-rate="0.6584" branches-covered="0" branches-valid="0" branch-rate="0" complexity="0">
	<!-- Generated by coverage.py: https://coverage.readthedocs.io/en/7.11.3 -->
	<!-- Based on https://raw.githubusercontent.com/cobertura/web/master/htdocs/xml/coverage-04.dtd -->
	<sources>
		<source>C:\PYTHONOHJELMAT\Verkko\EnableDisable</source>
	</sources>
	<packages>
		<package name="." line-rate="0.2679" branch-rate="0" complexity="0">
			<classes>
				<class name="app_logic.py" filename="app_logic.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="11" hits="1"/>
						<line number="14" hits="1"/>
						<line number="24" hits="1"/>
						<line number="31" hits="1"/>
						<line number="39" hits="1"/>
						<line number="47" hits="1"/>
						<line number="54" hits="1"/>
						<line number="61" hits="1"/>
					</lines>
				</class>
				<class name="build.py" filename="build.py" complexity="0" line-rate="0" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="0"/>
						<line number="2" hits="0"/>
						<line number="3" hits="0"/>
						<line number="4" hits="0"/>
						<line number="6" hits="0"/>
						<line number="7" hits="0"/>
						<line number="8" hits="0"/>
						<line number="9" hits="0"/>
						<line number="12" hits="0"/>
						<line number="13" hits="0"/>
						<line number="14" hits="0"/>
						<line number="15" hits="0"/>
						<line number="16" hits="0"/>
						<line number="18" hits="0"/>
						<line number="20" hits="0"/>
						<line number="21" hits="0"/>
						<line number="22" hits="0"/>
						<line number="23" hits="0"/>
						<line number="24" hits="0"/>
						<line number="26" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="30" hits="0"/>
						<line number="31" hits="0"/>
						<line number="32" hits="0"/>
						<line number="33" hits="0"/>
						<line number="34" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="40" hits="0"/>
						<line number="41" hits="0"/>
						<line number="45" hits="0"/>
						<line number="47" hits="0"/>
						<line number="48" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
						<line number="51" hits="0"/>
						<line number="52" hits="0"/>
						<line number="53" hits="0"/>
						<line number="55" hits="0"/>
						<line number="60" hits="0"/>
						<line number="61" hits="0"/>
						<line number="63" hits="0"/>
						<line number="68" hits="0"/>
						<line number="69" hits="0"/>
						<line number="70" hits="0"/>
						<line number="71" hits="0"/>
						<line number="72" hits="0"/>
						<line number="73" hits="0"/>
						<line number="75" hits="0"/>
						<line number="77" hits="0"/>
						<line number="78" hits="0"/>
						<line number="79" hits="0"/>
						<line number="80" hits="0"/>
						<line number="81" hits="0"/>
						<line number="83" hits="0"/>
						<line number="84" hits="0"/>
						<line number="85" hits="0"/>
						<line number="88" hits="0"/>
						<line number="91" hits="0"/>
						<line number="93" hits="0"/>
						<line number="94" hits="0"/>
						<line number="124" hits="0"/>
						<line number="130" hits="0"/>
						<line number="131" hits="0"/>
						<line number="132" hits="0"/>
						<line number="134" hits="0"/>
						<line number="136" hits="0"/>
						<line number="137" hits="0"/>
						<line number="139" hits="0"/>
						<line number="146" hits="0"/>
						<line number="148" hits="0"/>
						<line number="149" hits="0"/>
						<line number="150" hits="0"/>
						<line number="151" hits="0"/>
						<line number="153" hits="0"/>
						<line number="154" hits="0"/>
						<line number="158" hits="0"/>
						<line number="159" hits="0"/>
						<line number="160" hits="0"/>
						<line number="162" hits="0"/>
						<line number="164" hits="0"/>
						<line number="165" hits="0"/>
						<line number="166" hits="0"/>
						<line number="167" hits="0"/>
						<line number="169" hits="0"/>
						<line number="171" hits="0"/>
						<line number="172" hits="0"/>
						<line number="174" hits="0"/>
						<line number="175" hits="0"/>
						<line number="178" hits="0"/>
						<line number="179" hits="0"/>
						<line number="181" hits="0"/>
						<line number="182" hits="0"/>
						<line number="183" hits="0"/>
						<line number="185" hits="0"/>
						<line number="186" hits="0"/>
						<line number="187" hits="0"/>
						<line number="188" hits="0"/>
						<line number="190" hits="0"/>
						<line number="192" hits="0"/>
						<line number="193" hits="0"/>
						<line number="194" hits="0"/>
						<line number="197" hits="0"/>
						<line number="201" hits="0"/>
						<line number="202" hits="0"/>
						<line number="205" hits="0"/>
						<line number="206" hits="0"/>
						<line number="207" hits="0"/>
						<line number="208" hits="0"/>
						<line number="215" hits="0"/>
						<line number="216" hits="0"/>
						<line number="221" hits="0"/>
						<line number="222" hits="0"/>
						<line number="225" hits="0"/>
						<line number="227" hits="0"/>
						<line number="228" hits="0"/>
						<line number="230" hits="0"/>
						<line number="236" hits="0"/>
						<line number="237" hits="0"/>
						<line number="239" hits="0"/>
						<line number="242" hits="0"/>
						<line number="243" hits="0"/>
						<line number="244" hits="0"/>
						<line number="245" hits="0"/>
						<line number="246" hits="0"/>
						<line number="247" hits="0"/>
						<line number="249" hits="0"/>
						<line number="250" hits="0"/>
						<line number="251" hits="0"/>
						<line number="253" hits="0"/>
						<line number="258" hits="0"/>
						<line number="259" hits="0"/>
						<line number="261" hits="0"/>
						<line number="262" hits="0"/>
						<line number="265" hits="0"/>
						<line number="266" hits="0"/>
						<line number="267" hits="0"/>
						<line number="269" hits="0"/>
						<line number="272" hits="0"/>
						<line number="274" hits="0"/>
						<line number="277" hits="0"/>
						<line number="278" hits="0"/>
						<line number="281" hits="0"/>
						<line number="282" hits="0"/>
						<line number="284" hits="0"/>
						<line number="285" hits="0"/>
						<line number="288" hits="0"/>
						<line number="289" hits="0"/>
						<line number="290" hits="0"/>
						<line number="292" hits="0"/>
						<line number="294" hits="0"/>
						<line number="295" hits="0"/>
						<line number="296" hits="0"/>
						<line number="297" hits="0"/>
						<line number="298" hits="0"/>
						<line number="299" hits="0"/>
						<line number="300" hits="0"/>
						<line number="302" hits="0"/>
						<line number="304" hits="0"/>
						<line number="305" hits="0"/>
						<line number="306" hits="0"/>
						<line number="307" hits="0"/>
						<line number="308" hits="0"/>
						<line number="310" hits="0"/>
						<line number="312" hits="0"/>
						<line number="314" hits="0"/>
						<line number="332" hits="0"/>
						<line number="333" hits="0"/>
						<line number="334" hits="0"/>
						<line number="335" hits="0"/>
						<line number="337" hits="0"/>
						<line number="339" hits="0"/>
						<line number="341" hits="0"/>
						<line number="346" hits="0"/>
						<line number="348" hits="0"/>
						<line number="351" hits="0"/>
						<line number="352" hits="0"/>
						<line number="355" hits="0"/>
						<line number="356" hits="0"/>
						<line number="357" hits="0"/>
						<line number="358" hits="0"/>
						<line number="359" hits="0"/>
						<line number="361" hits="0"/>
						<line number="363" hits="0"/>
						<line number="366" hits="0"/>
						<line number="367" hits="0"/>
						<line number="370" hits="0"/>
						<line number="371" hits="0"/>
						<line number="372" hits="0"/>
						<line number="375" hits="0"/>
						<line number="378" hits="0"/>
						<line number="381" hits="0"/>
						<line number="382" hits="0"/>
						<line number="383" hits="0"/>
						<line number="384" hits="0"/>
						<line number="385" hits="0"/>
						<line number="386" hits="0"/>
						<line number="387" hits="0"/>
						<line number="389" hits="0"/>
						<line number="390" hits="0"/>
						<line number="396" hits="0"/>
						<line number="397" hits="0"/>
						<line number="399" hits="0"/>
						<line number="402" hits="0"/>
						<line number="403" hits="0"/>
						<line number="404" hits="0"/>
						<line number="406" hits="0"/>
						<line number="407" hits="0"/>
					</lines>
				</class>
				<class name="exceptions.py" filename="exceptions.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="10" hits="1"/>
						<line number="11" hits="1"/>
						<line number="12" hits="1"/>
						<line number="14" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
					</lines>
				</class>
				<class name="git_helper.py" filename="git_helper.py" complexity="0" line-rate="0" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="0"/>
						<line number="2" hits="0"/>
						<line number="3" hits="0"/>
						<line number="4" hits="0"/>
						<line number="6" hits="0"/>
						<line number="7" hits="0"/>
						<line number="8" hits="0"/>
						<line number="9" hits="0"/>
						<line number="12" hits="0"/>
						<line number="14" hits="0"/>
						<line number="16" hits="0"/>
						<line number="17" hits="0"/>
						<line number="18" hits="0"/>
						<line number="19" hits="0"/>
						<line number="20" hits="0"/>
						<line number="21" hits="0"/>
						<line number="22" hits="0"/>
						<line number="23" hits="0"/>
						<line number="24" hits="0"/>
						<line number="26" hits="0"/>
						<line number="29" hits="0"/>
						<line number="31" hits="0"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="41" hits="0"/>
						<line number="42" hits="0"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="46" hits="0"/>
						<line number="48" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
						<line number="51" hits="0"/>
						<line number="53" hits="0"/>
						<line number="55" hits="0"/>
						<line number="66" hits="0"/>
						<line number="72" hits="0"/>
						<line number="74" hits="0"/>
						<line number="77" hits="0"/>
						<line number="80" hits="0"/>
						<line number="84" hits="0"/>
						<line number="86" hits="0"/>
						<line number="88" hits="0"/>
						<line number="89" hits="0"/>
						<line number="90" hits="0"/>
						<line number="91" hits="0"/>
						<line number="93" hits="0"/>
						<line number="94" hits="0"/>
						<line number="95" hits="0"/>
						<line number="96" hits="0"/>
						<line number="97" hits="0"/>
						<line number="101" hits="0"/>
						<line number="102" hits="0"/>
						<line number="103" hits="0"/>
						<line number="104" hits="0"/>
						<line number="106" hits="0"/>
						<line number="107" hits="0"/>
						<line number="109" hits="0"/>
						<line number="112" hits="0"/>
						<line number="114" hits="0"/>
						<line number="115" hits="0"/>
						<line number="116" hits="0"/>
						<line number="119" hits="0"/>
						<line number="120" hits="0"/>
						<line number="121" hits="0"/>
						<line number="122" hits="0"/>
						<line number="123" hits="0"/>
						<line number="125" hits="0"/>
						<line number="126" hits="0"/>
						<line number="128" hits="0"/>
						<line number="132" hits="0"/>
						<line number="133" hits="0"/>
						<line number="134" hits="0"/>
						<line number="136" hits="0"/>
						<line number="139" hits="0"/>
						<line number="140" hits="0"/>
						<line number="141" hits="0"/>
						<line number="142" hits="0"/>
						<line number="144" hits="0"/>
						<line number="145" hits="0"/>
						<line number="147" hits="0"/>
						<line number="149" hits="0"/>
						<line number="150" hits="0"/>
						<line number="154" hits="0"/>
						<line number="155" hits="0"/>
						<line number="156" hits="0"/>
						<line number="158" hits="0"/>
						<line number="159" hits="0"/>
						<line number="162" hits="0"/>
						<line number="163" hits="0"/>
						<line number="164" hits="0"/>
						<line number="165" hits="0"/>
						<line number="166" hits="0"/>
						<line number="167" hits="0"/>
						<line number="169" hits="0"/>
						<line number="173" hits="0"/>
						<line number="174" hits="0"/>
						<line number="177" hits="0"/>
						<line number="180" hits="0"/>
						<line number="181" hits="0"/>
						<line number="183" hits="0"/>
						<line number="184" hits="0"/>
						<line number="185" hits="0"/>
						<line number="187" hits="0"/>
						<line number="189" hits="0"/>
						<line number="193" hits="0"/>
						<line number="194" hits="0"/>
						<line number="195" hits="0"/>
						<line number="196" hits="0"/>
						<line number="198" hits="0"/>
						<line number="202" hits="0"/>
						<line number="203" hits="0"/>
						<line number="206" hits="0"/>
						<line number="207" hits="0"/>
						<line number="209" hits="0"/>
						<line number="210" hits="0"/>
						<line number="213" hits="0"/>
						<line number="214" hits="0"/>
					</lines>
				</class>
				<class name="github_integration.py" filename="github_integration.py" complexity="0" line-rate="0.7727" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="19" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="30" hits="1"/>
						<line number="32" hits="1"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="40" hits="0"/>
						<line number="41" hits="0"/>
						<line number="42" hits="0"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="47" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="60" hits="0"/>
						<line number="64" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="69" hits="1"/>
						<line number="75" hits="1"/>
						<line number="79" hits="1"/>
						<line number="80" hits="1"/>
						<line number="82" hits="1"/>
						<line number="83" hits="0"/>
						<line number="84" hits="1"/>
						<line number="87" hits="1"/>
						<line number="91" hits="1"/>
						<line number="94" hits="1"/>
						<line number="112" hits="1"/>
						<line number="114" hits="1"/>
						<line number="116" hits="1"/>
						<line number="117" hits="1"/>
						<line number="118" hits="1"/>
						<line number="119" hits="0"/>
						<line number="121" hits="1"/>
						<line number="126" hits="1"/>
						<line number="127" hits="1"/>
						<line number="129" hits="0"/>
						<line number="131" hits="1"/>
						<line number="132" hits="1"/>
						<line number="135" hits="1"/>
						<line number="140" hits="1"/>
						<line number="141" hits="1"/>
						<line number="142" hits="1"/>
						<line number="145" hits="1"/>
						<line number="146" hits="1"/>
						<line number="149" hits="1"/>
						<line number="150" hits="0"/>
						<line number="153" hits="1"/>
						<line number="154" hits="0"/>
						<line number="160" hits="1"/>
					</lines>
				</class>
				<class name="localization.py" filename="localization.py" complexity="0" line-rate="0.7073" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="9" hits="1"/>
						<line number="12" hits="1"/>
						<line number="375" hits="1"/>
						<line number="377" hits="1"/>
						<line number="379" hits="1"/>
						<line number="381" hits="1"/>
						<line number="382" hits="1"/>
						<line number="383" hits="1"/>
						<line number="384" hits="1"/>
						<line number="385" hits="1"/>
						<line number="386" hits="0"/>
						<line number="387" hits="0"/>
						<line number="388" hits="1"/>
						<line number="390" hits="1"/>
						<line number="392" hits="0"/>
						<line number="393" hits="0"/>
						<line number="394" hits="0"/>
						<line number="396" hits="0"/>
						<line number="397" hits="0"/>
						<line number="398" hits="0"/>
						<line number="399" hits="0"/>
						<line number="400" hits="0"/>
						<line number="401" hits="0"/>
						<line number="402" hits="0"/>
						<line number="404" hits="1"/>
						<line number="411" hits="1"/>
						<line number="412" hits="1"/>
						<line number="413" hits="1"/>
						<line number="414" hits="1"/>
						<line number="415" hits="1"/>
						<line number="416" hits="1"/>
						<line number="417" hits="1"/>
						<line number="418" hits="1"/>
						<line number="420" hits="1"/>
						<line number="425" hits="1"/>
					</lines>
				</class>
				<class name="logger_setup.py" filename="logger_setup.py" complexity="0" line-rate="0.3913" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="12" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="22" hits="1"/>
						<line number="29" hits="0"/>
						<line number="30" hits="0"/>
						<line number="32" hits="0"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="42" hits="0"/>
						<line number="45" hits="1"/>
						<line number="47" hits="0"/>
						<line number="50" hits="1"/>
						<line number="55" hits="1"/>
						<line number="58" hits="0"/>
						<line number="61" hits="1"/>
						<line number="63" hits="1"/>
						<line number="65" hits="0"/>
						<line number="66" hits="0"/>
						<line number="67" hits="0"/>
						<line number="70" hits="1"/>
						<line number="81" hits="0"/>
						<line number="82" hits="0"/>
						<line number="85" hits="0"/>
						<line number="88" hits="0"/>
						<line number="91" hits="0"/>
						<line number="92" hits="0"/>
						<line number="95" hits="0"/>
						<line number="97" hits="0"/>
						<line number="100" hits="0"/>
						<line number="106" hits="0"/>
						<line number="107" hits="0"/>
						<line number="108" hits="0"/>
						<line number="111" hits="0"/>
						<line number="115" hits="0"/>
						<line number="116" hits="0"/>
						<line number="117" hits="0"/>
						<line number="120" hits="0"/>
					</lines>
				</class>
				<class name="main.py" filename="main.py" complexity="0" line-rate="0.9767" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="9" hits="1"/>
						<line number="10" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="23" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="31" hits="1"/>
						<line number="33" hits="1"/>
						<line number="34" hits="1"/>
						<line number="37" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="42" hits="1"/>
						<line number="43" hits="1"/>
						<line number="45" hits="1"/>
						<line number="48" hits="1"/>
						<line number="50" hits="1"/>
						<line number="53" hits="1"/>
						<line number="55" hits="1"/>
						<line number="60" hits="1"/>
						<line number="61" hits="1"/>
						<line number="64" hits="1"/>
						<line number="66" hits="1"/>
						<line number="67" hits="1"/>
						<line number="69" hits="1"/>
						<line number="71" hits="1"/>
						<line number="73" hits="1"/>
						<line number="75" hits="1"/>
						<line number="76" hits="0"/>
					</lines>
				</class>
				<class name="publish.py" filename="publish.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines/>
				</class>
				<class name="publish_dialog.py" filename="publish_dialog.py" complexity="0" line-rate="0.1633" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="9" hits="1"/>
						<line number="10" hits="1"/>
						<line number="12" hits="1"/>
						<line number="14" hits="1"/>
						<line number="18" hits="1"/>
						<line number="20" hits="0"/>
						<line number="23" hits="0"/>
						<line number="24" hits="0"/>
						<line number="25" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="31" hits="1"/>
						<line number="33" hits="0"/>
						<line number="34" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="42" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="48" hits="0"/>
						<line number="50" hits="0"/>
						<line number="51" hits="0"/>
						<line number="52" hits="0"/>
						<line number="55" hits="0"/>
						<line number="57" hits="0"/>
						<line number="58" hits="0"/>
						<line number="61" hits="0"/>
						<line number="62" hits="0"/>
						<line number="64" hits="0"/>
						<line number="67" hits="0"/>
						<line number="68" hits="0"/>
						<line number="69" hits="0"/>
						<line number="70" hits="0"/>
						<line number="73" hits="0"/>
						<line number="74" hits="0"/>
						<line number="76" hits="0"/>
						<line number="78" hits="0"/>
						<line number="81" hits="0"/>
						<line number="83" hits="0"/>
						<line number="86" hits="0"/>
						<line number="88" hits="0"/>
						<line number="90" hits="1"/>
						<line number="92" hits="0"/>
						<line number="93" hits="0"/>
						<line number="94" hits="0"/>
						<line number="98" hits="0"/>
						<line number="99" hits="0"/>
						<line number="100" hits="0"/>
						<line number="101" hits="0"/>
						<line number="102" hits="0"/>
						<line number="103" hits="0"/>
						<line number="104" hits="0"/>
						<line number="105" hits="0"/>
						<line number="107" hits="0"/>
						<line number="108" hits="0"/>
						<line number="110" hits="1"/>
						<line number="112" hits="0"/>
						<line number="113" hits="0"/>
						<line number="115" hits="0"/>
						<line number="117" hits="0"/>
						<line number="118" hits="0"/>
						<line number="119" hits="0"/>
						<line number="120" hits="0"/>
						<line number="124" hits="0"/>
						<line number="125" hits="0"/>
						<line number="126" hits="0"/>
						<line number="129" hits="0"/>
						<line number="132" hits="0"/>
						<line number="137" hits="0"/>
						<line number="141" hits="0"/>
						<line number="142" hits="0"/>
						<line number="143" hits="0"/>
						<line number="144" hits="0"/>
						<line number="147" hits="0"/>
						<line number="149" hits="1"/>
						<line number="151" hits="0"/>
						<line number="152" hits="0"/>
						<line number="153" hits="0"/>
						<line number="154" hits="0"/>
						<line number="156" hits="0"/>
						<line number="157" hits="0"/>
						<line number="159" hits="0"/>
						<line number="162" hits="0"/>
						<line number="163" hits="0"/>
						<line number="164" hits="0"/>
						<line number="165" hits="0"/>
						<line number="167" hits="0"/>
						<line number="168" hits="0"/>
						<line number="172" hits="0"/>
					</lines>
				</class>
			</classes>
		</package>
		<package name="gui" line-rate="0.4673" branch-rate="0" complexity="0">
			<classes>
				<class name="__init__.py" filename="gui/__init__.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines/>
				</class>
				<class name="action_handler.py" filename="gui/action_handler.py" complexity="0" line-rate="0.7943" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="11" hits="1"/>
						<line number="12" hits="1"/>
						<line number="13" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="21" hits="1"/>
						<line number="23" hits="1"/>
						<line number="25" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="30" hits="1"/>
						<line number="32" hits="1"/>
						<line number="33" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="37" hits="1"/>
						<line number="38" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="42" hits="1"/>
						<line number="43" hits="1"/>
						<line number="44" hits="1"/>
						<line number="46" hits="1"/>
						<line number="47" hits="0"/>
						<line number="48" hits="1"/>
						<line number="49" hits="0"/>
						<line number="50" hits="1"/>
						<line number="51" hits="1"/>
						<line number="52" hits="1"/>
						<line number="54" hits="1"/>
						<line number="55" hits="1"/>
						<line number="57" hits="1"/>
						<line number="59" hits="1"/>
						<line number="60" hits="1"/>
						<line number="62" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="65" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="70" hits="1"/>
						<line number="71" hits="1"/>
						<line number="72" hits="1"/>
						<line number="74" hits="1"/>
						<line number="75" hits="1"/>
						<line number="77" hits="1"/>
						<line number="78" hits="1"/>
						<line number="79" hits="1"/>
						<line number="81" hits="1"/>
						<line number="83" hits="1"/>
						<line number="84" hits="0"/>
						<line number="85" hits="0"/>
						<line number="87" hits="1"/>
						<line number="88" hits="1"/>
						<line number="89" hits="1"/>
						<line number="90" hits="1"/>
						<line number="92" hits="1"/>
						<line number="94" hits="1"/>
						<line number="95" hits="1"/>
						<line number="96" hits="1"/>
						<line number="98" hits="1"/>
						<line number="99" hits="1"/>
						<line number="101" hits="1"/>
						<line number="102" hits="1"/>
						<line number="103" hits="1"/>
						<line number="105" hits="1"/>
						<line number="106" hits="1"/>
						<line number="108" hits="1"/>
						<line number="109" hits="1"/>
						<line number="110" hits="1"/>
						<line number="112" hits="1"/>
						<line number="113" hits="1"/>
						<line number="114" hits="1"/>
						<line number="116" hits="1"/>
						<line number="117" hits="1"/>
						<line number="118" hits="1"/>
						<line number="120" hits="1"/>
						<line number="121" hits="0"/>
						<line number="123" hits="1"/>
						<line number="124" hits="1"/>
						<line number="125" hits="1"/>
						<line number="127" hits="1"/>
						<line number="129" hits="1"/>
						<line number="130" hits="1"/>
						<line number="132" hits="1"/>
						<line number="134" hits="0"/>
						<line number="136" hits="1"/>
						<line number="137" hits="0"/>
						<line number="138" hits="0"/>
						<line number="140" hits="1"/>
						<line number="142" hits="0"/>
						<line number="144" hits="1"/>
						<line number="145" hits="0"/>
						<line number="146" hits="0"/>
						<line number="148" hits="1"/>
						<line number="150" hits="0"/>
						<line number="152" hits="1"/>
						<line number="153" hits="0"/>
						<line number="154" hits="0"/>
						<line number="155" hits="0"/>
						<line number="157" hits="1"/>
						<line number="159" hits="1"/>
						<line number="160" hits="1"/>
						<line number="162" hits="1"/>
						<line number="163" hits="1"/>
						<line number="165" hits="1"/>
						<line number="166" hits="1"/>
						<line number="168" hits="1"/>
						<line number="169" hits="0"/>
						<line number="171" hits="1"/>
						<line number="173" hits="1"/>
						<line number="174" hits="1"/>
						<line number="175" hits="1"/>
						<line number="176" hits="1"/>
						<line number="177" hits="1"/>
						<line number="179" hits="1"/>
						<line number="180" hits="1"/>
						<line number="181" hits="1"/>
						<line number="183" hits="1"/>
						<line number="185" hits="1"/>
						<line number="186" hits="1"/>
						<line number="188" hits="1"/>
						<line number="201" hits="1"/>
						<line number="202" hits="1"/>
						<line number="206" hits="1"/>
						<line number="207" hits="1"/>
						<line number="209" hits="1"/>
						<line number="212" hits="1"/>
						<line number="213" hits="1"/>
						<line number="214" hits="1"/>
						<line number="215" hits="0"/>
						<line number="217" hits="1"/>
						<line number="219" hits="1"/>
						<line number="220" hits="1"/>
						<line number="222" hits="1"/>
						<line number="224" hits="1"/>
						<line number="225" hits="1"/>
						<line number="228" hits="0"/>
						<line number="229" hits="0"/>
						<line number="230" hits="0"/>
						<line number="231" hits="0"/>
						<line number="232" hits="0"/>
						<line number="233" hits="0"/>
						<line number="234" hits="0"/>
						<line number="235" hits="0"/>
						<line number="237" hits="0"/>
						<line number="239" hits="1"/>
						<line number="244" hits="0"/>
						<line number="246" hits="1"/>
						<line number="253" hits="0"/>
						<line number="254" hits="0"/>
						<line number="255" hits="0"/>
						<line number="256" hits="0"/>
						<line number="258" hits="1"/>
						<line number="263" hits="1"/>
						<line number="264" hits="1"/>
						<line number="265" hits="1"/>
						<line number="266" hits="1"/>
						<line number="267" hits="1"/>
						<line number="270" hits="1"/>
						<line number="273" hits="1"/>
						<line number="274" hits="0"/>
						<line number="275" hits="0"/>
						<line number="276" hits="0"/>
						<line number="277" hits="0"/>
						<line number="278" hits="0"/>
					</lines>
				</class>
				<class name="adapter_details_frame.py" filename="gui/adapter_details_frame.py" complexity="0" line-rate="0.209" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="8" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="0"/>
						<line number="16" hits="0"/>
						<line number="17" hits="0"/>
						<line number="18" hits="0"/>
						<line number="22" hits="0"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="39" hits="1"/>
						<line number="41" hits="0"/>
						<line number="42" hits="0"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="46" hits="0"/>
						<line number="47" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
						<line number="51" hits="0"/>
						<line number="52" hits="0"/>
						<line number="53" hits="0"/>
						<line number="54" hits="0"/>
						<line number="56" hits="1"/>
						<line number="58" hits="0"/>
						<line number="59" hits="0"/>
						<line number="61" hits="1"/>
						<line number="63" hits="0"/>
						<line number="64" hits="0"/>
						<line number="66" hits="1"/>
						<line number="68" hits="0"/>
						<line number="69" hits="0"/>
						<line number="70" hits="0"/>
						<line number="71" hits="0"/>
						<line number="72" hits="0"/>
						<line number="73" hits="0"/>
						<line number="75" hits="1"/>
						<line number="77" hits="0"/>
						<line number="78" hits="0"/>
						<line number="81" hits="0"/>
						<line number="83" hits="0"/>
						<line number="84" hits="0"/>
						<line number="85" hits="0"/>
						<line number="86" hits="0"/>
						<line number="89" hits="0"/>
						<line number="91" hits="1"/>
						<line number="93" hits="0"/>
						<line number="94" hits="0"/>
						<line number="95" hits="0"/>
						<line number="96" hits="0"/>
						<line number="97" hits="0"/>
						<line number="98" hits="0"/>
						<line number="100" hits="0"/>
						<line number="101" hits="0"/>
						<line number="103" hits="1"/>
						<line number="105" hits="0"/>
						<line number="106" hits="0"/>
						<line number="108" hits="1"/>
						<line number="110" hits="0"/>
						<line number="111" hits="0"/>
						<line number="112" hits="0"/>
					</lines>
				</class>
				<class name="adapter_list_frame.py" filename="gui/adapter_list_frame.py" complexity="0" line-rate="0.2917" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="7" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="0"/>
						<line number="15" hits="0"/>
						<line number="17" hits="0"/>
						<line number="18" hits="0"/>
						<line number="19" hits="0"/>
						<line number="21" hits="0"/>
						<line number="22" hits="0"/>
						<line number="23" hits="0"/>
						<line number="25" hits="1"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="30" hits="0"/>
						<line number="32" hits="1"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="40" hits="0"/>
					</lines>
				</class>
				<class name="app_context.py" filename="gui/app_context.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="9" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="33" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="38" hits="1"/>
						<line number="42" hits="1"/>
						<line number="43" hits="1"/>
						<line number="44" hits="1"/>
						<line number="46" hits="1"/>
						<line number="50" hits="1"/>
						<line number="52" hits="1"/>
						<line number="54" hits="1"/>
						<line number="56" hits="1"/>
						<line number="58" hits="1"/>
						<line number="60" hits="1"/>
						<line number="62" hits="1"/>
						<line number="64" hits="1"/>
						<line number="65" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="70" hits="1"/>
						<line number="71" hits="1"/>
						<line number="72" hits="1"/>
						<line number="73" hits="1"/>
					</lines>
				</class>
				<class name="available_networks_tab.py" filename="gui/available_networks_tab.py" complexity="0" line-rate="0.1481" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="11" hits="1"/>
						<line number="12" hits="0"/>
						<line number="13" hits="0"/>
						<line number="14" hits="0"/>
						<line number="15" hits="0"/>
						<line number="16" hits="0"/>
						<line number="18" hits="0"/>
						<line number="20" hits="1"/>
						<line number="21" hits="0"/>
						<line number="22" hits="0"/>
						<line number="24" hits="0"/>
						<line number="25" hits="0"/>
						<line number="26" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="30" hits="0"/>
						<line number="31" hits="0"/>
						<line number="32" hits="0"/>
						<line number="33" hits="0"/>
						<line number="34" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="40" hits="0"/>
						<line number="41" hits="0"/>
						<line number="42" hits="0"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="47" hits="0"/>
						<line number="48" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
						<line number="51" hits="0"/>
						<line number="52" hits="0"/>
						<line number="53" hits="0"/>
						<line number="55" hits="1"/>
						<line number="56" hits="0"/>
						<line number="57" hits="0"/>
						<line number="58" hits="0"/>
						<line number="59" hits="0"/>
						<line number="61" hits="1"/>
						<line number="62" hits="0"/>
						<line number="64" hits="1"/>
						<line number="65" hits="0"/>
						<line number="66" hits="0"/>
						<line number="67" hits="0"/>
						<line number="68" hits="0"/>
						<line number="69" hits="0"/>
						<line number="71" hits="0"/>
						<line number="72" hits="0"/>
						<line number="73" hits="0"/>
						<line number="74" hits="0"/>
						<line number="75" hits="0"/>
						<line number="77" hits="1"/>
						<line number="78" hits="0"/>
						<line number="79" hits="0"/>
						<line number="80" hits="0"/>
						<line number="81" hits="0"/>
						<line number="82" hits="0"/>
						<line number="83" hits="0"/>
						<line number="84" hits="0"/>
						<line number="86" hits="0"/>
						<line number="88" hits="1"/>
						<line number="89" hits="0"/>
						<line number="90" hits="0"/>
						<line number="91" hits="0"/>
						<line number="92" hits="0"/>
						<line number="93" hits="0"/>
						<line number="94" hits="0"/>
						<line number="95" hits="0"/>
						<line number="96" hits="0"/>
						<line number="98" hits="0"/>
						<line number="99" hits="0"/>
						<line number="100" hits="0"/>
						<line number="101" hits="0"/>
						<line number="102" hits="0"/>
						<line number="103" hits="0"/>
						<line number="104" hits="0"/>
						<line number="105" hits="0"/>
						<line number="106" hits="0"/>
						<line number="107" hits="0"/>
						<line number="112" hits="1"/>
						<line number="114" hits="0"/>
						<line number="115" hits="0"/>
						<line number="117" hits="1"/>
						<line number="118" hits="0"/>
						<line number="119" hits="0"/>
						<line number="120" hits="0"/>
						<line number="121" hits="0"/>
						<line number="123" hits="1"/>
						<line number="124" hits="0"/>
						<line number="125" hits="0"/>
						<line number="127" hits="1"/>
						<line number="128" hits="0"/>
						<line number="129" hits="0"/>
						<line number="130" hits="0"/>
						<line number="131" hits="0"/>
						<line number="132" hits="0"/>
						<line number="133" hits="0"/>
						<line number="134" hits="0"/>
						<line number="135" hits="0"/>
					</lines>
				</class>
				<class name="base_window.py" filename="gui/base_window.py" complexity="0" line-rate="0.4348" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="11" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="0"/>
						<line number="21" hits="0"/>
						<line number="22" hits="0"/>
						<line number="23" hits="0"/>
						<line number="25" hits="0"/>
						<line number="26" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="31" hits="0"/>
						<line number="32" hits="0"/>
						<line number="34" hits="1"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
					</lines>
				</class>
				<class name="conftest.py" filename="gui/conftest.py" complexity="0" line-rate="0" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="0"/>
						<line number="2" hits="0"/>
						<line number="4" hits="0"/>
						<line number="5" hits="0"/>
						<line number="14" hits="0"/>
						<line number="15" hits="0"/>
						<line number="16" hits="0"/>
						<line number="17" hits="0"/>
					</lines>
				</class>
				<class name="constants.py" filename="gui/constants.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="9" hits="1"/>
						<line number="10" hits="1"/>
						<line number="12" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
					</lines>
				</class>
				<class name="diagnostics_frame.py" filename="gui/diagnostics_frame.py" complexity="0" line-rate="0.3214" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="8" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="0"/>
						<line number="19" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="31" hits="1"/>
						<line number="33" hits="0"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="40" hits="0"/>
						<line number="41" hits="0"/>
						<line number="42" hits="0"/>
						<line number="44" hits="0"/>
						<line number="46" hits="1"/>
						<line number="48" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
						<line number="52" hits="1"/>
						<line number="54" hits="0"/>
					</lines>
				</class>
				<class name="dialogs.py" filename="gui/dialogs.py" complexity="0" line-rate="0.175" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="12" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="0"/>
						<line number="18" hits="0"/>
						<line number="19" hits="0"/>
						<line number="20" hits="0"/>
						<line number="22" hits="0"/>
						<line number="23" hits="0"/>
						<line number="24" hits="0"/>
						<line number="26" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="31" hits="0"/>
						<line number="32" hits="0"/>
						<line number="33" hits="0"/>
						<line number="34" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="39" hits="1"/>
						<line number="40" hits="0"/>
						<line number="41" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="46" hits="0"/>
						<line number="47" hits="0"/>
						<line number="48" hits="0"/>
						<line number="51" hits="0"/>
						<line number="52" hits="0"/>
						<line number="53" hits="0"/>
						<line number="54" hits="0"/>
						<line number="55" hits="0"/>
						<line number="56" hits="0"/>
						<line number="59" hits="0"/>
						<line number="60" hits="0"/>
						<line number="61" hits="0"/>
						<line number="62" hits="0"/>
						<line number="63" hits="0"/>
						<line number="66" hits="0"/>
						<line number="67" hits="0"/>
						<line number="68" hits="0"/>
						<line number="69" hits="0"/>
						<line number="71" hits="0"/>
						<line number="72" hits="0"/>
						<line number="73" hits="0"/>
						<line number="76" hits="0"/>
						<line number="77" hits="0"/>
						<line number="79" hits="0"/>
						<line number="80" hits="0"/>
						<line number="81" hits="0"/>
						<line number="82" hits="0"/>
						<line number="84" hits="0"/>
						<line number="85" hits="0"/>
						<line number="87" hits="1"/>
						<line number="90" hits="0"/>
						<line number="91" hits="0"/>
						<line number="93" hits="0"/>
						<line number="94" hits="0"/>
						<line number="95" hits="0"/>
						<line number="97" hits="0"/>
						<line number="99" hits="1"/>
						<line number="101" hits="0"/>
						<line number="102" hits="0"/>
						<line number="103" hits="0"/>
						<line number="104" hits="0"/>
						<line number="106" hits="0"/>
						<line number="107" hits="0"/>
						<line number="108" hits="0"/>
						<line number="111" hits="0"/>
						<line number="112" hits="0"/>
						<line number="114" hits="1"/>
						<line number="115" hits="0"/>
						<line number="116" hits="0"/>
					</lines>
				</class>
				<class name="main_controller.py" filename="gui/main_controller.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="15" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="20" hits="1"/>
						<line number="22" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="30" hits="1"/>
						<line number="31" hits="1"/>
						<line number="32" hits="1"/>
						<line number="34" hits="1"/>
						<line number="36" hits="1"/>
						<line number="37" hits="1"/>
						<line number="38" hits="1"/>
						<line number="39" hits="1"/>
						<line number="41" hits="1"/>
						<line number="42" hits="1"/>
						<line number="45" hits="1"/>
						<line number="47" hits="1"/>
						<line number="49" hits="1"/>
						<line number="50" hits="1"/>
						<line number="51" hits="1"/>
						<line number="53" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
					</lines>
				</class>
				<class name="main_window.py" filename="gui/main_window.py" complexity="0" line-rate="0.3571" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="9" hits="1"/>
						<line number="10" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="1"/>
						<line number="16" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="24" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="31" hits="0"/>
						<line number="33" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="40" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="48" hits="0"/>
						<line number="52" hits="0"/>
						<line number="55" hits="0"/>
						<line number="56" hits="0"/>
						<line number="57" hits="0"/>
						<line number="59" hits="1"/>
						<line number="61" hits="0"/>
						<line number="62" hits="0"/>
						<line number="64" hits="0"/>
						<line number="65" hits="0"/>
						<line number="66" hits="0"/>
						<line number="72" hits="0"/>
						<line number="74" hits="0"/>
						<line number="75" hits="0"/>
						<line number="77" hits="0"/>
						<line number="78" hits="0"/>
						<line number="80" hits="1"/>
						<line number="81" hits="0"/>
						<line number="82" hits="0"/>
						<line number="84" hits="1"/>
						<line number="86" hits="0"/>
						<line number="88" hits="0"/>
						<line number="90" hits="1"/>
						<line number="93" hits="0"/>
						<line number="95" hits="0"/>
						<line number="96" hits="0"/>
						<line number="98" hits="1"/>
						<line number="100" hits="0"/>
						<line number="101" hits="0"/>
						<line number="102" hits="0"/>
						<line number="103" hits="0"/>
						<line number="104" hits="0"/>
						<line number="106" hits="0"/>
						<line number="107" hits="0"/>
						<line number="110" hits="0"/>
						<line number="111" hits="0"/>
						<line number="113" hits="1"/>
						<line number="115" hits="0"/>
						<line number="116" hits="0"/>
					</lines>
				</class>
				<class name="menu_handler.py" filename="gui/menu_handler.py" complexity="0" line-rate="0.2812" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="8" hits="1"/>
						<line number="9" hits="1"/>
						<line number="10" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="15" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="0"/>
						<line number="19" hits="0"/>
						<line number="20" hits="0"/>
						<line number="22" hits="0"/>
						<line number="24" hits="0"/>
						<line number="59" hits="0"/>
						<line number="60" hits="0"/>
						<line number="61" hits="0"/>
						<line number="64" hits="0"/>
						<line number="68" hits="0"/>
						<line number="70" hits="0"/>
						<line number="71" hits="0"/>
						<line number="72" hits="0"/>
						<line number="74" hits="0"/>
						<line number="76" hits="1"/>
						<line number="78" hits="0"/>
						<line number="79" hits="0"/>
						<line number="80" hits="0"/>
						<line number="82" hits="1"/>
						<line number="84" hits="0"/>
						<line number="85" hits="0"/>
						<line number="86" hits="0"/>
						<line number="87" hits="0"/>
						<line number="88" hits="0"/>
						<line number="89" hits="0"/>
						<line number="90" hits="0"/>
						<line number="91" hits="0"/>
						<line number="93" hits="0"/>
						<line number="95" hits="0"/>
						<line number="100" hits="1"/>
						<line number="102" hits="0"/>
						<line number="106" hits="0"/>
						<line number="108" hits="1"/>
						<line number="110" hits="0"/>
						<line number="111" hits="0"/>
						<line number="112" hits="0"/>
						<line number="113" hits="0"/>
						<line number="114" hits="0"/>
						<line number="115" hits="0"/>
						<line number="116" hits="0"/>
						<line number="117" hits="0"/>
						<line number="119" hits="1"/>
						<line number="121" hits="0"/>
						<line number="123" hits="0"/>
						<line number="125" hits="0"/>
						<line number="126" hits="0"/>
						<line number="129" hits="0"/>
						<line number="135" hits="0"/>
						<line number="136" hits="0"/>
						<line number="137" hits="0"/>
						<line number="141" hits="0"/>
					</lines>
				</class>
				<class name="netstat_window.py" filename="gui/netstat_window.py" complexity="0" line-rate="0.1744" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="10" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="0"/>
						<line number="15" hits="0"/>
						<line number="16" hits="0"/>
						<line number="18" hits="0"/>
						<line number="19" hits="0"/>
						<line number="21" hits="1"/>
						<line number="22" hits="0"/>
						<line number="23" hits="0"/>
						<line number="26" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="30" hits="0"/>
						<line number="31" hits="0"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="40" hits="0"/>
						<line number="41" hits="0"/>
						<line number="42" hits="0"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="47" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
						<line number="51" hits="0"/>
						<line number="53" hits="0"/>
						<line number="54" hits="0"/>
						<line number="55" hits="0"/>
						<line number="56" hits="0"/>
						<line number="57" hits="0"/>
						<line number="58" hits="0"/>
						<line number="60" hits="1"/>
						<line number="62" hits="0"/>
						<line number="63" hits="0"/>
						<line number="65" hits="1"/>
						<line number="67" hits="0"/>
						<line number="69" hits="1"/>
						<line number="71" hits="0"/>
						<line number="72" hits="0"/>
						<line number="74" hits="0"/>
						<line number="75" hits="0"/>
						<line number="76" hits="0"/>
						<line number="77" hits="0"/>
						<line number="78" hits="0"/>
						<line number="86" hits="1"/>
						<line number="88" hits="0"/>
						<line number="89" hits="0"/>
						<line number="91" hits="1"/>
						<line number="92" hits="0"/>
						<line number="93" hits="0"/>
						<line number="94" hits="0"/>
						<line number="95" hits="0"/>
						<line number="96" hits="0"/>
						<line number="98" hits="1"/>
						<line number="99" hits="0"/>
						<line number="100" hits="0"/>
						<line number="101" hits="0"/>
						<line number="102" hits="0"/>
						<line number="104" hits="0"/>
						<line number="105" hits="0"/>
						<line number="107" hits="0"/>
						<line number="108" hits="0"/>
						<line number="109" hits="0"/>
						<line number="111" hits="0"/>
						<line number="112" hits="0"/>
						<line number="114" hits="0"/>
						<line number="115" hits="0"/>
						<line number="116" hits="0"/>
						<line number="117" hits="0"/>
						<line number="118" hits="0"/>
						<line number="119" hits="0"/>
						<line number="120" hits="0"/>
						<line number="121" hits="0"/>
					</lines>
				</class>
				<class name="polling_manager.py" filename="gui/polling_manager.py" complexity="0" line-rate="0.7624" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="11" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="26" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="31" hits="1"/>
						<line number="33" hits="1"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="41" hits="1"/>
						<line number="46" hits="1"/>
						<line number="47" hits="1"/>
						<line number="55" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="61" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="65" hits="0"/>
						<line number="66" hits="0"/>
						<line number="67" hits="0"/>
						<line number="68" hits="1"/>
						<line number="70" hits="1"/>
						<line number="75" hits="1"/>
						<line number="76" hits="1"/>
						<line number="77" hits="1"/>
						<line number="78" hits="0"/>
						<line number="79" hits="1"/>
						<line number="83" hits="1"/>
						<line number="84" hits="1"/>
						<line number="85" hits="1"/>
						<line number="87" hits="0"/>
						<line number="88" hits="0"/>
						<line number="90" hits="0"/>
						<line number="93" hits="0"/>
						<line number="94" hits="0"/>
						<line number="96" hits="0"/>
						<line number="98" hits="1"/>
						<line number="99" hits="1"/>
						<line number="100" hits="1"/>
						<line number="102" hits="1"/>
						<line number="103" hits="1"/>
						<line number="104" hits="1"/>
						<line number="105" hits="1"/>
						<line number="107" hits="1"/>
						<line number="108" hits="1"/>
						<line number="109" hits="1"/>
						<line number="110" hits="1"/>
						<line number="113" hits="1"/>
						<line number="114" hits="1"/>
						<line number="116" hits="1"/>
						<line number="117" hits="1"/>
						<line number="120" hits="1"/>
						<line number="124" hits="1"/>
						<line number="126" hits="1"/>
						<line number="128" hits="0"/>
						<line number="129" hits="0"/>
						<line number="130" hits="0"/>
						<line number="132" hits="0"/>
						<line number="133" hits="0"/>
						<line number="135" hits="1"/>
						<line number="140" hits="1"/>
						<line number="143" hits="1"/>
						<line number="144" hits="1"/>
						<line number="145" hits="1"/>
						<line number="146" hits="1"/>
						<line number="147" hits="0"/>
						<line number="148" hits="0"/>
						<line number="150" hits="1"/>
						<line number="151" hits="1"/>
						<line number="153" hits="1"/>
						<line number="156" hits="1"/>
						<line number="159" hits="1"/>
						<line number="160" hits="1"/>
						<line number="161" hits="0"/>
						<line number="162" hits="0"/>
						<line number="164" hits="1"/>
						<line number="166" hits="1"/>
						<line number="168" hits="1"/>
						<line number="169" hits="1"/>
						<line number="170" hits="1"/>
						<line number="171" hits="1"/>
					</lines>
				</class>
				<class name="publish_window.py" filename="gui/publish_window.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines/>
				</class>
				<class name="queue_handler.py" filename="gui/queue_handler.py" complexity="0" line-rate="0.8627" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="11" hits="1"/>
						<line number="15" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="50" hits="1"/>
						<line number="51" hits="1"/>
						<line number="53" hits="1"/>
						<line number="54" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="61" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="65" hits="1"/>
						<line number="67" hits="1"/>
						<line number="68" hits="1"/>
						<line number="69" hits="1"/>
						<line number="70" hits="1"/>
						<line number="72" hits="1"/>
						<line number="73" hits="1"/>
						<line number="74" hits="1"/>
						<line number="75" hits="1"/>
						<line number="76" hits="1"/>
						<line number="78" hits="1"/>
						<line number="79" hits="1"/>
						<line number="80" hits="1"/>
						<line number="81" hits="1"/>
						<line number="83" hits="1"/>
						<line number="84" hits="1"/>
						<line number="86" hits="1"/>
						<line number="87" hits="1"/>
						<line number="89" hits="1"/>
						<line number="90" hits="1"/>
						<line number="91" hits="1"/>
						<line number="93" hits="1"/>
						<line number="94" hits="1"/>
						<line number="95" hits="1"/>
						<line number="96" hits="1"/>
						<line number="98" hits="1"/>
						<line number="100" hits="1"/>
						<line number="102" hits="0"/>
						<line number="103" hits="0"/>
						<line number="105" hits="1"/>
						<line number="106" hits="0"/>
						<line number="107" hits="0"/>
						<line number="109" hits="1"/>
						<line number="110" hits="1"/>
						<line number="111" hits="1"/>
						<line number="113" hits="1"/>
						<line number="114" hits="0"/>
						<line number="115" hits="0"/>
						<line number="117" hits="1"/>
						<line number="118" hits="1"/>
						<line number="119" hits="1"/>
						<line number="120" hits="1"/>
						<line number="122" hits="1"/>
						<line number="124" hits="1"/>
						<line number="125" hits="1"/>
						<line number="126" hits="1"/>
						<line number="129" hits="1"/>
						<line number="131" hits="1"/>
						<line number="132" hits="1"/>
						<line number="133" hits="1"/>
						<line number="135" hits="1"/>
						<line number="137" hits="1"/>
						<line number="138" hits="1"/>
						<line number="139" hits="1"/>
						<line number="140" hits="1"/>
						<line number="141" hits="1"/>
						<line number="143" hits="1"/>
						<line number="144" hits="1"/>
						<line number="146" hits="1"/>
						<line number="148" hits="1"/>
						<line number="149" hits="1"/>
						<line number="151" hits="1"/>
						<line number="153" hits="0"/>
						<line number="154" hits="0"/>
						<line number="155" hits="0"/>
						<line number="157" hits="1"/>
						<line number="159" hits="0"/>
						<line number="160" hits="0"/>
						<line number="161" hits="0"/>
						<line number="165" hits="1"/>
						<line number="167" hits="1"/>
						<line number="168" hits="1"/>
						<line number="169" hits="0"/>
						<line number="170" hits="0"/>
					</lines>
				</class>
				<class name="saved_profiles_tab.py" filename="gui/saved_profiles_tab.py" complexity="0" line-rate="0.1837" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="11" hits="1"/>
						<line number="12" hits="0"/>
						<line number="13" hits="0"/>
						<line number="14" hits="0"/>
						<line number="15" hits="0"/>
						<line number="17" hits="0"/>
						<line number="19" hits="1"/>
						<line number="20" hits="0"/>
						<line number="21" hits="0"/>
						<line number="23" hits="0"/>
						<line number="24" hits="0"/>
						<line number="25" hits="0"/>
						<line number="26" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="31" hits="0"/>
						<line number="32" hits="0"/>
						<line number="33" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="40" hits="0"/>
						<line number="41" hits="0"/>
						<line number="42" hits="0"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="47" hits="1"/>
						<line number="48" hits="0"/>
						<line number="49" hits="0"/>
						<line number="51" hits="1"/>
						<line number="53" hits="0"/>
						<line number="54" hits="0"/>
						<line number="56" hits="1"/>
						<line number="57" hits="0"/>
						<line number="58" hits="0"/>
						<line number="59" hits="0"/>
						<line number="60" hits="0"/>
						<line number="62" hits="0"/>
						<line number="63" hits="0"/>
						<line number="64" hits="0"/>
						<line number="66" hits="1"/>
						<line number="67" hits="0"/>
						<line number="68" hits="0"/>
						<line number="69" hits="0"/>
						<line number="70" hits="0"/>
						<line number="71" hits="0"/>
						<line number="72" hits="0"/>
						<line number="73" hits="0"/>
						<line number="74" hits="0"/>
						<line number="79" hits="1"/>
						<line number="80" hits="0"/>
						<line number="81" hits="0"/>
						<line number="83" hits="1"/>
						<line number="84" hits="0"/>
						<line number="85" hits="0"/>
						<line number="86" hits="0"/>
						<line number="87" hits="0"/>
						<line number="88" hits="0"/>
						<line number="89" hits="0"/>
						<line number="90" hits="0"/>
						<line number="91" hits="0"/>
						<line number="93" hits="1"/>
						<line number="94" hits="0"/>
						<line number="95" hits="0"/>
						<line number="97" hits="1"/>
						<line number="98" hits="0"/>
						<line number="99" hits="0"/>
						<line number="100" hits="0"/>
						<line number="101" hits="0"/>
						<line number="102" hits="0"/>
						<line number="103" hits="0"/>
						<line number="104" hits="0"/>
						<line number="105" hits="0"/>
						<line number="106" hits="0"/>
						<line number="107" hits="0"/>
						<line number="108" hits="0"/>
						<line number="109" hits="0"/>
						<line number="111" hits="1"/>
						<line number="112" hits="0"/>
						<line number="113" hits="0"/>
						<line number="114" hits="0"/>
						<line number="115" hits="0"/>
						<line number="116" hits="0"/>
						<line number="117" hits="0"/>
						<line number="118" hits="0"/>
						<line number="120" hits="1"/>
						<line number="121" hits="0"/>
						<line number="122" hits="0"/>
						<line number="124" hits="1"/>
						<line number="125" hits="0"/>
					</lines>
				</class>
				<class name="traceroute_window.py" filename="gui/traceroute_window.py" complexity="0" line-rate="0.2642" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="12" hits="1"/>
						<line number="15" hits="1"/>
						<line number="16" hits="0"/>
						<line number="17" hits="0"/>
						<line number="19" hits="1"/>
						<line number="20" hits="0"/>
						<line number="21" hits="0"/>
						<line number="24" hits="0"/>
						<line number="25" hits="0"/>
						<line number="26" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="30" hits="0"/>
						<line number="31" hits="0"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="40" hits="0"/>
						<line number="42" hits="1"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="46" hits="0"/>
						<line number="48" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
						<line number="52" hits="0"/>
						<line number="53" hits="0"/>
						<line number="55" hits="0"/>
						<line number="56" hits="0"/>
						<line number="61" hits="1"/>
						<line number="64" hits="0"/>
						<line number="65" hits="0"/>
						<line number="66" hits="0"/>
						<line number="67" hits="0"/>
						<line number="68" hits="0"/>
						<line number="69" hits="0"/>
						<line number="71" hits="1"/>
						<line number="75" hits="0"/>
						<line number="76" hits="0"/>
						<line number="77" hits="0"/>
					</lines>
				</class>
				<class name="utils.py" filename="gui/utils.py" complexity="0" line-rate="0.3913" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="3" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="0"/>
						<line number="9" hits="0"/>
						<line number="10" hits="0"/>
						<line number="11" hits="0"/>
						<line number="12" hits="0"/>
						<line number="13" hits="0"/>
						<line number="14" hits="0"/>
						<line number="16" hits="1"/>
						<line number="17" hits="0"/>
						<line number="19" hits="1"/>
						<line number="20" hits="0"/>
						<line number="21" hits="0"/>
						<line number="23" hits="1"/>
						<line number="24" hits="0"/>
						<line number="25" hits="0"/>
						<line number="27" hits="1"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="30" hits="0"/>
						<line number="32" hits="1"/>
						<line number="33" hits="0"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="42" hits="0"/>
						<line number="44" hits="1"/>
						<line number="45" hits="0"/>
						<line number="46" hits="0"/>
						<line number="47" hits="0"/>
						<line number="48" hits="0"/>
						<line number="50" hits="1"/>
						<line number="52" hits="0"/>
						<line number="54" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="60" hits="1"/>
						<line number="62" hits="1"/>
						<line number="63" hits="1"/>
						<line number="65" hits="1"/>
					</lines>
				</class>
				<class name="wifi_queue_handler.py" filename="gui/wifi_queue_handler.py" complexity="0" line-rate="0.725" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="9" hits="1"/>
						<line number="10" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
						<line number="21" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="29" hits="1"/>
						<line number="31" hits="1"/>
						<line number="33" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="39" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="42" hits="0"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="46" hits="0"/>
						<line number="48" hits="1"/>
						<line number="49" hits="1"/>
						<line number="50" hits="1"/>
						<line number="51" hits="0"/>
						<line number="52" hits="0"/>
						<line number="54" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="57" hits="0"/>
						<line number="58" hits="0"/>
					</lines>
				</class>
				<class name="wifi_status_frame.py" filename="gui/wifi_status_frame.py" complexity="0" line-rate="0.25" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="7" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="0"/>
						<line number="15" hits="0"/>
						<line number="19" hits="0"/>
						<line number="25" hits="0"/>
						<line number="26" hits="0"/>
						<line number="28" hits="1"/>
						<line number="29" hits="0"/>
						<line number="30" hits="0"/>
						<line number="32" hits="0"/>
						<line number="33" hits="0"/>
						<line number="34" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="39" hits="0"/>
						<line number="41" hits="1"/>
						<line number="43" hits="0"/>
						<line number="44" hits="0"/>
						<line number="45" hits="0"/>
						<line number="47" hits="0"/>
						<line number="48" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
					</lines>
				</class>
				<class name="wifi_window.py" filename="gui/wifi_window.py" complexity="0" line-rate="0.3333" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="0"/>
						<line number="16" hits="0"/>
						<line number="17" hits="0"/>
						<line number="19" hits="1"/>
						<line number="20" hits="0"/>
						<line number="21" hits="0"/>
						<line number="23" hits="0"/>
						<line number="24" hits="0"/>
						<line number="26" hits="0"/>
						<line number="27" hits="0"/>
						<line number="28" hits="0"/>
						<line number="29" hits="0"/>
						<line number="32" hits="0"/>
						<line number="33" hits="0"/>
						<line number="35" hits="0"/>
						<line number="36" hits="0"/>
						<line number="37" hits="0"/>
						<line number="39" hits="1"/>
						<line number="41" hits="0"/>
						<line number="42" hits="0"/>
						<line number="43" hits="0"/>
						<line number="45" hits="1"/>
						<line number="47" hits="0"/>
						<line number="48" hits="0"/>
						<line number="49" hits="0"/>
						<line number="50" hits="0"/>
						<line number="51" hits="0"/>
						<line number="53" hits="1"/>
						<line number="55" hits="0"/>
						<line number="56" hits="0"/>
					</lines>
				</class>
			</classes>
		</package>
		<package name="logic" line-rate="0.9456" branch-rate="0" complexity="0">
			<classes>
				<class name="__init__.py" filename="logic/__init__.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines/>
				</class>
				<class name="adapters.py" filename="logic/adapters.py" complexity="0" line-rate="0.9615" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
						<line number="16" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="0"/>
						<line number="26" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="0"/>
						<line number="31" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="37" hits="1"/>
						<line number="39" hits="1"/>
						<line number="41" hits="1"/>
						<line number="44" hits="1"/>
						<line number="45" hits="1"/>
						<line number="52" hits="1"/>
						<line number="53" hits="1"/>
						<line number="57" hits="1"/>
						<line number="60" hits="1"/>
						<line number="66" hits="1"/>
						<line number="67" hits="1"/>
						<line number="71" hits="1"/>
						<line number="72" hits="1"/>
						<line number="74" hits="1"/>
						<line number="75" hits="1"/>
						<line number="76" hits="1"/>
						<line number="77" hits="1"/>
						<line number="79" hits="1"/>
						<line number="85" hits="1"/>
						<line number="87" hits="1"/>
						<line number="88" hits="1"/>
						<line number="89" hits="1"/>
						<line number="90" hits="1"/>
						<line number="91" hits="1"/>
						<line number="92" hits="1"/>
						<line number="93" hits="1"/>
						<line number="96" hits="1"/>
						<line number="99" hits="1"/>
						<line number="100" hits="1"/>
						<line number="102" hits="1"/>
					</lines>
				</class>
				<class name="command_utils.py" filename="logic/command_utils.py" complexity="0" line-rate="0.8889" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="15" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="27" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="37" hits="1"/>
						<line number="38" hits="0"/>
						<line number="39" hits="0"/>
						<line number="40" hits="1"/>
						<line number="42" hits="1"/>
						<line number="43" hits="1"/>
						<line number="46" hits="1"/>
						<line number="54" hits="1"/>
						<line number="55" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="61" hits="1"/>
						<line number="62" hits="1"/>
						<line number="65" hits="1"/>
						<line number="72" hits="1"/>
						<line number="74" hits="1"/>
						<line number="75" hits="1"/>
						<line number="76" hits="1"/>
						<line number="77" hits="1"/>
						<line number="78" hits="1"/>
						<line number="80" hits="1"/>
						<line number="81" hits="1"/>
						<line number="84" hits="1"/>
						<line number="97" hits="1"/>
						<line number="99" hits="1"/>
						<line number="100" hits="1"/>
						<line number="101" hits="1"/>
						<line number="102" hits="0"/>
						<line number="104" hits="1"/>
						<line number="105" hits="0"/>
						<line number="107" hits="1"/>
						<line number="109" hits="1"/>
						<line number="111" hits="1"/>
						<line number="113" hits="0"/>
						<line number="118" hits="0"/>
						<line number="119" hits="0"/>
						<line number="120" hits="0"/>
						<line number="122" hits="1"/>
						<line number="126" hits="1"/>
						<line number="128" hits="1"/>
						<line number="129" hits="1"/>
						<line number="131" hits="1"/>
						<line number="132" hits="1"/>
						<line number="136" hits="1"/>
						<line number="137" hits="1"/>
						<line number="138" hits="1"/>
						<line number="140" hits="1"/>
						<line number="141" hits="1"/>
						<line number="142" hits="1"/>
					</lines>
				</class>
				<class name="diagnostics.py" filename="logic/diagnostics.py" complexity="0" line-rate="0.9394" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="12" hits="1"/>
						<line number="15" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="32" hits="1"/>
						<line number="33" hits="1"/>
						<line number="35" hits="1"/>
						<line number="37" hits="1"/>
						<line number="38" hits="1"/>
						<line number="41" hits="1"/>
						<line number="43" hits="1"/>
						<line number="45" hits="1"/>
						<line number="47" hits="1"/>
						<line number="48" hits="1"/>
						<line number="49" hits="1"/>
						<line number="52" hits="1"/>
						<line number="53" hits="1"/>
						<line number="54" hits="0"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="60" hits="1"/>
						<line number="61" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="70" hits="1"/>
						<line number="71" hits="1"/>
						<line number="72" hits="1"/>
						<line number="73" hits="0"/>
						<line number="74" hits="0"/>
						<line number="75" hits="0"/>
						<line number="79" hits="1"/>
						<line number="80" hits="1"/>
						<line number="81" hits="1"/>
						<line number="83" hits="1"/>
						<line number="85" hits="1"/>
						<line number="86" hits="1"/>
						<line number="87" hits="1"/>
						<line number="88" hits="1"/>
						<line number="90" hits="1"/>
						<line number="91" hits="1"/>
						<line number="92" hits="1"/>
						<line number="95" hits="1"/>
						<line number="98" hits="1"/>
						<line number="99" hits="1"/>
						<line number="104" hits="1"/>
						<line number="108" hits="1"/>
						<line number="112" hits="1"/>
						<line number="113" hits="1"/>
						<line number="114" hits="1"/>
						<line number="116" hits="1"/>
					</lines>
				</class>
				<class name="system.py" filename="logic/system.py" complexity="0" line-rate="0.9773" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
						<line number="16" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="22" hits="1"/>
						<line number="27" hits="0"/>
						<line number="36" hits="1"/>
						<line number="42" hits="1"/>
						<line number="44" hits="1"/>
						<line number="49" hits="1"/>
						<line number="51" hits="1"/>
						<line number="56" hits="1"/>
						<line number="60" hits="1"/>
						<line number="62" hits="1"/>
						<line number="64" hits="1"/>
						<line number="68" hits="1"/>
						<line number="73" hits="1"/>
						<line number="74" hits="1"/>
						<line number="78" hits="1"/>
						<line number="82" hits="1"/>
						<line number="84" hits="1"/>
						<line number="86" hits="1"/>
						<line number="87" hits="1"/>
						<line number="88" hits="1"/>
						<line number="92" hits="1"/>
						<line number="93" hits="1"/>
						<line number="97" hits="1"/>
						<line number="99" hits="1"/>
						<line number="104" hits="1"/>
						<line number="105" hits="1"/>
						<line number="107" hits="1"/>
						<line number="108" hits="1"/>
						<line number="110" hits="1"/>
						<line number="112" hits="1"/>
					</lines>
				</class>
				<class name="wifi.py" filename="logic/wifi.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="12" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="26" hits="1"/>
						<line number="28" hits="1"/>
						<line number="32" hits="1"/>
						<line number="33" hits="1"/>
						<line number="37" hits="1"/>
						<line number="45" hits="1"/>
						<line number="46" hits="1"/>
						<line number="49" hits="1"/>
						<line number="51" hits="1"/>
						<line number="52" hits="1"/>
						<line number="54" hits="1"/>
						<line number="55" hits="1"/>
						<line number="62" hits="1"/>
						<line number="64" hits="1"/>
						<line number="66" hits="1"/>
						<line number="70" hits="1"/>
						<line number="85" hits="1"/>
						<line number="86" hits="1"/>
						<line number="87" hits="1"/>
						<line number="88" hits="1"/>
						<line number="89" hits="1"/>
						<line number="91" hits="1"/>
						<line number="93" hits="1"/>
						<line number="94" hits="1"/>
						<line number="96" hits="1"/>
						<line number="100" hits="1"/>
						<line number="101" hits="1"/>
						<line number="102" hits="1"/>
						<line number="105" hits="1"/>
						<line number="107" hits="1"/>
						<line number="112" hits="1"/>
						<line number="133" hits="1"/>
						<line number="134" hits="1"/>
						<line number="135" hits="1"/>
						<line number="136" hits="1"/>
						<line number="137" hits="1"/>
						<line number="139" hits="1"/>
					</lines>
				</class>
				<class name="wifi_profile_manager.py" filename="logic/wifi_profile_manager.py" complexity="0" line-rate="0.9302" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="15" hits="1"/>
						<line number="23" hits="1"/>
						<line number="25" hits="1"/>
						<line number="26" hits="1"/>
						<line number="28" hits="1"/>
						<line number="30" hits="1"/>
						<line number="31" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="38" hits="1"/>
						<line number="50" hits="1"/>
						<line number="53" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="60" hits="1"/>
						<line number="62" hits="1"/>
						<line number="63" hits="0"/>
						<line number="64" hits="0"/>
						<line number="67" hits="1"/>
						<line number="68" hits="1"/>
						<line number="70" hits="1"/>
						<line number="72" hits="1"/>
						<line number="73" hits="1"/>
						<line number="74" hits="1"/>
						<line number="76" hits="1"/>
						<line number="77" hits="1"/>
						<line number="78" hits="1"/>
						<line number="79" hits="1"/>
						<line number="83" hits="0"/>
						<line number="85" hits="1"/>
						<line number="87" hits="1"/>
						<line number="88" hits="1"/>
					</lines>
				</class>
			</classes>
		</package>
		<package name="tests" line-rate="0.9841" branch-rate="0" complexity="0">
			<classes>
				<class name="__init__.py" filename="tests/__init__.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines/>
				</class>
				<class name="conftest.py" filename="tests/conftest.py" complexity="0" line-rate="0.5" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="14" hits="0"/>
						<line number="15" hits="0"/>
						<line number="16" hits="0"/>
						<line number="17" hits="0"/>
					</lines>
				</class>
				<class name="test_adapters.py" filename="tests/test_adapters.py" complexity="0" line-rate="0.9881" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="24" hits="1"/>
						<line number="27" hits="1"/>
						<line number="29" hits="1"/>
						<line number="30" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="39" hits="1"/>
						<line number="42" hits="1"/>
						<line number="44" hits="1"/>
						<line number="46" hits="1"/>
						<line number="47" hits="1"/>
						<line number="49" hits="1"/>
						<line number="50" hits="1"/>
						<line number="54" hits="1"/>
						<line number="55" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="61" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="68" hits="1"/>
						<line number="69" hits="1"/>
						<line number="72" hits="1"/>
						<line number="73" hits="1"/>
						<line number="75" hits="1"/>
						<line number="76" hits="1"/>
						<line number="78" hits="1"/>
						<line number="79" hits="1"/>
						<line number="83" hits="1"/>
						<line number="84" hits="1"/>
						<line number="87" hits="1"/>
						<line number="88" hits="1"/>
						<line number="91" hits="1"/>
						<line number="93" hits="1"/>
						<line number="95" hits="1"/>
						<line number="100" hits="1"/>
						<line number="101" hits="1"/>
						<line number="105" hits="1"/>
						<line number="109" hits="1"/>
						<line number="112" hits="1"/>
						<line number="115" hits="1"/>
						<line number="116" hits="1"/>
						<line number="117" hits="1"/>
						<line number="119" hits="1"/>
						<line number="120" hits="1"/>
						<line number="124" hits="1"/>
						<line number="127" hits="1"/>
						<line number="128" hits="1"/>
						<line number="130" hits="1"/>
						<line number="133" hits="1"/>
						<line number="138" hits="1"/>
						<line number="139" hits="1"/>
						<line number="140" hits="1"/>
						<line number="141" hits="1"/>
						<line number="142" hits="1"/>
						<line number="146" hits="1"/>
						<line number="147" hits="1"/>
						<line number="150" hits="1"/>
						<line number="151" hits="1"/>
						<line number="154" hits="1"/>
						<line number="155" hits="1"/>
						<line number="156" hits="1"/>
						<line number="157" hits="1"/>
						<line number="159" hits="1"/>
						<line number="160" hits="1"/>
						<line number="161" hits="1"/>
						<line number="162" hits="1"/>
						<line number="166" hits="1"/>
						<line number="169" hits="1"/>
						<line number="170" hits="1"/>
						<line number="172" hits="1"/>
						<line number="173" hits="0"/>
					</lines>
				</class>
				<class name="test_app_context.py" filename="tests/test_app_context.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="8" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="15" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="31" hits="1"/>
						<line number="33" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="37" hits="1"/>
						<line number="39" hits="1"/>
						<line number="40" hits="1"/>
						<line number="42" hits="1"/>
						<line number="43" hits="1"/>
						<line number="44" hits="1"/>
						<line number="46" hits="1"/>
						<line number="47" hits="1"/>
						<line number="49" hits="1"/>
						<line number="52" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="57" hits="1"/>
						<line number="59" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="70" hits="1"/>
					</lines>
				</class>
				<class name="test_command_utils.py" filename="tests/test_command_utils.py" complexity="0" line-rate="0.9898" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="12" hits="1"/>
						<line number="13" hits="1"/>
						<line number="15" hits="1"/>
						<line number="17" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="24" hits="1"/>
						<line number="30" hits="1"/>
						<line number="32" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="37" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="43" hits="1"/>
						<line number="44" hits="1"/>
						<line number="45" hits="1"/>
						<line number="46" hits="1"/>
						<line number="48" hits="1"/>
						<line number="50" hits="1"/>
						<line number="51" hits="1"/>
						<line number="53" hits="1"/>
						<line number="54" hits="1"/>
						<line number="56" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="60" hits="1"/>
						<line number="61" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="69" hits="1"/>
						<line number="71" hits="1"/>
						<line number="72" hits="1"/>
						<line number="74" hits="1"/>
						<line number="75" hits="1"/>
						<line number="76" hits="1"/>
						<line number="77" hits="1"/>
						<line number="79" hits="1"/>
						<line number="80" hits="1"/>
						<line number="83" hits="1"/>
						<line number="85" hits="1"/>
						<line number="86" hits="1"/>
						<line number="88" hits="1"/>
						<line number="89" hits="1"/>
						<line number="91" hits="1"/>
						<line number="92" hits="1"/>
						<line number="94" hits="1"/>
						<line number="95" hits="1"/>
						<line number="97" hits="1"/>
						<line number="99" hits="1"/>
						<line number="100" hits="1"/>
						<line number="102" hits="1"/>
						<line number="103" hits="1"/>
						<line number="104" hits="1"/>
						<line number="105" hits="1"/>
						<line number="107" hits="1"/>
						<line number="109" hits="1"/>
						<line number="112" hits="1"/>
						<line number="115" hits="1"/>
						<line number="117" hits="1"/>
						<line number="120" hits="1"/>
						<line number="121" hits="1"/>
						<line number="123" hits="1"/>
						<line number="124" hits="1"/>
						<line number="125" hits="1"/>
						<line number="126" hits="1"/>
						<line number="128" hits="1"/>
						<line number="129" hits="1"/>
						<line number="131" hits="1"/>
						<line number="132" hits="1"/>
						<line number="134" hits="1"/>
						<line number="135" hits="1"/>
						<line number="136" hits="1"/>
						<line number="138" hits="1"/>
						<line number="139" hits="1"/>
						<line number="140" hits="1"/>
						<line number="142" hits="1"/>
						<line number="143" hits="1"/>
						<line number="144" hits="1"/>
						<line number="146" hits="1"/>
						<line number="148" hits="1"/>
						<line number="149" hits="1"/>
						<line number="151" hits="1"/>
						<line number="152" hits="1"/>
						<line number="153" hits="1"/>
						<line number="155" hits="1"/>
						<line number="156" hits="1"/>
						<line number="157" hits="1"/>
						<line number="159" hits="1"/>
						<line number="160" hits="0"/>
					</lines>
				</class>
				<class name="test_constants.py" filename="tests/test_constants.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="1"/>
						<line number="16" hits="1"/>
						<line number="18" hits="1"/>
					</lines>
				</class>
				<class name="test_diagnostics.py" filename="tests/test_diagnostics.py" complexity="0" line-rate="0.987" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="10" hits="1"/>
						<line number="15" hits="1"/>
						<line number="16" hits="1"/>
						<line number="19" hits="1"/>
						<line number="25" hits="1"/>
						<line number="28" hits="1"/>
						<line number="31" hits="1"/>
						<line number="32" hits="1"/>
						<line number="33" hits="1"/>
						<line number="36" hits="1"/>
						<line number="39" hits="1"/>
						<line number="42" hits="1"/>
						<line number="44" hits="1"/>
						<line number="46" hits="1"/>
						<line number="48" hits="1"/>
						<line number="49" hits="1"/>
						<line number="52" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="58" hits="1"/>
						<line number="60" hits="1"/>
						<line number="65" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="70" hits="1"/>
						<line number="71" hits="1"/>
						<line number="73" hits="1"/>
						<line number="74" hits="1"/>
						<line number="76" hits="1"/>
						<line number="78" hits="1"/>
						<line number="79" hits="1"/>
						<line number="81" hits="1"/>
						<line number="82" hits="1"/>
						<line number="85" hits="1"/>
						<line number="86" hits="1"/>
						<line number="89" hits="1"/>
						<line number="92" hits="1"/>
						<line number="93" hits="1"/>
						<line number="94" hits="1"/>
						<line number="96" hits="1"/>
						<line number="97" hits="1"/>
						<line number="99" hits="1"/>
						<line number="100" hits="1"/>
						<line number="101" hits="1"/>
						<line number="103" hits="1"/>
						<line number="106" hits="1"/>
						<line number="107" hits="1"/>
						<line number="108" hits="1"/>
						<line number="111" hits="1"/>
						<line number="113" hits="1"/>
						<line number="117" hits="1"/>
						<line number="120" hits="1"/>
						<line number="121" hits="1"/>
						<line number="122" hits="1"/>
						<line number="123" hits="1"/>
						<line number="124" hits="1"/>
						<line number="125" hits="1"/>
						<line number="127" hits="1"/>
						<line number="128" hits="1"/>
						<line number="129" hits="1"/>
						<line number="132" hits="1"/>
						<line number="133" hits="1"/>
						<line number="139" hits="1"/>
						<line number="145" hits="1"/>
						<line number="147" hits="1"/>
						<line number="148" hits="1"/>
						<line number="149" hits="1"/>
						<line number="150" hits="1"/>
						<line number="152" hits="1"/>
						<line number="153" hits="0"/>
					</lines>
				</class>
				<class name="test_dialogs.py" filename="tests/test_dialogs.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
					</lines>
				</class>
				<class name="test_exceptions.py" filename="tests/test_exceptions.py" complexity="0" line-rate="0.9615" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="10" hits="1"/>
						<line number="12" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="1"/>
						<line number="17" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="23" hits="1"/>
						<line number="25" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="31" hits="1"/>
						<line number="33" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="37" hits="1"/>
						<line number="39" hits="1"/>
						<line number="40" hits="0"/>
					</lines>
				</class>
				<class name="test_github_integration.py" filename="tests/test_github_integration.py" complexity="0" line-rate="0.9886" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="1"/>
						<line number="18" hits="1"/>
						<line number="21" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="31" hits="1"/>
						<line number="32" hits="1"/>
						<line number="35" hits="1"/>
						<line number="38" hits="1"/>
						<line number="39" hits="1"/>
						<line number="41" hits="1"/>
						<line number="42" hits="1"/>
						<line number="45" hits="1"/>
						<line number="48" hits="1"/>
						<line number="49" hits="1"/>
						<line number="51" hits="1"/>
						<line number="52" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="59" hits="1"/>
						<line number="62" hits="1"/>
						<line number="63" hits="1"/>
						<line number="65" hits="1"/>
						<line number="66" hits="1"/>
						<line number="69" hits="1"/>
						<line number="70" hits="1"/>
						<line number="73" hits="1"/>
						<line number="76" hits="1"/>
						<line number="78" hits="1"/>
						<line number="79" hits="1"/>
						<line number="82" hits="1"/>
						<line number="83" hits="1"/>
						<line number="86" hits="1"/>
						<line number="87" hits="1"/>
						<line number="89" hits="1"/>
						<line number="91" hits="1"/>
						<line number="92" hits="1"/>
						<line number="95" hits="1"/>
						<line number="96" hits="1"/>
						<line number="99" hits="1"/>
						<line number="100" hits="1"/>
						<line number="102" hits="1"/>
						<line number="104" hits="1"/>
						<line number="105" hits="1"/>
						<line number="106" hits="1"/>
						<line number="110" hits="1"/>
						<line number="113" hits="1"/>
						<line number="115" hits="1"/>
						<line number="116" hits="1"/>
						<line number="118" hits="1"/>
						<line number="121" hits="1"/>
						<line number="122" hits="1"/>
						<line number="123" hits="1"/>
						<line number="125" hits="1"/>
						<line number="126" hits="1"/>
						<line number="128" hits="1"/>
						<line number="129" hits="1"/>
						<line number="130" hits="1"/>
						<line number="132" hits="1"/>
						<line number="133" hits="1"/>
						<line number="135" hits="1"/>
						<line number="136" hits="1"/>
						<line number="137" hits="1"/>
						<line number="139" hits="1"/>
						<line number="140" hits="1"/>
						<line number="142" hits="1"/>
						<line number="143" hits="1"/>
						<line number="144" hits="1"/>
						<line number="146" hits="1"/>
						<line number="147" hits="1"/>
						<line number="149" hits="1"/>
						<line number="150" hits="1"/>
						<line number="151" hits="1"/>
						<line number="153" hits="1"/>
						<line number="154" hits="1"/>
						<line number="156" hits="1"/>
						<line number="157" hits="0"/>
					</lines>
				</class>
				<class name="test_gui_components.py" filename="tests/test_gui_components.py" complexity="0" line-rate="0.9792" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="7" hits="1"/>
						<line number="8" hits="1"/>
						<line number="9" hits="1"/>
						<line number="10" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="29" hits="1"/>
						<line number="30" hits="1"/>
						<line number="31" hits="1"/>
						<line number="33" hits="1"/>
						<line number="34" hits="1"/>
						<line number="36" hits="1"/>
						<line number="37" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="43" hits="1"/>
						<line number="45" hits="1"/>
						<line number="46" hits="1"/>
						<line number="48" hits="1"/>
						<line number="49" hits="1"/>
						<line number="54" hits="1"/>
						<line number="55" hits="1"/>
						<line number="57" hits="1"/>
						<line number="59" hits="1"/>
						<line number="60" hits="1"/>
						<line number="62" hits="1"/>
						<line number="63" hits="1"/>
						<line number="65" hits="1"/>
						<line number="68" hits="1"/>
						<line number="69" hits="1"/>
						<line number="72" hits="1"/>
						<line number="73" hits="1"/>
						<line number="74" hits="1"/>
						<line number="76" hits="1"/>
						<line number="78" hits="1"/>
						<line number="80" hits="1"/>
						<line number="81" hits="1"/>
						<line number="82" hits="1"/>
						<line number="83" hits="1"/>
						<line number="85" hits="1"/>
						<line number="86" hits="1"/>
						<line number="87" hits="1"/>
						<line number="88" hits="1"/>
						<line number="90" hits="1"/>
						<line number="91" hits="1"/>
						<line number="92" hits="1"/>
						<line number="94" hits="1"/>
						<line number="95" hits="1"/>
						<line number="96" hits="1"/>
						<line number="98" hits="1"/>
						<line number="99" hits="1"/>
						<line number="100" hits="1"/>
						<line number="102" hits="1"/>
						<line number="103" hits="1"/>
						<line number="106" hits="1"/>
						<line number="108" hits="1"/>
						<line number="109" hits="1"/>
						<line number="110" hits="1"/>
						<line number="112" hits="1"/>
						<line number="113" hits="1"/>
						<line number="114" hits="1"/>
						<line number="115" hits="1"/>
						<line number="117" hits="1"/>
						<line number="118" hits="1"/>
						<line number="119" hits="1"/>
						<line number="121" hits="1"/>
						<line number="122" hits="1"/>
						<line number="123" hits="1"/>
						<line number="124" hits="1"/>
						<line number="126" hits="1"/>
						<line number="127" hits="1"/>
						<line number="129" hits="1"/>
						<line number="130" hits="1"/>
						<line number="132" hits="1"/>
						<line number="133" hits="1"/>
						<line number="135" hits="1"/>
						<line number="136" hits="1"/>
						<line number="138" hits="1"/>
						<line number="139" hits="1"/>
						<line number="141" hits="1"/>
						<line number="142" hits="1"/>
						<line number="143" hits="1"/>
						<line number="145" hits="1"/>
						<line number="147" hits="1"/>
						<line number="148" hits="1"/>
						<line number="150" hits="1"/>
						<line number="152" hits="1"/>
						<line number="153" hits="1"/>
						<line number="155" hits="1"/>
						<line number="156" hits="1"/>
						<line number="158" hits="1"/>
						<line number="159" hits="1"/>
						<line number="160" hits="1"/>
						<line number="162" hits="1"/>
						<line number="163" hits="1"/>
						<line number="164" hits="1"/>
						<line number="166" hits="1"/>
						<line number="167" hits="1"/>
						<line number="168" hits="1"/>
						<line number="170" hits="1"/>
						<line number="171" hits="1"/>
						<line number="173" hits="1"/>
						<line number="174" hits="1"/>
						<line number="176" hits="1"/>
						<line number="177" hits="1"/>
						<line number="179" hits="1"/>
						<line number="180" hits="1"/>
						<line number="182" hits="1"/>
						<line number="183" hits="1"/>
						<line number="185" hits="1"/>
						<line number="186" hits="1"/>
						<line number="188" hits="1"/>
						<line number="189" hits="1"/>
						<line number="191" hits="1"/>
						<line number="192" hits="1"/>
						<line number="193" hits="1"/>
						<line number="195" hits="1"/>
						<line number="196" hits="1"/>
						<line number="198" hits="1"/>
						<line number="199" hits="1"/>
						<line number="200" hits="1"/>
						<line number="201" hits="1"/>
						<line number="203" hits="1"/>
						<line number="204" hits="1"/>
						<line number="205" hits="1"/>
						<line number="206" hits="1"/>
						<line number="208" hits="1"/>
						<line number="209" hits="1"/>
						<line number="210" hits="1"/>
						<line number="211" hits="1"/>
						<line number="213" hits="1"/>
						<line number="214" hits="1"/>
						<line number="215" hits="1"/>
						<line number="216" hits="1"/>
						<line number="218" hits="1"/>
						<line number="219" hits="1"/>
						<line number="221" hits="1"/>
						<line number="224" hits="1"/>
						<line number="226" hits="1"/>
						<line number="228" hits="1"/>
						<line number="229" hits="1"/>
						<line number="231" hits="1"/>
						<line number="232" hits="1"/>
						<line number="233" hits="1"/>
						<line number="234" hits="1"/>
						<line number="236" hits="1"/>
						<line number="237" hits="1"/>
						<line number="238" hits="1"/>
						<line number="239" hits="1"/>
						<line number="241" hits="1"/>
						<line number="242" hits="1"/>
						<line number="243" hits="1"/>
						<line number="244" hits="1"/>
						<line number="246" hits="1"/>
						<line number="247" hits="1"/>
						<line number="248" hits="1"/>
						<line number="250" hits="1"/>
						<line number="251" hits="1"/>
						<line number="253" hits="1"/>
						<line number="255" hits="1"/>
						<line number="257" hits="1"/>
						<line number="259" hits="1"/>
						<line number="260" hits="1"/>
						<line number="263" hits="1"/>
						<line number="266" hits="0"/>
						<line number="268" hits="0"/>
						<line number="269" hits="0"/>
						<line number="270" hits="0"/>
						<line number="272" hits="0"/>
						<line number="278" hits="1"/>
						<line number="281" hits="1"/>
						<line number="282" hits="1"/>
						<line number="283" hits="1"/>
						<line number="284" hits="1"/>
						<line number="285" hits="1"/>
						<line number="286" hits="1"/>
						<line number="292" hits="1"/>
						<line number="293" hits="1"/>
						<line number="295" hits="1"/>
						<line number="297" hits="1"/>
						<line number="298" hits="1"/>
						<line number="299" hits="1"/>
						<line number="301" hits="1"/>
						<line number="303" hits="1"/>
						<line number="304" hits="1"/>
						<line number="305" hits="1"/>
						<line number="307" hits="1"/>
						<line number="309" hits="1"/>
						<line number="315" hits="1"/>
						<line number="316" hits="1"/>
						<line number="317" hits="1"/>
						<line number="318" hits="1"/>
						<line number="320" hits="1"/>
						<line number="321" hits="1"/>
						<line number="323" hits="1"/>
						<line number="329" hits="1"/>
						<line number="330" hits="1"/>
						<line number="332" hits="1"/>
						<line number="333" hits="1"/>
						<line number="335" hits="1"/>
						<line number="341" hits="1"/>
						<line number="342" hits="1"/>
						<line number="343" hits="1"/>
						<line number="345" hits="1"/>
						<line number="346" hits="1"/>
						<line number="348" hits="1"/>
						<line number="354" hits="1"/>
						<line number="355" hits="1"/>
						<line number="356" hits="1"/>
						<line number="357" hits="1"/>
						<line number="359" hits="1"/>
						<line number="361" hits="1"/>
						<line number="366" hits="1"/>
						<line number="368" hits="1"/>
						<line number="369" hits="1"/>
						<line number="370" hits="1"/>
						<line number="372" hits="1"/>
						<line number="374" hits="1"/>
						<line number="379" hits="1"/>
						<line number="380" hits="1"/>
						<line number="381" hits="1"/>
						<line number="383" hits="1"/>
						<line number="385" hits="1"/>
						<line number="386" hits="1"/>
						<line number="387" hits="1"/>
						<line number="388" hits="1"/>
						<line number="390" hits="1"/>
						<line number="392" hits="1"/>
						<line number="393" hits="1"/>
						<line number="394" hits="1"/>
						<line number="395" hits="1"/>
						<line number="397" hits="1"/>
						<line number="399" hits="1"/>
						<line number="400" hits="1"/>
						<line number="401" hits="1"/>
						<line number="403" hits="1"/>
						<line number="405" hits="1"/>
						<line number="406" hits="1"/>
						<line number="408" hits="1"/>
						<line number="409" hits="1"/>
						<line number="410" hits="1"/>
						<line number="412" hits="1"/>
						<line number="413" hits="1"/>
						<line number="415" hits="1"/>
						<line number="416" hits="1"/>
						<line number="417" hits="1"/>
						<line number="419" hits="1"/>
						<line number="421" hits="1"/>
						<line number="422" hits="1"/>
						<line number="423" hits="1"/>
						<line number="425" hits="1"/>
						<line number="427" hits="1"/>
						<line number="428" hits="1"/>
						<line number="429" hits="1"/>
						<line number="430" hits="1"/>
						<line number="432" hits="1"/>
						<line number="434" hits="1"/>
						<line number="435" hits="1"/>
						<line number="436" hits="1"/>
						<line number="437" hits="1"/>
						<line number="439" hits="1"/>
						<line number="440" hits="1"/>
						<line number="443" hits="1"/>
						<line number="444" hits="1"/>
						<line number="446" hits="1"/>
						<line number="448" hits="1"/>
						<line number="450" hits="1"/>
						<line number="453" hits="1"/>
						<line number="456" hits="1"/>
						<line number="457" hits="1"/>
						<line number="458" hits="1"/>
						<line number="459" hits="1"/>
						<line number="462" hits="1"/>
						<line number="463" hits="0"/>
					</lines>
				</class>
				<class name="test_localization.py" filename="tests/test_localization.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="9" hits="1"/>
						<line number="11" hits="1"/>
						<line number="13" hits="1"/>
						<line number="14" hits="1"/>
						<line number="16" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="24" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="29" hits="1"/>
						<line number="30" hits="1"/>
						<line number="32" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="38" hits="1"/>
						<line number="41" hits="1"/>
						<line number="42" hits="1"/>
						<line number="44" hits="1"/>
						<line number="46" hits="1"/>
						<line number="48" hits="1"/>
					</lines>
				</class>
				<class name="test_main_and_startup.py" filename="tests/test_main_and_startup.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="6" hits="1"/>
						<line number="9" hits="1"/>
						<line number="15" hits="1"/>
						<line number="17" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="21" hits="1"/>
						<line number="22" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="30" hits="1"/>
						<line number="32" hits="1"/>
						<line number="33" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="37" hits="1"/>
						<line number="39" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="43" hits="1"/>
						<line number="44" hits="1"/>
						<line number="45" hits="1"/>
						<line number="46" hits="1"/>
						<line number="47" hits="1"/>
						<line number="48" hits="1"/>
						<line number="51" hits="1"/>
						<line number="52" hits="1"/>
						<line number="53" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="59" hits="1"/>
						<line number="60" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="65" hits="1"/>
						<line number="67" hits="1"/>
						<line number="68" hits="1"/>
						<line number="69" hits="1"/>
						<line number="70" hits="1"/>
						<line number="71" hits="1"/>
						<line number="72" hits="1"/>
						<line number="75" hits="1"/>
						<line number="76" hits="1"/>
						<line number="78" hits="1"/>
					</lines>
				</class>
				<class name="test_main_controller.py" filename="tests/test_main_controller.py" complexity="0" line-rate="0.9796" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="8" hits="1"/>
						<line number="13" hits="1"/>
						<line number="15" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="27" hits="1"/>
						<line number="30" hits="1"/>
						<line number="32" hits="1"/>
						<line number="33" hits="1"/>
						<line number="36" hits="1"/>
						<line number="37" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="43" hits="1"/>
						<line number="46" hits="1"/>
						<line number="47" hits="1"/>
						<line number="50" hits="1"/>
						<line number="53" hits="1"/>
						<line number="55" hits="1"/>
						<line number="58" hits="1"/>
						<line number="61" hits="1"/>
						<line number="62" hits="1"/>
						<line number="65" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="71" hits="1"/>
						<line number="73" hits="1"/>
						<line number="76" hits="1"/>
						<line number="80" hits="1"/>
						<line number="81" hits="1"/>
						<line number="83" hits="1"/>
						<line number="85" hits="1"/>
						<line number="86" hits="1"/>
						<line number="87" hits="1"/>
						<line number="90" hits="1"/>
						<line number="94" hits="1"/>
						<line number="95" hits="1"/>
						<line number="98" hits="1"/>
						<line number="99" hits="0"/>
					</lines>
				</class>
				<class name="test_menu_handler.py" filename="tests/test_menu_handler.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines/>
				</class>
				<class name="test_polling_manager.py" filename="tests/test_polling_manager.py" complexity="0" line-rate="0.9908" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="6" hits="1"/>
						<line number="8" hits="1"/>
						<line number="13" hits="1"/>
						<line number="15" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="20" hits="1"/>
						<line number="22" hits="1"/>
						<line number="23" hits="1"/>
						<line number="24" hits="1"/>
						<line number="28" hits="1"/>
						<line number="30" hits="1"/>
						<line number="32" hits="1"/>
						<line number="34" hits="1"/>
						<line number="37" hits="1"/>
						<line number="38" hits="1"/>
						<line number="40" hits="1"/>
						<line number="44" hits="1"/>
						<line number="46" hits="1"/>
						<line number="48" hits="1"/>
						<line number="50" hits="1"/>
						<line number="52" hits="1"/>
						<line number="53" hits="1"/>
						<line number="55" hits="1"/>
						<line number="57" hits="1"/>
						<line number="59" hits="1"/>
						<line number="61" hits="1"/>
						<line number="63" hits="1"/>
						<line number="65" hits="1"/>
						<line number="66" hits="1"/>
						<line number="69" hits="1"/>
						<line number="72" hits="1"/>
						<line number="75" hits="1"/>
						<line number="77" hits="1"/>
						<line number="78" hits="1"/>
						<line number="83" hits="1"/>
						<line number="85" hits="1"/>
						<line number="86" hits="1"/>
						<line number="88" hits="1"/>
						<line number="90" hits="1"/>
						<line number="91" hits="1"/>
						<line number="95" hits="1"/>
						<line number="97" hits="1"/>
						<line number="99" hits="1"/>
						<line number="102" hits="1"/>
						<line number="103" hits="1"/>
						<line number="104" hits="1"/>
						<line number="105" hits="1"/>
						<line number="106" hits="1"/>
						<line number="108" hits="1"/>
						<line number="110" hits="1"/>
						<line number="111" hits="1"/>
						<line number="113" hits="1"/>
						<line number="115" hits="1"/>
						<line number="117" hits="1"/>
						<line number="118" hits="1"/>
						<line number="123" hits="1"/>
						<line number="125" hits="1"/>
						<line number="126" hits="1"/>
						<line number="127" hits="1"/>
						<line number="128" hits="1"/>
						<line number="129" hits="1"/>
						<line number="130" hits="1"/>
						<line number="132" hits="1"/>
						<line number="133" hits="1"/>
						<line number="134" hits="1"/>
						<line number="135" hits="1"/>
						<line number="139" hits="1"/>
						<line number="140" hits="1"/>
						<line number="145" hits="1"/>
						<line number="146" hits="1"/>
						<line number="147" hits="1"/>
						<line number="149" hits="1"/>
						<line number="153" hits="1"/>
						<line number="154" hits="1"/>
						<line number="157" hits="1"/>
						<line number="159" hits="1"/>
						<line number="161" hits="1"/>
						<line number="162" hits="1"/>
						<line number="163" hits="1"/>
						<line number="164" hits="1"/>
						<line number="168" hits="1"/>
						<line number="170" hits="1"/>
						<line number="173" hits="1"/>
						<line number="174" hits="1"/>
						<line number="175" hits="1"/>
						<line number="177" hits="1"/>
						<line number="180" hits="1"/>
						<line number="182" hits="1"/>
						<line number="183" hits="1"/>
						<line number="187" hits="1"/>
						<line number="188" hits="1"/>
						<line number="190" hits="1"/>
						<line number="191" hits="1"/>
						<line number="195" hits="1"/>
						<line number="196" hits="1"/>
						<line number="199" hits="1"/>
						<line number="201" hits="1"/>
						<line number="202" hits="1"/>
						<line number="206" hits="1"/>
						<line number="208" hits="1"/>
						<line number="209" hits="1"/>
						<line number="211" hits="1"/>
						<line number="212" hits="0"/>
					</lines>
				</class>
				<class name="test_system.py" filename="tests/test_system.py" complexity="0" line-rate="0.9882" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="4" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="12" hits="1"/>
						<line number="13" hits="1"/>
						<line number="16" hits="1"/>
						<line number="17" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="22" hits="1"/>
						<line number="23" hits="1"/>
						<line number="25" hits="1"/>
						<line number="27" hits="1"/>
						<line number="29" hits="1"/>
						<line number="30" hits="1"/>
						<line number="32" hits="1"/>
						<line number="33" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="38" hits="1"/>
						<line number="41" hits="1"/>
						<line number="42" hits="1"/>
						<line number="44" hits="1"/>
						<line number="45" hits="1"/>
						<line number="48" hits="1"/>
						<line number="49" hits="1"/>
						<line number="51" hits="1"/>
						<line number="52" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="59" hits="1"/>
						<line number="60" hits="1"/>
						<line number="62" hits="1"/>
						<line number="63" hits="1"/>
						<line number="65" hits="1"/>
						<line number="68" hits="1"/>
						<line number="69" hits="1"/>
						<line number="72" hits="1"/>
						<line number="76" hits="1"/>
						<line number="77" hits="1"/>
						<line number="78" hits="1"/>
						<line number="79" hits="1"/>
						<line number="81" hits="1"/>
						<line number="82" hits="1"/>
						<line number="85" hits="1"/>
						<line number="90" hits="1"/>
						<line number="92" hits="1"/>
						<line number="93" hits="1"/>
						<line number="96" hits="1"/>
						<line number="97" hits="1"/>
						<line number="100" hits="1"/>
						<line number="105" hits="1"/>
						<line number="106" hits="1"/>
						<line number="108" hits="1"/>
						<line number="110" hits="1"/>
						<line number="111" hits="1"/>
						<line number="115" hits="1"/>
						<line number="119" hits="1"/>
						<line number="120" hits="1"/>
						<line number="121" hits="1"/>
						<line number="123" hits="1"/>
						<line number="124" hits="1"/>
						<line number="127" hits="1"/>
						<line number="131" hits="1"/>
						<line number="132" hits="1"/>
						<line number="133" hits="1"/>
						<line number="135" hits="1"/>
						<line number="136" hits="1"/>
						<line number="138" hits="1"/>
						<line number="139" hits="1"/>
						<line number="140" hits="1"/>
						<line number="147" hits="1"/>
						<line number="149" hits="1"/>
						<line number="150" hits="1"/>
						<line number="151" hits="1"/>
						<line number="152" hits="1"/>
						<line number="154" hits="1"/>
						<line number="155" hits="1"/>
						<line number="157" hits="1"/>
						<line number="158" hits="1"/>
						<line number="161" hits="1"/>
						<line number="162" hits="0"/>
					</lines>
				</class>
				<class name="test_utils.py" filename="tests/test_utils.py" complexity="0" line-rate="1" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="8" hits="1"/>
						<line number="9" hits="1"/>
						<line number="11" hits="1"/>
						<line number="12" hits="1"/>
						<line number="14" hits="1"/>
						<line number="15" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
					</lines>
				</class>
				<class name="test_wifi.py" filename="tests/test_wifi.py" complexity="0" line-rate="0.9909" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="3" hits="1"/>
						<line number="5" hits="1"/>
						<line number="7" hits="1"/>
						<line number="9" hits="1"/>
						<line number="14" hits="1"/>
						<line number="16" hits="1"/>
						<line number="34" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="43" hits="1"/>
						<line number="45" hits="1"/>
						<line number="58" hits="1"/>
						<line number="62" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="66" hits="1"/>
						<line number="68" hits="1"/>
						<line number="73" hits="1"/>
						<line number="77" hits="1"/>
						<line number="78" hits="1"/>
						<line number="80" hits="1"/>
						<line number="82" hits="1"/>
						<line number="89" hits="1"/>
						<line number="93" hits="1"/>
						<line number="94" hits="1"/>
						<line number="96" hits="1"/>
						<line number="98" hits="1"/>
						<line number="102" hits="1"/>
						<line number="103" hits="1"/>
						<line number="105" hits="1"/>
						<line number="107" hits="1"/>
						<line number="108" hits="1"/>
						<line number="110" hits="1"/>
						<line number="113" hits="1"/>
						<line number="114" hits="1"/>
						<line number="115" hits="1"/>
						<line number="117" hits="1"/>
						<line number="118" hits="1"/>
						<line number="120" hits="1"/>
						<line number="122" hits="1"/>
						<line number="123" hits="1"/>
						<line number="124" hits="1"/>
						<line number="126" hits="1"/>
						<line number="127" hits="1"/>
						<line number="129" hits="1"/>
						<line number="130" hits="1"/>
						<line number="132" hits="1"/>
						<line number="133" hits="1"/>
						<line number="135" hits="1"/>
						<line number="136" hits="1"/>
						<line number="137" hits="1"/>
						<line number="139" hits="1"/>
						<line number="140" hits="1"/>
						<line number="142" hits="1"/>
						<line number="143" hits="1"/>
						<line number="145" hits="1"/>
						<line number="150" hits="1"/>
						<line number="151" hits="1"/>
						<line number="154" hits="1"/>
						<line number="160" hits="1"/>
						<line number="163" hits="1"/>
						<line number="166" hits="1"/>
						<line number="168" hits="1"/>
						<line number="169" hits="1"/>
						<line number="172" hits="1"/>
						<line number="175" hits="1"/>
						<line number="178" hits="1"/>
						<line number="180" hits="1"/>
						<line number="181" hits="1"/>
						<line number="184" hits="1"/>
						<line number="187" hits="1"/>
						<line number="189" hits="1"/>
						<line number="190" hits="1"/>
						<line number="192" hits="1"/>
						<line number="194" hits="1"/>
						<line number="197" hits="1"/>
						<line number="198" hits="1"/>
						<line number="200" hits="1"/>
						<line number="202" hits="1"/>
						<line number="203" hits="1"/>
						<line number="205" hits="1"/>
						<line number="206" hits="1"/>
						<line number="208" hits="1"/>
						<line number="209" hits="1"/>
						<line number="210" hits="1"/>
						<line number="211" hits="1"/>
						<line number="216" hits="1"/>
						<line number="217" hits="1"/>
						<line number="220" hits="1"/>
						<line number="224" hits="1"/>
						<line number="227" hits="1"/>
						<line number="230" hits="1"/>
						<line number="232" hits="1"/>
						<line number="233" hits="1"/>
						<line number="236" hits="1"/>
						<line number="239" hits="1"/>
						<line number="242" hits="1"/>
						<line number="244" hits="1"/>
						<line number="245" hits="1"/>
						<line number="248" hits="1"/>
						<line number="252" hits="1"/>
						<line number="253" hits="1"/>
						<line number="255" hits="1"/>
						<line number="256" hits="1"/>
						<line number="258" hits="1"/>
						<line number="259" hits="1"/>
						<line number="261" hits="1"/>
						<line number="262" hits="0"/>
					</lines>
				</class>
				<class name="test_wifi_profile_manager.py" filename="tests/test_wifi_profile_manager.py" complexity="0" line-rate="0.9886" branch-rate="0">
					<methods/>
					<lines>
						<line number="1" hits="1"/>
						<line number="2" hits="1"/>
						<line number="4" hits="1"/>
						<line number="7" hits="1"/>
						<line number="10" hits="1"/>
						<line number="15" hits="1"/>
						<line number="17" hits="1"/>
						<line number="18" hits="1"/>
						<line number="19" hits="1"/>
						<line number="20" hits="1"/>
						<line number="22" hits="1"/>
						<line number="24" hits="1"/>
						<line number="25" hits="1"/>
						<line number="26" hits="1"/>
						<line number="27" hits="1"/>
						<line number="28" hits="1"/>
						<line number="29" hits="1"/>
						<line number="31" hits="1"/>
						<line number="33" hits="1"/>
						<line number="34" hits="1"/>
						<line number="35" hits="1"/>
						<line number="36" hits="1"/>
						<line number="38" hits="1"/>
						<line number="40" hits="1"/>
						<line number="41" hits="1"/>
						<line number="42" hits="1"/>
						<line number="43" hits="1"/>
						<line number="44" hits="1"/>
						<line number="46" hits="1"/>
						<line number="48" hits="1"/>
						<line number="49" hits="1"/>
						<line number="50" hits="1"/>
						<line number="51" hits="1"/>
						<line number="53" hits="1"/>
						<line number="55" hits="1"/>
						<line number="56" hits="1"/>
						<line number="57" hits="1"/>
						<line number="58" hits="1"/>
						<line number="60" hits="1"/>
						<line number="62" hits="1"/>
						<line number="63" hits="1"/>
						<line number="64" hits="1"/>
						<line number="65" hits="1"/>
						<line number="68" hits="1"/>
						<line number="70" hits="1"/>
						<line number="71" hits="1"/>
						<line number="72" hits="1"/>
						<line number="73" hits="1"/>
						<line number="74" hits="1"/>
						<line number="76" hits="1"/>
						<line number="78" hits="1"/>
						<line number="79" hits="1"/>
						<line number="80" hits="1"/>
						<line number="81" hits="1"/>
						<line number="83" hits="1"/>
						<line number="85" hits="1"/>
						<line number="86" hits="1"/>
						<line number="87" hits="1"/>
						<line number="90" hits="1"/>
						<line number="93" hits="1"/>
						<line number="94" hits="1"/>
						<line number="95" hits="1"/>
						<line number="96" hits="1"/>
						<line number="97" hits="1"/>
						<line number="100" hits="1"/>
						<line number="101" hits="1"/>
						<line number="102" hits="1"/>
						<line number="105" hits="1"/>
						<line number="109" hits="1"/>
						<line number="110" hits="1"/>
						<line number="113" hits="1"/>
						<line number="119" hits="1"/>
						<line number="122" hits="1"/>
						<line number="124" hits="1"/>
						<line number="125" hits="1"/>
						<line number="128" hits="1"/>
						<line number="129" hits="1"/>
						<line number="132" hits="1"/>
						<line number="133" hits="1"/>
						<line number="135" hits="1"/>
						<line number="136" hits="1"/>
						<line number="138" hits="1"/>
						<line number="139" hits="1"/>
						<line number="142" hits="1"/>
						<line number="145" hits="1"/>
						<line number="148" hits="1"/>
						<line number="152" hits="1"/>
						<line number="153" hits="0"/>
					</lines>
				</class>
			</classes>
		</package>
	</packages>
</coverage>


================================================================================
FILE: exceptions.py
================================================================================

class NetworkManagerError(Exception):
    """
    Custom exception for network management errors.

    Attributes:
        message (str): The human-readable error message.
        code (str | None): An optional machine-readable error code for
                           specific error handling.
    """
    def __init__(self, message: str, code: str | None = None):
        super().__init__(message)
        self.code = code

    def __str__(self) -> str:
        """Return the string representation of the error, including the code
        if present."""
        if self.code:
            return f"{super().__str__()} (code: {self.code})"
        return super().__str__()

================================================================================
FILE: github_integration.py
================================================================================

import os
import re
import sys
from pathlib import Path
import json

from exceptions import NetworkManagerError
from logger_setup import get_project_or_exe_root

def check_github_cli_auth() -> tuple[bool, str]:
    """
    Checks if GitHub CLI is installed and the user is authenticated.

    Returns:
        A tuple (is_ok, message).
        is_ok is True if everything is fine, False otherwise.
        message contains the status or error.
    """
    try:
        # Need to import here to avoid circular dependency with logger_setup
        from logic.command_utils import run_system_command
        run_system_command(
            ["gh", "auth", "status"], "GitHub CLI authentication check failed.")
        return (True, "GitHub CLI is ready.")
    except NetworkManagerError as e:
        # Distinguish between 'gh not found' and 'not logged in'.
        if "not found" in str(e):  # noqa: E501
            return (False, "GitHub CLI ('gh') is not installed. Please install it from https://cli.github.com/")  # noqa: E501
        else:
            return (False, "You are not logged in to GitHub CLI. Please run 'gh auth login' in your terminal.")  # noqa: E501

def _get_repo_from_packaged_info() -> str | None:
    """
    Tries to read the repository name from a 'git_info.json' file,
    which is expected to exist alongside the executable when packaged.
    """
    if getattr(sys, 'frozen', False): # Checks if running as a bundled exe
        try:  # noqa: E501
            info_file = get_project_or_exe_root() / "git_info.json"
            if info_file.is_file():
                data = json.loads(info_file.read_text(encoding='utf-8'))
                return data.get("repository")
        except (IOError, json.JSONDecodeError):
            return None
    return None

def get_repo_from_git_config() -> str | None:
    """
    Reads the 'origin' remote URL from the local Git config and extracts the
    'owner/repo' string.

    This function now first checks for a packaged `git_info.json` file.

    Returns:
        The 'owner/repo' string (e.g., "atkeppu/NetPilot") or None if not found.
    """
    # First, try the method for the packaged application
    packaged_repo = _get_repo_from_packaged_info()
    if packaged_repo:
        return packaged_repo

    # Determine the project root directory based on this file's location.
    # This ensures the git command runs in the correct directory.
    project_root = get_project_or_exe_root()

    try:
        # Need to import here to avoid circular dependency with logger_setup
        from logic.command_utils import run_system_command
        result = run_system_command(
            ["git", "remote", "get-url", "origin"],
            "Could not get remote URL for 'origin'.",
            # Execute the command in the project's root directory
            cwd=str(project_root)
        )
        url = result.stdout.decode('utf-8').strip()

        # Regex to match both HTTPS and SSH URLs
        # e.g., https://github.com/owner/repo.git or git@github.com:owner/repo.git
        match = re.search(r'github\.com[/:]([\w-]+/[\w.-]+?)(\.git)?$', url)
        if match:
            # Group 1 captures the 'owner/repo' part without the optional .git suffix
            return match.group(1).removesuffix('.git')
        return None
    except NetworkManagerError as e:
        # Provide more context on failure. This helps diagnose if git isn't
        # installed, not in a repo, or if the 'origin' remote doesn't exist.
        print(
            f"DEBUG: Failed to get git remote URL. Reason: {e}", file=sys.stderr)
        # The function's contract is to return None on failure, so we don't
        # re-raise.
        return None


def create_github_release(tag: str, title: str, notes: str,
                          repo: str | None = None,
                          asset_paths: list[str] | None = None) -> str | None:
    """
    Creates a new release on GitHub and optionally uploads an asset.

    Args:
        tag: The version tag for the release (e.g., "v1.2.0").
        title: The title of the release.
        notes: The release notes.
        repo: Optional. The GitHub repository in "owner/repo" format. If not
              provided, it will be detected from the local Git
              configuration.
        asset_paths: Optional list of local paths to files to be uploaded as release assets.

    Returns:
        The URL of the new release, or None if an error occurs.
    """
    try:
        # Need to import here to avoid circular dependency with logger_setup
        from logic.command_utils import run_system_command
        # Build the command as a list of arguments. shell=False handles quoting safely.
        if not repo:
            repo = get_repo_from_git_config()
            if not repo:
                raise NetworkManagerError(
                    "Could not determine GitHub repository. Please ensure you are in a Git repository with a configured 'origin' remote.")
        command = [
            'gh', 'release', 'create', tag,
            '--repo', repo,
            '--title', title,
        ]
        if notes:
            command.extend(['--notes', notes])
        else:
            command.append('--generate-notes')

        if asset_paths:
            command.extend(asset_paths)

        # Use a much longer timeout for release creation, as asset uploads can be slow.
        result = run_system_command(
            command,
            f"Failed to create GitHub release for tag {tag}",
            timeout=300  # 5 minutes
        )
        return result.stdout.decode('utf-8').strip()
    except NetworkManagerError as e:
        error_output = str(e).lower()

        # Provide more specific, user-friendly error messages for common failures.
        if "release with tag" in error_output and "already exists" in error_output:
            raise NetworkManagerError(f"A release for tag '{tag}' already exists on GitHub. Please update the version number.",  # noqa: E501
                                      code='TAG_EXISTS'
                                      ) from e
        if "bad credentials" in error_output or "authentication required" in error_output:  # noqa: E501
            raise NetworkManagerError("Authentication with GitHub failed. Your token may have expired. Please run 'gh auth login' in your terminal to re-authenticate.",  # noqa: E501
                                      code='AUTH_FAILED'
                                      ) from e
        if "could not resolve to a repository" in error_output or "not found" in error_output:  # noqa: E501
            raise NetworkManagerError(f"The repository '{repo}' could not be found. Please check for typos or ensure you have access to it.",  # noqa: E501
                                      code='REPO_NOT_FOUND'
                                      ) from e

        # For any other errors, raise a generic but informative exception.
        # The original error details from 'gh' are included.
        raise NetworkManagerError(
            f"Failed to create GitHub release for tag {tag}:\n\n{str(e)}") from e

================================================================================
FILE: git_helper.py
================================================================================

import subprocess
import sys
import os
import argparse

try:
    from github_integration import check_github_cli_auth
except ImportError:
    print(
        "❌ Virhe: Projektin moduuleja ei voitu ladata. Varmista, että "
        "suoritat skriptin projektin juurihakemistosta.", file=sys.stderr)
    sys.exit(1)

class Colors:
    """ANSI color codes for terminal output."""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def run_command(command: list[str], check: bool = True,
                capture: bool = True) -> subprocess.CompletedProcess | None:
    """A helper to run a command and handle errors."""
    try:
        # Using shell=False is safer. The command should be a list of strings.
        return subprocess.run(
            command, check=check, capture_output=capture, text=True,
            encoding='utf-8', shell=False)
    except FileNotFoundError:
        print(f"{Colors.FAIL}❌ Virhe: Komentoa '{command[0]}' ei löytynyt. "
              f"Onko se asennettu ja PATH-ympäristömuuttujassa?{Colors.ENDC}", file=sys.stderr)
        return None
    except subprocess.CalledProcessError as e:
        print(f"{Colors.FAIL}❌ Komennon '{' '.join(command)}' suoritus "
              f"epäonnistui:{Colors.ENDC}", file=sys.stderr)
        error_output = e.stderr or e.stdout
        if error_output:
            print(f"{Colors.FAIL}{error_output.strip()}{Colors.ENDC}", file=sys.stderr)
        return None

def get_current_branch() -> str | None:
    """Gets the current git branch name."""
    result = run_command(["git", "branch", "--show-current"])
    if result:
        return result.stdout.strip()
    return None

def main():
    """A command-line helper to initialize a Git repository and push it to GitHub."""
    epilog_text = """
Mitä tämä skripti tekee:
  1. Tarkistaa, että Git ja GitHub CLI (gh) on asennettu ja toimivat.
  2. Alustaa paikallisen Git-repon, jos sitä ei ole olemassa.
  3. Lisää kaikki projektin tiedostot ja tekee 'commit'-paketin.
  4. Luo uuden julkisen (tai yksityisen) repon GitHub-tilillesi.
  5. Työntää (push) paikallisen koodin uuteen etärepoon.

Jos paikallinen repo on jo linkitetty etärepoon ('origin'), skripti vain
työntää olemassa olevat muutokset sinne.
"""
    parser = argparse.ArgumentParser(
        description="Luo uuden GitHub-repon ja vie olemassa olevan koodin "
                    "sinne.",
        epilog=epilog_text,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "repo_name", help="Uuden GitHub-repositorion nimi (esim. 'NetPilot').")
    parser.add_argument(
        "-m", "--message", default="Initial commit",
        help="Commit-viesti, jota käytetään (oletus: 'Initial commit').")
    parser.add_argument(
        "--private", action="store_true",
        help="Luo yksityisen (private) repositorion. Oletus on julkinen (public).")
    parser.add_argument(
        "-d", "--description", type=str,
        help="Repositorion kuvaus (asetetaan lainausmerkkien sisään).")

    args = parser.parse_args()

    print(f"{Colors.HEADER}--- Aloitetaan lähdekoodin vienti GitHubiin ---{Colors.ENDC}")
    # 1. Tarkista työkalut (Git ja GitHub CLI)
    print(f"\n{Colors.BOLD}1/5: Tarkistetaan työkalujen asennukset...{Colors.ENDC}")
    if not run_command(["git", "--version"]):
        sys.exit(1)
    print(f"{Colors.OKGREEN}✅ Git on asennettu.{Colors.ENDC}")

    is_ok, message = check_github_cli_auth()
    if not is_ok:
        print(f"{Colors.FAIL}❌ Virhe: {message}{Colors.ENDC}", file=sys.stderr)
        sys.exit(1)
    print(f"{Colors.OKGREEN}✅ GitHub CLI on asennettu ja käyttäjä on "
          f"kirjautunut.{Colors.ENDC}")

    # 2. Alusta Git-repository ja tee commit
    if not os.path.isdir('.git'):
        print(f"\n{Colors.BOLD}2/5: Alustetaan uusi Git-repository...{Colors.ENDC}")
        if not run_command(["git", "init"]):
            sys.exit(1)
        # Set default branch to 'main'
        if not run_command(["git", "branch", "-M", "main"]):
            print(f"{Colors.WARNING}⚠️ Varoitus: Oletushaaran nimeäminen "
                  f"'main'-haaraksi epäonnistui.{Colors.ENDC}")
        print(f"{Colors.OKGREEN}✅ Git-repository alustettu ja oletushaaraksi "
              f"asetettu 'main'.{Colors.ENDC}")
    else:
        print(f"\n{Colors.BOLD}2/5: Olemassa oleva Git-repository löydetty.{Colors.ENDC}")

    print("-> Lisätään projektin tiedostot...")
    if not run_command(["git", "add", "."]):
        sys.exit(1)

    # Check if there are changes to commit
    status_result = run_command(["git", "status", "--porcelain"], capture=True)
    if status_result and status_result.stdout:
        print(f"-> Tehdään commit viestillä '{args.message}'...")
        if not run_command(["git", "commit", "-m", args.message]):
            print(f"{Colors.FAIL}❌ Commit epäonnistui odottamattomasti.{Colors.ENDC}",
                  file=sys.stderr)
            sys.exit(1)
        print(f"{Colors.OKGREEN}✅ Commit onnistui.{Colors.ENDC}")
    else:
        print(f"{Colors.OKCYAN}ℹ️ Info: Ei uusia muutoksia committoitavaksi. "
              f"Ohitetaan commit.{Colors.ENDC}")

    # 3. Tarkista, onko etärepository jo linkitetty
    remotes = run_command(["git", "remote", "-v"])
    if remotes and "origin" in remotes.stdout:
        print(f"\n{Colors.BOLD}3/5: Etärepository 'origin' on jo olemassa. "
              f"Ohitetaan luonti.{Colors.ENDC}")
        print(f"\n{Colors.BOLD}4/5: Työnnetään muutokset olemassa olevaan "
              f"repositoryyn...{Colors.ENDC}")
        
        current_branch = get_current_branch()
        if not current_branch:
            print("❌ Ei voitu tunnistaa nykyistä Git-haaraa.", file=sys.stderr)
            sys.exit(1)
            
        if not run_command(["git", "push", "origin", current_branch]):
            print(f"{Colors.FAIL}❌ Koodin työntäminen haaraan "
                  f"'{current_branch}' epäonnistui.{Colors.ENDC}", file=sys.stderr)
            sys.exit(1)
            
        repo_url_output = run_command(["git", "remote", "get-url", "origin"])
        repo_url = repo_url_output.stdout.strip() if repo_url_output else "N/A"

    # 4 & 5. Luo uusi repository ja työnnä koodi sinne
    else:
        print(f"\n{Colors.BOLD}3/5: Vahvistetaan GitHub-repon luonti...{Colors.ENDC}")
        visibility = "--private" if args.private else "--public"
        visibility_text = "yksityisen (private)" if args.private else "julkisen (public)"  # noqa: E501
        
        try:
            confirm = input(
                f"Haluatko luoda uuden {visibility_text} GitHub-repon "
                f"nimellä '{args.repo_name}'? (y/N): ")
            if confirm.lower() != 'y':
                print(f"{Colors.WARNING}Peruutettu käyttäjän toimesta.{Colors.ENDC}")
                sys.exit(0)
        except KeyboardInterrupt:
            print(f"\n{Colors.WARNING}Peruutettu käyttäjän toimesta.{Colors.ENDC}")
            sys.exit(0)

        print(f"\n{Colors.BOLD}4/5: Luodaan uutta GitHub-repositorya...{Colors.ENDC}")
        
        # If repo_name contains a '/', assume it's in 'owner/repo' format.
        # Otherwise, create it under the currently logged-in user.
        if '/' in args.repo_name:
            create_command = ["gh", "repo", "create",
                              args.repo_name, visibility, "--source=."]
        else:
            create_command = ["gh", "repo", "create", args.
                              repo_name, visibility, "--source=.", "--push"]
        
        if args.description:
            create_command.extend(["-d", args.description])

        result = run_command(create_command)
        if not result:
            print(f"{Colors.FAIL}❌ Repositorion luonti epäonnistui. "
                  f"Tarkista yllä oleva virheilmoitus.{Colors.ENDC}", file=sys.stderr)
            print(f"{Colors.FAIL}   (Yleinen syy on, että samanniminen "
                  f"repositorio on jo olemassa GitHubissa.){Colors.ENDC}", file=sys.stderr)
            sys.exit(1)
        
        # If we created the repo under an organization or another user, we
        # need to manually set the remote and push.
        if '/' in args.repo_name:
            print("-> Asetetaan etärepository ja työnnetään koodi...")
            repo_url_for_remote = f"https://github.com/{args.repo_name}.git"
            run_command(
                ["git", "remote", "add", "origin", repo_url_for_remote])
            run_command(["git", "push", "-u", "origin", "main"])

        # The URL can be in stdout or stderr depending on the gh version.
        # We search both to be safe.
        combined_output = result.stdout + "\n" + result.stderr
        repo_url = next((line for line in combined_output.splitlines()
                        if line.startswith('https://github.com/')), "N/A")

        print(f"{Colors.OKGREEN}✅ Repositorio luotu onnistuneesti.{Colors.ENDC}")
        print(f"\n{Colors.BOLD}5/5: Koodi työnnetty GitHubiin.{Colors.ENDC}")

    print(f"\n{Colors.HEADER}--- VALMIS! ---{Colors.ENDC}")
    print(f"{Colors.OKGREEN}✅ Projektisi lähdekoodi on nyt GitHubissa "
          f"osoitteessa: {Colors.OKCYAN}{repo_url.replace('.git', '')}{Colors.ENDC}")

if __name__ == "__main__":
    main()

================================================================================
FILE: LICENSE.md
================================================================================

MIT License

Copyright (c) 2025 Sami Turpeinen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================================================================================
FILE: localization.py
================================================================================

import locale
import configparser
from pathlib import Path

# --- Language Configuration ---
LANG_CODE_KEY = 'lang_code' # A special key to get the current language code itself
SUPPORTED_LANGUAGES = ['en', 'fi']
CURRENT_LANGUAGE = 'en'  # Default, will be updated by initialize_language
DEFAULT_LANGUAGE = 'en'

# --- String Definitions ---
STRINGS = {
    'en': {
        LANG_CODE_KEY: 'en',
        # Startup Errors
        'unsupported_os_title': "Unsupported OS",
        'unsupported_os_message': "This application is designed for Windows only.",
        'admin_required_title': "Admin Rights Required",
        'admin_required_relaunch_prompt': "This application requires administrative privileges to function correctly.\n\nDo you want to restart it as an administrator?",
        'language_change_title': "Language Change",
        'language_change_message': "The language will be updated the next time you start the application.",
        'language_restart_prompt_title': "Restart Required",
        'language_restart_prompt_message': "The language has been changed. Do you want to restart the application now for the changes to take effect?",
        'relaunch_failed_title': "Relaunch Failed",
        'relaunch_failed_message': "Could not restart the application with admin rights. Please check the log file for details.",

        # Generic Errors
        'ui_error_title': "UI Error",
        'ui_error_message': "A critical error occurred with the user interface components. Please check the log file for details.",
        'fatal_error_title': "Fatal Error",
        'fatal_error_message': "A critical error occurred and the application must close. Please check the log file for details.",

        # Log file hint
        'log_file_hint': "\n\nFor more details, see the log file:\n{log_file_path}",

        # Main UI
        'app_title': "NetPilot",
        'status_initializing': "Initializing...",
        'status_initial_load': "Loading initial data...",
        'status_op_cancelled': "Operation cancelled.",
        'status_op_cancelled_by_user': "Operation cancelled by user.",
        'status_enable_attempt': "Attempting to enable '{adapter_name}'...",
        'status_disable_attempt': "Attempting to disable '{adapter_name}'...",
        'status_reset_attempt': "Resetting network stack...",
        'status_failed_op': "Failed to change status for '{adapter_name}'.",
        'status_not_needed': "Operation not needed.",
        'status_refreshing_list': "Refreshing list...",
        'status_disconnect_and_disable': "Attempting automated two-step action...",
        'status_reset_success': "Network stack reset. Reboot required.",
        'status_dns_flush_success': "DNS cache flushed.",
        'status_ip_renew_success': "IP addresses renewed.",
        'status_wifi_disconnected': "Wi-Fi disconnected.",
        'status_ready_select_adapter': "Ready. Select an adapter from the list.",
        'status_fetching': "Fetching...",

        # Menu
        'menu_tools': "Tools",
        'menu_reset_stack': "Reset Network Stack...",
        'menu_release_renew': "Release & Renew IP",
        'menu_flush_dns': "Flush DNS Cache",
        'menu_connections': "Active Connections...",
        'menu_traceroute': "Trace Route...",
        'menu_wifi': "Wi-Fi Networks...",
        'menu_language': "Language",
        'menu_lang_en': "English",
        'menu_lang_fi': "Suomi",
        'menu_publish': "Publish Release...",
        'menu_help': "Help",
        'menu_open_log': "Open Log File",
        'menu_about': "About...",

        # Dialogs
        'about_title': "About NetPilot",
        'about_message_content': "{app_name}\n\nVersion: {version}\nAuthor: {author}",
        'publish_title': "Publish New Release",
        'publish_repo': "Repository (owner/repo):",
        'publish_version': "Version / Tag:",
        'publish_version_tooltip': "Must start with 'v', e.g., v1.2.3",
        'publish_release_title': "Release Title:",
        'publish_notes': "Release Notes:",
        'publish_button': "Publish Release",
        'publish_cancel': "Cancel",
        'publish_missing_info': "Missing Information",
        'publish_missing_info_msg': "Repository, Version, and Title fields are required.",

        # UI Frames
        'available_adapters_title': "Available Adapters",
        'no_adapters_found': "No adapters found.",
        'adapter_details_title': "Adapter Details",
        'button_connect': "Enable",
        'button_disconnect': "Disable",
        'context_menu_copy': "Copy",
        'status_copied_to_clipboard': "Copied '{text}' to clipboard.",
        'wifi_status_title': "Current Wi-Fi Connection",
        'diagnostics_title': "Network Diagnostics",

        # Adapter Details Labels
        'details_description': "Description",
        'details_mac': "MAC Address",
        'details_ipv4': "IPv4 Address",
        'details_ipv6': "IPv6 Address",
        'details_link_speed': "Link Speed",
        'details_download_speed': "Download Speed",
        'details_upload_speed': "Upload Speed",
        'details_driver_version': "Driver Version",
        'details_driver_date': "Driver Date",
        'diag_public_ip': "Public IP",
        'diag_gateway': "Gateway",
        'diag_gateway_latency': "Gateway Latency",
        'diag_external_latency': "External Latency",
        'diag_dns_servers': "DNS Servers",
        'diag_ping_target': "Ping Target",
        'wifi_status_ssid': "SSID",
        'wifi_status_signal': "Signal",
        'wifi_status_ip': "IP Address",
        'wifi_status_not_connected': "Not Connected",
        'wifi_button_disconnect': "Disconnect",
        'netstat_title': "Active Connections (netstat)",
        'netstat_filter_by': "Filter by protocol:",
        'netstat_filter_all': "All",
        'netstat_filter_tcp': "TCP",
        'netstat_filter_udp': "UDP",
        'netstat_col_proto': "Proto",
        'netstat_col_local': "Local Address",
        'netstat_col_foreign': "Foreign Address",
        'netstat_col_state': "State",
        'netstat_col_process': "Process Name",
        'netstat_button_refresh': "Refresh",
        'netstat_button_terminate': "Terminate Process",
        'traceroute_title': "Trace Route",
        'traceroute_target': "Target:",
        'traceroute_button_start': "Start",
        'traceroute_starting': "Tracing route to {target}...",
        'wifi_window_title': "Wi-Fi Management",
        'wifi_tab_available': "Available Networks",
        'wifi_tab_saved': "Saved Profiles",
        'wifi_col_ssid': "SSID",
        'wifi_col_signal': "Signal",
        'wifi_col_auth': "Authentication",
        'wifi_col_encrypt': "Encryption",
        'wifi_col_profile': "Profile Name",
        'wifi_col_password': "Password",
        'wifi_button_refresh': "Refresh",
        'wifi_button_connect': "Connect",
        'wifi_button_delete': "Delete Profile",
        'wifi_button_copy_pass': "Copy Password",
        'wifi_button_export': "Export to File...",
        'wifi_password_prompt_title': "Password Required",
        'wifi_password_prompt_msg': "Enter password for {ssid}:",
        'wifi_connect_status': "Connecting to {ssid}...",
        'wifi_delete_confirm_title': "Confirm Deletion",
        'wifi_delete_confirm_msg': "Are you sure you want to delete the profile '{profile_name}'?",
        'wifi_no_networks_found': "No Wi-Fi networks found.",

        # Queue Handler Messages
        'toggle_error_title': "Execution Error",
        'toggle_error_message': "Operation failed:\n\n{error}",
        'toggle_info_title': "Information",
        'toggle_wifi_connected_title': "Action Required",
        'toggle_confirm_enable_title': "Confirm Enable",
        'toggle_confirm_enable_prompt': "Are you sure you want to enable the adapter '{adapter_name}'?",
        'toggle_confirm_disable_title': "Confirm Disable",
        'toggle_confirm_disable_prompt': "Are you sure you want to disable the adapter '{adapter_name}'?",
        'toggle_wifi_connected_prompt': "Could not disable '{adapter}' because it is connected to a network.\n\nDo you want to automatically disconnect from Wi-Fi and then disable the adapter?",
        'reset_stack_success_title': "Success",
        'reset_stack_success_message': "Network stack has been reset.\nPlease reboot your computer for the changes to take effect.",
        'flush_dns_success_title': "Success",
        'flush_dns_success_message': "Successfully flushed the DNS resolver cache.",
        'release_renew_success_title': "Success",
        'release_renew_success_message': "Successfully released and renewed IP addresses. Refreshing adapter list.",
        'disconnect_wifi_success_title': "Success",
        'disconnect_wifi_success_message': "Successfully disconnected from the Wi-Fi network.",
        'netstat_selection_required': "Selection Required",
        'netstat_selection_required_msg': "Please select a connection from the list first.",
        'netstat_process_info_error': "Could not retrieve process information for the selected connection.",
        'netstat_terminate_confirm_title': "Confirm Termination",
        'netstat_terminate_confirm_prompt': "Are you sure you want to terminate the process '{process_name}' (PID: {pid})?",
        'netstat_terminate_success_msg': "Process '{process_name}' (PID: {pid}) has been terminated.",
        'netstat_terminate_failed_title': "Termination Failed",
        'traceroute_input_required': "Input Required",
        'traceroute_input_required_msg': "Please enter a target host or IP address.",
        'wifi_export_success_title': "Export Successful",
        'wifi_export_success_msg': "Saved Wi-Fi profiles exported to {filepath}",
        'publish_ready': "Ready to publish release.",
        'publish_checking_auth': "Checking GitHub authentication...",
        'publish_auth_failed': "GitHub authentication failed. Please run 'gh auth login'.",
        'publish_auth_failed_title': "GitHub Authentication Failed",
        'publish_success': "Successfully created release {tag} on GitHub.",
        'wifi_password_copied': "Password for '{profile_name}' copied to clipboard.",
        'wifi_select_to_connect': "Please select an item from the list to connect.",
        'wifi_select_to_delete': "Please select a profile to delete.",
    },
    'fi': {
        LANG_CODE_KEY: 'fi',
        # Startup Errors
        'unsupported_os_title': "Ei-tuettu käyttöjärjestelmä",
        'unsupported_os_message': "Tämä sovellus on suunniteltu vain Windows-käyttöjärjestelmälle.",
        'admin_required_title': "Järjestelmänvalvojan oikeudet vaaditaan",
        'admin_required_relaunch_prompt': "Tämä sovellus vaatii järjestelmänvalvojan oikeudet toimiakseen oikein.\n\nHaluatko käynnistää sen uudelleen järjestelmänvalvojana?",
        'language_change_title': "Kielen vaihto",
        'language_change_message': "Kieli päivitetään, kun käynnistät sovelluksen seuraavan kerran.",
        'language_restart_prompt_title': "Uudelleenkäynnistys vaaditaan",
        'language_restart_prompt_message': "Kieli on vaihdettu. Haluatko käynnistää sovelluksen uudelleen nyt, jotta muutokset tulevat voimaan?",
        'relaunch_failed_title': "Uudelleenkäynnistys epäonnistui",
        'relaunch_failed_message': "Sovellusta ei voitu käynnistää uudelleen järjestelmänvalvojan oikeuksilla. Tarkista lokitiedostosta lisätietoja.",

        # Generic Errors
        'ui_error_title': "Käyttöliittymän virhe",
        'ui_error_message': "Käyttöliittymäkomponenteissa tapahtui kriittinen virhe. Tarkista lokitiedosto.",
        'fatal_error_title': "Kriittinen virhe",
        'fatal_error_message': "Tapahtui odottamaton virhe ja sovelluksen on sulkeuduttava. Tarkista lokitiedostosta lisätietoja.",

        # Log file hint
        'log_file_hint': "\n\nLisätietoja löydät lokitiedostosta:\n{log_file_path}",

        # Main UI
        'app_title': "NetPilot",
        'status_initializing': "Alustetaan...",
        'status_initial_load': "Ladataan perustietoja...",
        'status_op_cancelled': "Toiminto peruutettu.",
        'status_op_cancelled_by_user': "Käyttäjä peruutti toiminnon.",
        'status_enable_attempt': "Yritetään ottaa käyttöön '{adapter_name}'...",
        'status_disable_attempt': "Yritetään poistaa käytöstä '{adapter_name}'...",
        'status_reset_attempt': "Nollataan verkkopinoa...",
        'status_failed_op': "Tilan muuttaminen sovittimelle '{adapter_name}' epäonnistui.",
        'status_not_needed': "Toimintoa ei tarvita.",
        'status_refreshing_list': "Päivitetään listaa...",
        'status_disconnect_and_disable': "Yritetään automaattista kaksivaiheista toimintoa...",
        'status_reset_success': "Verkkopino nollattu. Uudelleenkäynnistys vaaditaan.",
        'status_dns_flush_success': "DNS-välimuisti tyhjennetty.",
        'status_ip_renew_success': "IP-osoitteet uusittu.",
        'status_wifi_disconnected': "Wi-Fi-yhteys katkaistu.",
        'status_ready_select_adapter': "Valmis. Valitse sovitin listalta.",
        'status_fetching': "Haetaan...",

        # Menu
        'menu_tools': "Työkalut",
        'menu_reset_stack': "Nollaa verkkopino...",
        'menu_release_renew': "Vapauta ja uusi IP",
        'menu_flush_dns': "Tyhjennä DNS-välimuisti",
        'menu_connections': "Aktiiviset yhteydet...",
        'menu_traceroute': "Jäljitä reitti...",
        'menu_wifi': "Wi-Fi-verkot...",
        'menu_language': "Kieli",
        'menu_lang_en': "English",
        'menu_lang_fi': "Suomi",
        'menu_publish': "Julkaise versio...",
        'menu_help': "Ohje",
        'menu_open_log': "Avaa lokitiedosto",
        'menu_about': "Tietoja...",

        # Dialogs
        'about_title': "Tietoja NetPilotista",
        'about_message_content': "{app_name}\n\nVersio: {version}\nTekijä: {author}",
        'publish_title': "Julkaise uusi versio",
        'publish_repo': "Repository (omistaja/repo):",
        'publish_version': "Versio / Tagi:",
        'publish_version_tooltip': "Pitää alkaa 'v'-kirjaimella, esim. v1.2.3",
        'publish_release_title': "Julkaisun otsikko:",
        'publish_notes': "Julkaisutiedot:",
        'publish_button': "Julkaise versio",
        'publish_cancel': "Peruuta",
        'publish_missing_info': "Puutteelliset tiedot",
        'publish_missing_info_msg': "Repository, versio ja otsikko ovat pakollisia kenttiä.",

        # UI Frames
        'available_adapters_title': "Saatavilla olevat sovittimet",
        'no_adapters_found': "Sovittimia ei löytynyt.",
        'adapter_details_title': "Sovittimen tiedot",
        'button_connect': "Ota käyttöön",
        'button_disconnect': "Poista käytöstä",
        'context_menu_copy': "Kopioi",
        'status_copied_to_clipboard': "Kopioitu '{text}' leikepöydälle.",
        'wifi_status_title': "Nykyinen Wi-Fi-yhteys",
        'diagnostics_title': "Verkkodiagnostiikka",

        # Adapter Details Labels
        'details_description': "Kuvaus",
        'details_mac': "MAC-osoite",
        'details_ipv4': "IPv4-osoite",
        'details_ipv6': "IPv6-osoite",
        'details_link_speed': "Linkin nopeus",
        'details_download_speed': "Latausnopeus",
        'details_upload_speed': "Lähetysnopeus",
        'details_driver_version': "Ajurin versio",
        'details_driver_date': "Ajurin päiväys",
        'diag_public_ip': "Julkinen IP",
        'diag_gateway': "Yhdyskäytävä",
        'diag_gateway_latency': "Yhdyskäytävän viive",
        'diag_external_latency': "Ulkoinen viive",
        'diag_dns_servers': "DNS-palvelimet",
        'diag_ping_target': "Ping-kohde",
        'wifi_status_ssid': "SSID",
        'wifi_status_signal': "Signaali",
        'wifi_status_ip': "IP-osoite",
        'wifi_status_not_connected': "Ei yhdistetty",
        'wifi_button_disconnect': "Katkaise yhteys",
        'netstat_title': "Aktiiviset yhteydet (netstat)",
        'netstat_filter_by': "Suodata protokollan mukaan:",
        'netstat_filter_all': "Kaikki",
        'netstat_filter_tcp': "TCP",
        'netstat_filter_udp': "UDP",
        'netstat_col_proto': "Protok.",
        'netstat_col_local': "Paikallinen osoite",
        'netstat_col_foreign': "Etäosoite",
        'netstat_col_state': "Tila",
        'netstat_col_process': "Prosessin nimi",
        'netstat_button_refresh': "Päivitä",
        'netstat_button_terminate': "Lopeta prosessi",
        'traceroute_title': "Jäljitä reitti",
        'traceroute_target': "Kohde:",
        'traceroute_button_start': "Aloita",
        'traceroute_starting': "Jäljetetään reittiä kohteeseen {target}...",
        'wifi_window_title': "Wi-Fi-hallinta",
        'wifi_tab_available': "Saatavilla olevat verkot",
        'wifi_tab_saved': "Tallennetut profiilit",
        'wifi_col_ssid': "SSID",
        'wifi_col_signal': "Signaali",
        'wifi_col_auth': "Todennus",
        'wifi_col_encrypt': "Salaus",
        'wifi_col_profile': "Profiilin nimi",
        'wifi_col_password': "Salasana",
        'wifi_button_refresh': "Päivitä",
        'wifi_button_connect': "Yhdistä",
        'wifi_button_delete': "Poista profiili",
        'wifi_button_copy_pass': "Kopioi salasana",
        'wifi_button_export': "Vie tiedostoon...",
        'wifi_password_prompt_title': "Salasana vaaditaan",
        'wifi_password_prompt_msg': "Anna verkon {ssid} salasana:",
        'wifi_connect_status': "Yhdistetään verkkoon {ssid}...",
        'wifi_delete_confirm_title': "Vahvista poisto",
        'wifi_delete_confirm_msg': "Haluatko varmasti poistaa profiilin '{profile_name}'?",
        'wifi_no_networks_found': "Wi-Fi-verkkoja ei löytynyt.",

        # Queue Handler Messages
        'toggle_error_title': "Suoritusvirhe",
        'toggle_error_message': "Toiminto epäonnistui:\n\n{error}",
        'toggle_info_title': "Tiedoksi",
        'toggle_wifi_connected_title': "Toiminto vaaditaan",
        'toggle_confirm_enable_title': "Vahvista käyttöönotto",
        'toggle_confirm_enable_prompt': "Haluatko varmasti ottaa käyttöön sovittimen '{adapter_name}'?",
        'toggle_confirm_disable_title': "Vahvista käytöstä poisto",
        'toggle_confirm_disable_prompt': "Haluatko varmasti poistaa käytöstä sovittimen '{adapter_name}'?",
        'toggle_wifi_connected_prompt': "Sovittimen '{adapter}' poistaminen käytöstä epäonnistui, koska se on yhdistetty verkkoon.\n\nHaluatko katkaista Wi-Fi-yhteyden automaattisesti ja poistaa sitten sovittimen käytöstä?",
        'reset_stack_success_title': "Onnistui",
        'reset_stack_success_message': "Verkkopino on nollattu.\nKäynnistä tietokone uudelleen, jotta muutokset tulevat voimaan.",
        'flush_dns_success_title': "Onnistui",
        'flush_dns_success_message': "DNS-välimuisti on tyhjennetty onnistuneesti.",
        'release_renew_success_title': "Onnistui",
        'release_renew_success_message': "IP-osoitteet on vapautettu ja uusittu onnistuneesti. Päivitetään sovitinlistaa.",
        'disconnect_wifi_success_title': "Onnistui",
        'disconnect_wifi_success_message': "Wi-Fi-yhteys on katkaistu onnistuneesti.",
        'netstat_selection_required': "Valinta vaaditaan",
        'netstat_selection_required_msg': "Valitse ensin yhteys listalta.",
        'netstat_process_info_error': "Valitun yhteyden prosessitietoja ei voitu hakea.",
        'netstat_terminate_confirm_title': "Vahvista lopetus",
        'netstat_terminate_confirm_prompt': "Haluatko varmasti lopettaa prosessin '{process_name}' (PID: {pid})?",
        'netstat_terminate_success_msg': "Prosessi '{process_name}' (PID: {pid}) on lopetettu.",
        'netstat_terminate_failed_title': "Lopetus epäonnistui",
        'traceroute_input_required': "Syöte vaaditaan",
        'traceroute_input_required_msg': "Anna kohde (isäntänimi tai IP-osoite).",
        'wifi_export_success_title': "Vienti onnistui",
        'wifi_export_success_msg': "Tallennetut Wi-Fi-profiilit viety tiedostoon {filepath}",
        'publish_ready': "Valmis julkaisemaan version.",
        'publish_checking_auth': "Tarkistetaan GitHub-autentikointia...",
        'publish_auth_failed': "GitHub-autentikointi epäonnistui. Suorita 'gh auth login'.",
        'publish_auth_failed_title': "GitHub-autentikointi epäonnistui",
        'publish_success': "Versio {tag} luotu onnistuneesti GitHubiin.",
        'wifi_password_copied': "Verkon '{profile_name}' salasana kopioitu leikepöydälle.",
        'wifi_select_to_connect': "Valitse kohde listalta yhdistääksesi.",
        'wifi_select_to_delete': "Valitse profiili listalta poistaaksesi.",
    }
}

CONFIG_FILE = Path(__file__).parent / 'config.ini'

def _get_system_language() -> str:
    """Detects the OS language as a fallback."""
    try:
        # E.g., 'en_US', 'fi_FI'
        lang_code, _ = locale.getdefaultlocale()
        if lang_code:
            primary_lang = lang_code.split('_')[0]
            if primary_lang in SUPPORTED_LANGUAGES:
                return primary_lang
    except Exception:
        pass
    return DEFAULT_LANGUAGE

def set_language(lang_code: str):
    """Saves the selected language to the config file."""
    if lang_code not in SUPPORTED_LANGUAGES:
        return
    config = configparser.ConfigParser()
    # Lue olemassa oleva tiedosto, jotta muut asetukset säilyvät
    if CONFIG_FILE.exists():
        config.read(CONFIG_FILE, encoding='utf-8')
    if 'Settings' not in config:
        config['Settings'] = {}
    config['Settings']['language'] = lang_code
    with CONFIG_FILE.open('w', encoding='utf-8') as configfile:
        config.write(configfile)

def initialize_language():
    """
    Initializes the language by reading from the config file,
    falling back to system language, and finally to the default.
    Updates the global CURRENT_LANGUAGE variable.
    """
    global CURRENT_LANGUAGE
    config = configparser.ConfigParser()
    if CONFIG_FILE.exists():
        config.read(CONFIG_FILE, encoding='utf-8')
        saved_lang = config.get('Settings', 'language', fallback=None)
        if saved_lang in SUPPORTED_LANGUAGES:
            CURRENT_LANGUAGE = saved_lang
            return
    CURRENT_LANGUAGE = _get_system_language()

def get_string(key: str, **kwargs) -> str:
    """
    Retrieves a localized string by its key and formats it with provided arguments.
    If a default is provided, it's used when the key is not found.
    """
    return STRINGS[CURRENT_LANGUAGE].get(key, kwargs.get('default', f"<{key}>")).format(**kwargs)

================================================================================
FILE: logger_setup.py
================================================================================

import logging
import logging.handlers
import os
import sys
from pathlib import Path

# --- Logging Configuration ---

# Use the user's AppData/Roaming directory for logs. This is the standard for
# Windows applications and avoids permission issues with Program Files.
# Fallback to the script's directory if APPDATA is not set.
LOG_DIR_PARENT = Path(os.getenv('APPDATA', '.'))
APP_NAME = "NetPilot"
LOG_DIR = LOG_DIR_PARENT / APP_NAME / "logs"
LOG_FILE_NAME = "app.log"

# Configuration for the RotatingFileHandler
MAX_LOG_SIZE_BYTES = 1 * 1024 * 1024  # 1 MB
BACKUP_COUNT = 5  # Keep 5 old log files (e.g., app.log.1, app.log.2, ...)


def _get_log_level_from_env() -> int:
    """
    Gets the logging level from the 'LOG_LEVEL' environment variable.
    Defaults to logging.INFO if the variable is not set or invalid.
    """
    # Default to DEBUG when running from source for better development feedback,
    # and INFO when packaged to avoid overly verbose logs for end-users.
    if getattr(sys, 'frozen', False):
        default_level = 'INFO'
    else:
        default_level = 'DEBUG'

    log_level_str = os.getenv('LOG_LEVEL', default_level).upper()
    log_levels = {
        'DEBUG': logging.DEBUG,
        'INFO': logging.INFO,
        'WARNING': logging.WARNING,
        'ERROR': logging.ERROR,
        'CRITICAL': logging.CRITICAL,
    }
    return log_levels.get(log_level_str, logging.INFO)


def get_log_file_path() -> Path:
    """Returns the full, absolute path to the log file."""
    return LOG_DIR / LOG_FILE_NAME


def get_project_or_exe_root() -> Path:
    """
    Returns the absolute path to the project root when running from source,
    or the directory containing the .exe when running as a packaged app.
    """
    if getattr(sys, 'frozen', False):
        # Running as a bundled exe (e.g., via PyInstaller).
        # The executable is in the root of the distribution.
        return Path(sys.executable).parent
    else:
        # Running as a script
        return Path(sys.argv[0]).resolve().parent

def get_dist_path() -> Path:
    """Returns the absolute path to the 'dist' directory."""
    if getattr(sys, 'frozen', False):
        return get_project_or_exe_root()
    return get_project_or_exe_root() / 'dist'


def setup_logging() -> Path | None:
    """
    Configures logging with a RotatingFileHandler and a console handler.

    - Logs are stored in a version-safe, user-specific directory.
    - Log files rotate to prevent them from growing indefinitely.
    - If file logging fails, it falls back to console-only logging.

    Returns:
        The absolute path to the log file if successful, otherwise None.
    """
    log_file_path: Path = get_log_file_path()
    log_formatter = logging.Formatter(
        # Lisätään funktion nimi ja rivinumero lokiviesteihin paremman kontekstin saamiseksi.
        '%(asctime)s - %(levelname)-8s - [%(name)s:%(funcName)s:%(lineno)d] - %(message)s'
    )
    root_logger = logging.getLogger()
    # Set level from environment variable, defaulting to INFO.
    # This allows for easy debugging without code changes.
    root_logger.setLevel(_get_log_level_from_env())
    
    # Clear any existing handlers to prevent duplicate logging.
    if root_logger.hasHandlers():
        root_logger.handlers.clear()

    # --- File Handler (Rotating) ---
    try:
        # Ensure the log directory exists.
        LOG_DIR.mkdir(parents=True, exist_ok=True)

        # Create a handler that rotates log files when they reach a certain size.
        file_handler = logging.handlers.RotatingFileHandler(
            log_file_path,
            maxBytes=MAX_LOG_SIZE_BYTES,
            backupCount=BACKUP_COUNT,
            encoding='utf-8'
        )
        file_handler.setFormatter(log_formatter)
        root_logger.addHandler(file_handler)
    except (OSError, PermissionError) as e:
        # If we can't create the log directory/file, we can't log to a file.
        # Fallback to console-only logging and print an error.
        print(f"CRITICAL: Unable to create log file at {log_file_path}. "
              f"Logging to console only. Error: {e}", file=sys.stderr)        

    # --- Console Handler ---
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(log_formatter)
    root_logger.addHandler(console_handler)

    # Return the path only if the file handler was successfully added.
    return log_file_path if any(isinstance(h, logging.FileHandler) for h in root_logger.handlers) else None

================================================================================
FILE: main.py
================================================================================

import tkinter as tk
from tkinter import messagebox
import logging
import sys
import os

import logger_setup
from localization import initialize_language, get_string, set_language
from logic.system import is_admin, relaunch_as_admin
from gui.main_window import NetworkManagerApp
from gui.app_context import AppContext

def main():
    """Main entry point for the application."""
    # --- 1. Initial Setup ---
    # Set up logging as the very first thing.
    log_file_path = logger_setup.setup_logging()
    logger = logging.getLogger(__name__)
    logger.info("-----------------------------------------------------")
    logger.info("Application starting up.")

    # Initialize language settings
    initialize_language()

    # --- 2. Pre-flight Checks ---
    logger.info("Performing pre-flight checks...")
    if sys.platform != "win32":
        logger.critical("Unsupported OS: %s", sys.platform)
        messagebox.showerror(get_string('unsupported_os_title'),
                             get_string('unsupported_os_message'))
        return

    if not is_admin():
        logger.warning(
            "Application not running with admin rights. "
            "Attempting automatic relaunch.")
        try:
            # Directly attempt to relaunch as admin without asking the user.
            # The OS will show a UAC prompt, which the user can accept or deny.
            relaunch_as_admin()
        except Exception as e:
            logger.critical("Failed to relaunch with admin rights.", exc_info=True)
            message = (get_string('relaunch_failed_message') + get_string(
                'log_file_hint', log_file_path=log_file_path))
            messagebox.showerror(get_string('relaunch_failed_title'), message)
        # The current non-admin instance will exit, regardless of whether the
        # relaunch succeeds.
        return

    logger.info("Pre-flight checks passed. Initializing main application.")

    # --- 3. Application Initialization ---
    try:
        # The AppContext holds the shared state and logic handlers.
        context = AppContext()

        # Initialize core components that depend on the UI being created.
        # This must be done after the app and its frames are instantiated
        # but before the mainloop starts.
        app = NetworkManagerApp(context)
        context.initialize_components(app, app.ui_frames, app.status_var)

        # Start the Tkinter event loop.
        app.mainloop()

    except Exception as e:
        logger.critical("An unhandled exception occurred in the main application.",
                        exc_info=True)
        message = (get_string('fatal_error_message') + get_string(
            'log_file_hint', log_file_path=log_file_path))
        messagebox.showerror(get_string('fatal_error_title'), message)
    finally:
        logger.info("Application shut down gracefully.\n")

if __name__ == "__main__":
    main()

================================================================================
FILE: publish.py
================================================================================



================================================================================
FILE: publish_dialog.py
================================================================================

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
from pathlib import Path
import logging

from gui.base_window import BaseTaskWindow
from gui.utils import create_tooltip
from localization import get_string
from logger_setup import get_project_or_exe_root
from exceptions import NetworkManagerError

logger = logging.getLogger(__name__)

class PublishDialog(BaseTaskWindow):
    """
    A dialog window for creating a new GitHub release.
    """
    def __init__(self, context):
        # The parent is automatically handled by BaseTaskWindow via context.root # noqa: E501
        super().__init__(context, title=get_string("publish_title"),
                         geometry="600x550")

        self.repo_var = tk.StringVar()
        self.version_var = tk.StringVar()
        self.title_var = tk.StringVar()

        self._create_widgets()
        self._initialize_fields()
        self._load_changelog()

    def _create_widgets(self):
        """Creates and lays out the widgets for the dialog."""
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Input Fields ---
        fields_frame = ttk.Frame(main_frame)
        fields_frame.pack(fill=tk.X, pady=(0, 10))
        fields_frame.columnconfigure(1, weight=1)

        # Repository
        ttk.Label(fields_frame, text=get_string('publish_repo')).grid(
            row=0, column=0, sticky="w", padx=5, pady=2)
        repo_entry = ttk.Entry(fields_frame, textvariable=self.repo_var)
        repo_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        # Version / Tag
        ttk.Label(fields_frame, text=get_string('publish_version')).grid(
            row=1, column=0, sticky="w", padx=5, pady=2)
        version_entry = ttk.Entry(fields_frame, textvariable=self.version_var)
        version_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        create_tooltip(version_entry, get_string('publish_version_tooltip'))

        # Release Title
        ttk.Label(fields_frame, text=get_string('publish_release_title')).grid(
            row=2, column=0, sticky="w", padx=5, pady=2)
        title_entry = ttk.Entry(fields_frame, textvariable=self.title_var)
        title_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=2)

        # --- Release Notes ---
        ttk.Label(main_frame, text=get_string('publish_notes')).pack(anchor='w', padx=5)
        self.notes_text = scrolledtext.ScrolledText(
            main_frame, wrap=tk.WORD, height=10, relief=tk.SOLID, borderwidth=1)
        self.notes_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # --- Buttons ---
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)

        # --- Progress Bar and Status ---
        self.progress_frame = ttk.Frame(main_frame)
        self.progress_label = ttk.Label(
            self.progress_frame, text="Publishing, please wait...")
        self.progress_bar = ttk.Progressbar(self.progress_frame, mode='indeterminate')

        self.publish_button = ttk.Button(button_frame,
                                         text=get_string('publish_button'),
                                         command=self._on_publish)
        self.publish_button.grid(row=0, column=0, padx=5, sticky="e")

        self.cancel_button = ttk.Button(button_frame,
                                        text=get_string('publish_cancel'),
                                        command=self.destroy)
        self.cancel_button.grid(row=0, column=1, padx=5, sticky="w")

        self.progress_frame.pack(fill=tk.X, pady=(10, 0), padx=5)

    def _initialize_fields(self):
        """Populates the input fields with default values."""
        repo = self.context.action_handler.app_logic.get_repo_from_git_config()
        if repo:
            self.repo_var.set(repo)

        # Read the version directly from the file each time the dialog is opened
        # to ensure it's always up-to-date, especially after running build.py.
        try:
            version_path = get_project_or_exe_root() / "VERSION"
            version = version_path.read_text(encoding="utf-8").strip()
            if version:
                self.version_var.set(f"v{version}")
                self.title_var.set(f"NetPilot v{version}")
        except (FileNotFoundError, IOError) as e:
            logger.warning(
                "Could not read VERSION file to populate publish dialog: %s", e)
            self.version_var.set("v0.0.0")
            self.title_var.set("NetPilot v0.0.0")

    def _load_changelog(self):
        """Finds and loads the content of CHANGELOG.md into the notes text widget."""
        self.notes_text.delete("1.0", tk.END)
        try:
            # Use the robust helper to find the project root.
            changelog_file = get_project_or_exe_root() / "CHANGELOG.md"

            if changelog_file.is_file():
                content = changelog_file.read_text(encoding='utf-8')
                current_tag = self.version_var.get()
                current_version_in_dialog = current_tag.lstrip('v')

                # Check if the changelog title matches the current version in the dialog.
                # If not, it's stale and should be regenerated.
                if f"Muutokset versiossa {current_version_in_dialog}" in content:  # noqa: E501
                    self.notes_text.insert(tk.END, content)
                    self.context.status_var.set(get_string('publish_ready'))
                else:
                    # The changelog is for a different version. Regenerate it.
                    logger.info(
                        "Stale CHANGELOG.md detected. Regenerating for version %s.",
                        current_version_in_dialog)
                    self.context.action_handler.generate_changelog_and_update_dialog(
                        current_version_in_dialog,
                        lambda new_content: self.notes_text.insert(tk.END, new_content)
                    )
            else:
                default_text = (
                    "- CHANGELOG.md not found.\n- Run 'python build.py' to "
                    "generate release notes from recent commits.\n- "
                    "Alternatively, write or paste the release notes manually here.")
                self.notes_text.insert(tk.END, default_text)
        except Exception as e:
            logger.error("Failed to load changelog", exc_info=True)
            self.notes_text.insert(tk.END, f"Error loading changelog:\n{e}")
        finally:
            # Hide progress bar initially
            self.progress_frame.pack_forget()
    
    def _on_publish(self):
        """Handles the logic for publishing the release."""
        repo = self.repo_var.get().strip()
        tag = self.version_var.get().strip()
        title = self.title_var.get().strip()
        notes = self.notes_text.get("1.0", tk.END).strip()

        if not all((repo, tag, title)):
            messagebox.showerror(get_string('publish_missing_info'),
                                 get_string('publish_missing_info_msg'))
            return

        # Show progress bar and disable buttons
        self.progress_frame.pack(fill=tk.X, pady=(10, 0), padx=5)
        self.progress_label.pack(fill=tk.X)
        self.progress_bar.pack(fill=tk.X, pady=(5, 0))
        self.progress_bar.start()

        self.publish_button.config(state=tk.DISABLED)
        self.cancel_button.config(state=tk.DISABLED)

        # The on_complete callback will now be handled by the QueueHandler,
        # which will close this window upon success.
        self.context.action_handler.publish_release(
            repo, tag, title, notes, on_complete=self.destroy)

================================================================================
FILE: pytest.ini
================================================================================

[pytest]
# Tämä kertoo pytestille, että projektin juurihakemisto on lisättävä
# Python-polkuun. Tämä mahdollistaa suorat importit kuten 'from logic.system import ...'
# ilman, että testitiedostoissa tarvitsee muokata sys.path-muuttujaa.
pythonpath = .

# Määritellään hakemisto, josta testit löytyvät.
testpaths = tests

# Oletusarvoiset komentorivivalitsimet, jotka ajetaan aina.
addopts =
    -v
    -rA
    --strict-markers
    --cov=.
    --cov-report=term-missing
    --cov-report=xml
    --cov-fail-under=60

[flake8]
# Asetetaan moderni rivinpituus
max-line-length = 80
# Ohitetaan virheet, jotka ovat ristiriidassa Black-formatoijan kanssa
# E203: välilyönti ennen ':'
# W503: rivinvaihto ennen binäärioperaattoria
extend-ignore = E203, W503
# Määritellään kansiot, joita ei tarkisteta
exclude =
    .git,
    __pycache__,
    build,
    dist,
    venv,
    .venv

[mypy]
# Ohitetaan virheet puuttuvista tyyppivihjeistä kolmannen osapuolen kirjastoissa (esim. tkinter)
ignore_missing_imports = True
# Älä seuraa importteja kirjastoihin, joilla ei ole tyyppivihjeitä
follow_imports = skip

[coverage:run]
# Mitataan myös haarautumien kattavuus.
branch = True

[coverage:report]
# Määritellään tiedostot ja kansiot, joita ei oteta huomioon kattavuusraportissa.
omit =
    tests/*
    build.py
    git_helper.py
    logger_setup.py
    create_context.py
    project_context.txt

================================================================================
FILE: README.MD
================================================================================

# NetPilot

[![CI Status](https://github.com/atkeppu/NetPilot/actions/workflows/ci.yml/badge.svg)](https://github.com/atkeppu/NetPilot/actions/workflows/ci.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

**NetPilot** on monipuolinen verkonhallinta- ja diagnostiikkatyökalu Windows-käyttöjärjestelmille. Se tarjoaa graafisen käyttöliittymän yleisimpiin verkon vianmääritys- ja hallintatehtäviin, jotka vaativat normaalisti komentorivin käyttöä.

![NetPilot Screenshot](screenshot.png)

## Sisällysluettelo

- [Ominaisuudet](#ominaisuudet)
- [Asennus ja käyttö](#asennus-ja-käyttö)
- [Vaatimukset](#vaatimukset)
- [Kehitys](#kehitys)
- [Arkkitehtuuri ja prosessit](#arkkitehtuuri-ja-prosessit)
  - [Projektin Roadmap](#projektin-roadmap)
  - [Jatkuva Integraatio (CI) ja Toimitus (CD)](#jatkuva-integraatio-ci-ja-toimitus-cd)
- [Kehitysprosessi ja Tekoälyn Rooli](#kehitysprosessi-ja-tekoälyn-rooli)
- [Osallistuminen (Contributing)](#osallistuminen-contributing)
- [Lisenssi](#lisenssi)

## Ominaisuudet

*   **Verkkosovittimien hallinta:** Ota käyttöön (Enable) ja poista käytöstä (Disable) verkkosovittimia helposti.
*   **Yksityiskohtaiset tiedot:** Näe sovittimien tiedot, kuten IP- ja MAC-osoitteet, nopeudet ja ajuritiedot.
*   **Wi-Fi-työkalut:**
    *   Selaa ja yhdistä saatavilla oleviin Wi-Fi-verkkoihin.
    *   Tarkastele ja poista tallennettuja Wi-Fi-profiileja.
    *   Kopioi tallennettujen verkkojen salasanat leikepöydälle.
    *   Vie profiilit ja salasanat tekstitiedostoon.
*   **Diagnostiikka:**
    *   Seuraa reaaliaikaisesti lataus- ja lähetysnopeuksia.
    *   Tarkista julkinen IP-osoite, yhdyskäytävän ja ulkoisen palvelimen viiveet.
    *   Suorita `tracert` ja `netstat` graafisessa näkymässä.
*   **Verkon ylläpito:**
    *   Tyhjennä DNS-välimuisti (`ipconfig /flushdns`).
    *   Uusi IP-osoite (`ipconfig /release` & `/renew`).
    *   Nollaa verkkopino (`netsh winsock reset`).

## Asennus ja käyttö

### Valmis sovellus (.exe)

1.  Lataa uusin `NetPilot.exe` projektin Releases-sivulta (linkki lisätään myöhemmin).
2.  Käynnistä ladattu tiedosto. Asennusta ei vaadita.

> **Huom!** Ohjelma vaatii **ylläpitäjän oikeudet** toimiakseen oikein, koska se muokkaa verkkosovittimien asetuksia.

### Lähdekoodista suorittaminen

1.  Kloonaa tämä repositorio: `git clone https://github.com/atkeppu/NetPilot.git`
2.  Siirry projektihakemistoon: `cd NetPilot`
3.  Asenna ajonaikaiset riippuvuudet: `pip install -r requirements.txt`
4.  Käynnistä pääskripti ylläpitäjän oikeuksin: `python main.py`

## Vaatimukset

*   Windows 10 tai uudempi.
*   Python 3.10+ (jos suoritetaan lähdekoodista).
*   GitHub CLI (jos käytät `git_helper.py`-skriptiä).

## Kehitys

Tämä osio on tarkoitettu kehittäjille, jotka haluavat muokata koodia tai rakentaa ohjelman itse.

### Kehitysympäristön pystyttäminen

1.  Varmista, että sinulla on Python 3.10+ asennettuna.
2.  Kloonaa repositorio ja siirry sen juurihakemistoon.
3.  (Suositus) Luo ja aktivoi virtuaaliympäristö:
    ```bash
    python -m venv venv
    ```
    Aktivoi virtuaaliympäristö PowerShellissä:
    ```powershell
    .\venv\Scripts\Activate.ps1
    ```
    > **Huom!** Jos saat virheilmoituksen, sinun on ehkä sallittava skriptien suorittaminen nykyisessä istunnossa komennolla: `Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process`
4.  Asenna kehityksessä tarvittavat riippuvuudet:
    ```bash
    pip install -r requirements-dev.txt
    ```

### Koodin laadun tarkistaminen

Projekti käyttää `mypy`-työkalua koodin tyyppiturvallisuuden varmistamiseksi. Voit suorittaa tarkistuksen manuaalisesti komennolla:

*   **Suorita staattinen tyyppitarkistus `mypy`:llä:**
    ```bash
    mypy .
    ```

### Sovelluksen rakentaminen (.exe)

Voit paketoida sovelluksen yhdeksi `.exe`-tiedostoksi `build.py`-skriptillä.
1.  Varmista, että olet asentanut kehitysriippuvuudet (katso yllä).
2.  Suorita build-skripti:
    ```bash
    python build.py
    ```
3.  Valmis `NetPilot.exe`-tiedosto löytyy `dist`-kansiosta.

#### Build-prosessin työkalut

`build.py`-skripti hyödyntää kahta ulkoista työkalua, jotka on asennettava erikseen:

1.  **UPX (Ultimate Packer for eXecutables)**
    *   **Mitä tekee:** Pienentää `NetPilot.exe`-tiedoston kokoa merkittävästi (yleensä ~35 MB -> ~15 MB) pakkaamalla sen.
    *   **Asennus:** Lataa UPX viralliselta sivulta, pura paketti ja lisää `upx.exe` järjestelmän `PATH`-ympäristömuuttujaan (esim. kopioimalla se `C:\Windows`-kansioon). Skripti löytää ja käyttää sitä automaattisesti, jos se on asennettu.

2.  **Inno Setup**
    *   **Mitä tekee:** Luo ammattimaisen asennusohjelman (`NetPilot-x.x.x-setup.exe`), joka osaa luoda pikakuvakkeita ja mahdollistaa sovelluksen helpon poistamisen Ohjauspaneelista.
    *   **Asennus:** Lataa ja asenna Inno Setup viralliselta sivulta. `build.py`-skripti olettaa, että se on asennettu oletussijaintiin (`C:\Program Files (x86)\Inno Setup 6`).

> **Huom:** Build-prosessi toimii, vaikka näitä työkaluja ei olisi asennettu. Tällöin `.exe`-tiedosto on suurempi, eikä asennusohjelmaa luoda.

#### Versionumeron hallinta

`build.py`-skripti tukee versionumeron automaattista päivittämistä `--increment`-valitsimella. Tämä on suositeltu tapa hallita versioita ennen uuden julkaisun tekemistä.

*   **Päivitä patch-versio** (esim. 1.4.0 -> 1.4.1):
    ```bash
    python build.py --increment patch
    ```
*   **Päivitä minor-versio** (esim. 1.4.1 -> 1.5.0):
    ```bash
    python build.py --increment minor
    ```

Jos komento ajetaan ilman `--increment`-valitsinta, skripti käyttää olemassa olevaa versiota `VERSION`-tiedostosta.

### Julkaisuprosessin logiikka

Sovelluksen julkaisuikkuna on suunniteltu joustavaksi:

1.  **Versionumeron päivitys:** Voit päivittää versionumeron `build.py`-skriptillä (`--increment patch`), muokata `VERSION`-tiedostoa käsin tai muuttaa version suoraan julkaisuikkunassa. Onnistuneen julkaisun jälkeen uusi versio tallentuu automaattisesti `VERSION`-tiedostoon.
2.  **Muutoslokin generointi:** Jos julkaisuikkunassa oleva versio ei vastaa `CHANGELOG.md`-tiedoston versiota, muutosloki generoidaan automaattisesti uudelleen oikealla versiolla.
3.  **Asennustiedoston etsintä:** Julkaisutoiminto etsii dynaamisesti `dist`-kansiosta minkä tahansa `*-setup.exe`-päätteisen tiedoston. Tämä varmistaa, että oikea asennustiedosto löytyy, vaikka olisit muuttanut versionumeroa dialogissa juuri ennen julkaisua. Jos asennustiedostoa ei löydy, se lataa pelkän `NetPilot.exe`-tiedoston.

### Arkkitehtuurikaavioiden tarkastelu

`ARCHITECTURE.md`-tiedosto sisältää Mermaid-syntaksilla luotuja kaavioita, jotka visualisoivat sovelluksen rakennetta. Nämä kaaviot eivät välttämättä näy oikein kaikissa Markdown-katseluohjelmissa.

**Suositus:** Käytä editoria, joka tukee Mermaid-laajennuksia. Esimerkiksi:

*   **Visual Studio Code:** Asenna laajennus `Markdown Preview Mermaid Support`. Tämän jälkeen kaaviot näkyvät oikein, kun avaat `.md`-tiedoston esikatselun (esim. `Ctrl+Shift+V`).
*   **GitHub:** Mermaid-kaaviot renderöityvät automaattisesti, kun ne ovat ````mermaid` koodilohkojen sisällä, kuten `ARCHITECTURE.md`-tiedostossa on tehty.

### Kehittäjän aputyökalut

Projekti sisältää apuskriptejä, jotka helpottavat kehitystyötä.

#### `git_helper.py`

Tämä skripti automatisoi uuden GitHub-projektin luomisen ja olemassa olevan koodin lähettämisen sinne. Tämä on hyödyllistä, kun aloitat uuden projektin paikallisesti ja haluat julkaista sen GitHubiin vaivattomasti.

**Esimerkkikäyttö:**

```bash
# Luo uusi julkinen projekti nimeltä "NetPilot" GitHubiin
python git_helper.py NetPilot -d "Projektin kuvaus tähän"
```

#### `create_context.py`

Tämä skripti kerää kaikki projektin relevantit lähdekooditiedostot yhteen isoon tekstitiedostoon (`project_context.txt`). Tämä on erittäin kätevää, kun haluat antaa koko projektin kontekstin kerralla esimerkiksi tekoälyavustajalle (kuten Gemini).

Skripti lukee automaattisesti ohitettavat tiedostot ja kansiot kahdesta paikasta:
1.  Projektin juureen luodusta `.contextignore`-tiedostosta.
2.  VS Coden asetuksista (`.vscode/settings.json`), jos sellainen on olemassa.

**Käyttö:**

```bash
# Suorita skripti projektin juurihakemistossa
python create_context.py
```

## Jatkuva Toimitus (CD)

Projekti ei tällä hetkellä hyödynnä täysin automatisoitua jatkuvan toimituksen (Continuous Deployment) putkea, jossa jokainen muutos päähaaraan johtaisi automaattisesti uuteen julkaisuun. Sen sijaan käytössä on puoliautomaattinen julkaisuprosessi, joka nojaa vahvasti kehittäjän toimiin ja sovelluksen sisäisiin työkaluihin:

1. **Rakentaminen:** Kehittäjä rakentaa uuden sovellusversion paikallisesti `build.py`-skriptillä. Tämä skripti hoitaa versionumeron päivityksen, muutoslokin generoinnin, `.exe`-tiedoston luomisen PyInstallerilla ja asennuspaketin luomisen Inno Setupilla.  
2. **Julkaisu:** Sovelluksen sisäänrakennettu *"Julkaise versio..."* -toiminto (`publish_dialog.py`) avaa ikkunan, jossa kehittäjä voi tarkistaa version, muutoslokin ja muut tiedot.  
3. **GitHub-julkaisu:** *"Julkaise"*-painike käyttää GitHub CLI (`gh`) -työkalua luodakseen uuden julkaisun (Release) suoraan GitHub-repositorioon ja lataa `build.py`:n luoman asennustiedoston sinne.  

Tämä malli antaa kehittäjälle täyden kontrollin julkaisuajankohtaan, mutta automatisoi suurimman osan manuaalisista ja virheherkistä vaiheista.

## Jatkuva Integraatio (CI)

Projekti käyttää GitHub Actions -työnkulkua jatkuvaan integraatioon. CI-prosessi on määritelty tiedostossa `.github/workflows/ci.yml`, ja se varmistaa koodin laadun ja toimivuuden automaattisesti.

CI-työnkulku suoritetaan jokaisen `push`- ja `pull_request`-tapahtuman yhteydessä `main`-haaraan, ja se sisältää seuraavat vaiheet:

1. **Ympäristön alustus:** Pystyttää Windows-ympäristön ja määritellyn Python-version.  
2. **Riippuvuuksien asennus:** Asentaa kaikki kehityksessä tarvittavat riippuvuudet `requirements-dev.txt`-tiedostosta.  
3. **Tyyppitarkistus:** Suorittaa staattisen tyyppitarkistuksen `mypy`-työkalulla varmistaen, ettei koodissa ole tyyppivirheitä.  
4. **Testaus:** Ajaa yksikkötestit `pytest`-työkalulla. Testauksen yhteydessä mitataan myös testikattavuus, ja CI-ajo epäonnistuu, jos kattavuus alittaa `pytest.ini`-tiedostossa määritellyn rajan.  

Voit seurata CI-ajojen tilaa suoraan GitHub-repositorion **Actions**-välilehdeltä.

## Kehitysprosessi ja Tekoälyn Rooli

Tämä projekti on kehitetty hyödyntäen laajasti tekoälyavusteisia työkaluja, kuten Gemini Code Assistia. Tekoälyä on käytetty monissa kehitysvaiheissa:

*   **Koodin generointi:** Rutiininomaisten funktioiden ja koodirakenteiden luominen.
*   **Refaktorointi:** Koodin laadun ja luettavuuden parantaminen.
*   **Virheenkorjaus:** Ongelmien tunnistaminen ja korjausehdotusten saaminen.
*   **Dokumentaatio:** Kommenttien, `README`-tiedoston ja muiden selittävien tekstien kirjoittaminen.
*   **Testaus:** Yksikkötestien luominen ja testauksen suunnittelu.

Tekoälyn käyttö on nopeuttanut kehitystä merkittävästi ja auttanut ylläpitämään korkeaa koodin laatua.

## Osallistuminen (Contributing)

Apu projektin kehittämisessä on tervetullutta! Jos haluat osallistua, voit tehdä sen seuraavilla tavoilla:

1.  **Ilmoita bugeista:** Jos löydät virheen, luo uusi Issue ja kuvaile ongelma mahdollisimman tarkasti.
2.  **Ehdota parannuksia:** Onko sinulla idea uudesta ominaisuudesta tai parannuksesta? Avaa Issue ja kerro siitä.
3.  **Lähetä Pull Request:** Jos olet korjannut bugin tai toteuttanut uuden ominaisuuden, voit lähettää Pull Requestin.

## Lisenssi

Tämä projekti on lisensoitu MIT-lisenssillä. Tämä tarkoittaa, että voit vapaasti käyttää, kopioida, muokata ja jakaa koodia, kunhan alkuperäinen lisenssi ja tekijänoikeusilmoitus säilytetään.
```

================================================================================
FILE: requirements-dev.txt
================================================================================

# Development and Build Dependencies
# These packages are required for developing, testing, or building the application,
# but not for running the compiled executable or the source code directly (if no runtime dependencies exist).
pyinstaller>=5.0
pytest>=7.0
pytest-cov>=3.0
requests>=2.28
types-pyinstaller>=5.0
types-requests>=2.0

# Static Analysis Tools (for future CI steps)
flake8>=6.0
mypy>=1.0

================================================================================
FILE: requirements.txt
================================================================================

# Runtime dependencies for the NetPilot application.
# Development and build dependencies are listed in requirements-dev.txt.
requests>=2.28

================================================================================
FILE: ROADMAP.md
================================================================================

# Projektin Roadmap

Tämä dokumentti kuvaa NetPilot-projektin kehityssuunnitelmaa. Se sisältää sekä jo toteutetut virstanpylväät että tulevaisuuden tavoitteet.

## Toteutetut ominaisuudet

✅ **Jatkuvan integraation (CI) käyttöönotto**
*   **Tila:** Valmis.
*   **Toteutus:** GitHub Actions -työnkulku (`.github/workflows/ci.yml`) on luotu. Se suorittaa automaattisesti `mypy`-tyyppitarkistuksen ja `pytest`-yksikkötestit jokaisen `push`- ja `pull_request`-tapahtuman yhteydessä.

✅ **Asennuspaketin luominen**
*   **Tila:** Valmis.
*   **Toteutus:** `build.py`-skripti tukee Inno Setup -työkalua, jolla luodaan ammattimainen asennusohjelma (`.exe`). Tämä mahdollistaa pikakuvakkeiden luomisen ja sovelluksen helpon poistamisen.

✅ **Resurssien hallinta**
*   **Tila:** Valmis.
*   **Toteutus:** `build.py` lisää tarvittavat resurssit (kuten `icon.ico`) PyInstaller-pakettiin, mikä varmistaa niiden toimivuuden jaettavassa sovelluksessa.

## Tulevaisuuden kehityskohteet

### 1. Testikattavuuden parantaminen
*   **Tila:** Kesken.
*   **Tehtävä:** Kirjoittaa lisää yksikkötestejä erityisesti `logic`- ja `gui`-kerrosten toiminnoille.
*   **Tavoite:** Nostaa testikattavuus (`coverage`) nykyisestä (60 %) yli 80 %:iin.
*   **Miksi:** Varmistaa koodin vakauden, ehkäisee regressioita ja helpottaa uusien ominaisuuksien lisäämistä turvallisesti.

### 2. Koodin refaktorointi ja laadun parantaminen
*   **Tila:** Suunnitteilla.
*   **Tehtävä:** Käydä läpi sovelluksen koodikanta ja soveltaa SOLID-periaatteita. Esimerkiksi `gui/main_window.py`-tiedoston `ActionHandler`-luokka on jo jaettu pienempiin osiin, mutta vastaavia parannuksia voidaan tehdä muuallakin.
*   **Miksi:** Parantaa koodin luettavuutta, ylläpidettävyyttä ja testattavuutta.

### 3. Dokumentaation viimeistely
*   **Tila:** Suunnitteilla.
*   **Tehtävä:** Kirjoittaa kattavampi API-dokumentaatio koodin sisälle (docstringit) ja varmistaa, että `README.md` ja `ARCHITECTURE.md` ovat täysin ajan tasalla.
*   **Miksi:** Helpottaa uusien kehittäjien perehtymistä projektiin ja selkeyttää olemassa olevia toiminnallisuuksia.

### 4. Lokituksen parantaminen
*   **Tila:** Suunnitteilla.
*   **Tehtävä:** Lisätä kontekstitietoa lokiviesteihin, kuten funkti- ja moduulinimiä. Harkita jäsennellyn lokituksen (esim. JSON-formaatti) käyttöönottoa, mikä helpottaisi lokien automaattista analysointia tulevaisuudessa.
*   **Miksi:** Nopeuttaa virheiden diagnosointia ja antaa paremman kuvan sovelluksen toiminnasta ajon aikana.

### 5. Käyttöliittymän modernisointi
*   **Tila:** Suunnitteilla.
*   **Tehtävä:** Tutkia ja ottaa käyttöön modernimpi ulkoasu sovellukselle. Tämä voi sisältää:
    *   `ttkthemes`-kirjaston tai `Sun Valley TTK Theme`:n hyödyntämisen nykyisen Tkinter-käyttöliittymän ulkoasun parantamiseksi.
    *   Käyttöliittymän elementtien ja asettelun uudelleensuunnittelun käyttäjäkokemuksen parantamiseksi.
    *   Pitkällä tähtäimellä siirtymisen harkitsemista toiseen UI-kirjastoon (esim. PyQt/PySide).
*   **Miksi:** Parantaa sovelluksen visuaalista ilmettä ja käytettävyyttä, tehden siitä miellyttävämmän ja intuitiivisemman loppukäyttäjälle.


================================================================================
FILE: setup.iss
================================================================================

; NetPilot Inno Setup Script
; Tämä skripti luo asennusohjelman NetPilot-sovellukselle.

[Setup]
; Perusasetukset sovellukselle
AppName=NetPilot
AppVersion={#AppVersion}
AppPublisher=Sami Turpeinen
AppPublisherURL=https://github.com/atkeppu/NetPilot
AppSupportURL=https://github.com/atkeppu/NetPilot/issues
AppUpdatesURL=https://github.com/atkeppu/NetPilot/releases

; Asennuskansio (oletus %ProgramFiles%\NetPilot)
DefaultDirName={autopf}\NetPilot
DefaultGroupName=NetPilot

; Asennusohjelman ulkoasu ja toiminta
OutputBaseFilename=NetPilot-{#AppVersion}-setup
OutputDir=dist
Compression=lzma2/ultra64
SolidCompression=yes
WizardStyle=modern
SetupIconFile=icon.ico
UninstallDisplayIcon={app}\NetPilot.exe

; Pyydä käyttäjää hyväksymään lisenssi (jos sellainen on)
LicenseFile=LICENSE.md

; Määritellään tuetut kielet asennusohjelmalle
[Languages]
Name: "fi"; MessagesFile: "compiler:Languages\Finnish.isl"
Name: "en"; MessagesFile: "compiler:Default.isl"

; Tehtävät, joita käyttäjä voi valita asennuksen aikana
[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

; Tiedostot, jotka paketoidaan asennusohjelmaan
[Files]
; Pääohjelma
Source: "dist\NetPilot.exe"; DestDir: "{app}"; Flags: ignoreversion
; Ikonitiedosto, jota sovellus voi käyttää
Source: "icon.ico"; DestDir: "{app}"
; Voit lisätä muita tiedostoja, kuten README tai LICENSE
Source: "LICENSE.md"; DestDir: "{app}"; Flags: isreadme

; Pikakuvakkeet, jotka luodaan
[Icons]
; Käynnistä-valikon pikakuvake
Name: "{group}\NetPilot"; Filename: "{app}\NetPilot.exe"
; Työpöydän pikakuvake (jos käyttäjä valitsee tehtävän)
Name: "{autodesktop}\NetPilot"; Filename: "{app}\NetPilot.exe"; Tasks: desktopicon
; Ohjauspaneelin "Poista asennus" -kohdan pikakuvake
Name: "{group}\{cm:UninstallProgram,NetPilot}"; Filename: "{uninstallexe}"

; Toiminnot, jotka suoritetaan asennuksen jälkeen
[Run]
; Tarjoa mahdollisuus käynnistää sovellus asennuksen päätteeksi
Filename: "{app}\NetPilot.exe"; Description: "{cm:LaunchProgram,NetPilot}"; Flags: nowait postinstall skipifsilent

; Määritellään, mitä tiedostoja ja kansioita poistetaan asennuksen poiston yhteydessä
[UninstallDelete]
; Poista sovelluksen luoma asetustiedosto
Type: files; Name: "{app}\config.ini"

; Poista lokikansio, jos se on tyhjä
Type: dirifempty; Name: "{userappdata}\NetPilot\logs"

; Poista sovelluksen juurikansio, jos se on tyhjä
Type: dirifempty; Name: "{userappdata}\NetPilot"


================================================================================
FILE: VERSION
================================================================================

1.4.3

================================================================================
FILE: gui/action_handler.py
================================================================================

import tkinter as tk
from tkinter import messagebox
import threading
import logging
from pathlib import Path
from typing import Callable, TYPE_CHECKING

if TYPE_CHECKING:
    from .app_context import AppContext

import app_logic
from localization import get_string
from exceptions import NetworkManagerError

# Import window classes to avoid circular imports
from .netstat_window import NetstatWindow
from .traceroute_window import TracerouteWindow
from publish_dialog import PublishDialog
from .wifi_window import WifiConnectWindow

logger = logging.getLogger(__name__)

class BaseActionHandler:
    """Base class for action handlers providing common functionality."""
    def __init__(self, context: 'AppContext', get_selected_adapter_name_func: Callable[[], str | None]):
        self.context = context
        self.get_selected_adapter_name_func = get_selected_adapter_name_func
        self.app_logic = app_logic

    def run_background_task(self, task_func, *args, on_complete: Callable | None = None, on_error: Callable | None = None):
        """A generic wrapper to run a function in a background thread."""
        task_name = task_func.__name__
        logger.info("Starting background task: %s", task_name)

        def worker():
            try:
                result = task_func(*args)
                if on_complete:
                    # Pass result to the on_complete callback if it's not None
                    self.context.task_queue.put({'type': 'ui_update', 'func': lambda: on_complete(result)})
                logger.info("Background task '%s' completed successfully.", task_name)
            except NetworkManagerError as e:
                logger.error("A known error occurred in task '%s': %s", task_name, e, exc_info=True)
                self.context.task_queue.put({'type': 'generic_error', 'description': f"running task {task_name}", 'error': e})
                # Still call on_complete in case of a handled error to allow UI cleanup (e.g., re-enabling buttons)
                if on_complete:
                    self.context.task_queue.put({'type': 'ui_update', 'func': on_complete})
                if on_error:
                    self.context.task_queue.put({'type': 'ui_update', 'func': lambda: on_error(e)})
            except Exception as e:
                logger.critical("An unhandled error occurred in background task '%s'.", task_name, exc_info=True)
                self.context.task_queue.put({'type': 'unhandled_error', 'error': e})

        thread = threading.Thread(target=worker, daemon=True)
        thread.start()

class NetworkActionsHandler(BaseActionHandler):
    """Handles core network-related actions."""
    def __init__(self, context: 'AppContext', get_selected_adapter_name_func: Callable[[], str | None]):
        super().__init__(context, get_selected_adapter_name_func)

    def toggle_adapter(self, action: str):
        adapter_name = self.get_selected_adapter_name_func()
        if not adapter_name:
            messagebox.showwarning(get_string('netstat_selection_required'), get_string('wifi_select_to_connect'))
            return

        is_enable = action == 'enable'
        
        title_key = 'toggle_confirm_enable_title' if is_enable else 'toggle_confirm_disable_title'
        prompt_key = 'toggle_confirm_enable_prompt' if is_enable else 'toggle_confirm_disable_prompt'
        status_key = 'status_enable_attempt' if is_enable else 'status_disable_attempt'

        title = get_string(title_key)
        prompt = get_string(prompt_key, adapter_name=adapter_name)

        if messagebox.askyesno(title, prompt):
            self.context.root.status_var.set(get_string(status_key, adapter_name=adapter_name))
            self.run_background_task(self._execute_toggle_in_thread, adapter_name, action)
        else:
            self.context.root.status_var.set(get_string('status_op_cancelled'))

    def _execute_toggle_in_thread(self, adapter_name, action):
        app_logic.set_network_adapter_status_windows(adapter_name, action)
        self.context.task_queue.put({'type': 'toggle_success', 'adapter_name': adapter_name, 'action': action})

    def confirm_reset_network_stack(self):
        if messagebox.askyesno(get_string('menu_reset_stack'), "This will reset your network configuration and require a reboot. Are you sure?"):
            self.context.root.status_var.set(get_string('status_reset_attempt'))
            self.run_background_task(self._execute_reset_in_thread)
        else:
            self.context.root.status_var.set(get_string('status_op_cancelled'))

    def _execute_reset_in_thread(self):
        app_logic.reset_network_stack()
        self.context.task_queue.put({'type': 'reset_stack_success'})

    def flush_dns(self):
        self.run_background_task(self._execute_flush_dns_in_thread)

    def _execute_flush_dns_in_thread(self):
        app_logic.flush_dns_cache()
        self.context.task_queue.put({'type': 'flush_dns_success'})

    def renew_ip(self):
        self.run_background_task(self._execute_release_renew_in_thread)

    def _execute_release_renew_in_thread(self):
        app_logic.release_renew_ip()
        self.context.task_queue.put({'type': 'release_renew_success'})

    def disconnect_current_wifi(self):
        if messagebox.askyesno("Confirm Disconnect", "Are you sure you want to disconnect from the current Wi-Fi network?"):
            self.run_background_task(self._execute_disconnect_wifi_in_thread)

    def _execute_disconnect_wifi_in_thread(self):
        app_logic.disconnect_wifi()
        self.context.task_queue.put({'type': 'disconnect_wifi_success'})

    def execute_disconnect_and_disable(self, adapter_name):
        self.run_background_task(self._execute_disconnect_and_disable_in_thread, adapter_name)

    def _execute_disconnect_and_disable_in_thread(self, adapter_name):
        for status_update in app_logic.disconnect_wifi_and_disable_adapter(adapter_name):
            self.context.task_queue.put({'type': 'status_update', 'text': status_update})

class DiagnosticsActionsHandler(BaseActionHandler):
    """Handles actions related to diagnostics and data fetching."""
    def __init__(self, context: 'AppContext', get_selected_adapter_name_func: Callable[[], str | None]):
        super().__init__(context, get_selected_adapter_name_func)

    def fetch_active_connections(self, on_complete: Callable | None = None):
        """Fetches active network connections in the background."""
        self.run_background_task(self._execute_fetch_connections_in_thread, on_complete=on_complete)

    def _execute_fetch_connections_in_thread(self):
        data = app_logic.get_active_connections()
        self.context.task_queue.put({'type': 'ui_update', 'func': lambda: self.context.queue_handler.handle_netstat_update(data)})

    def run_traceroute(self, target: str, on_complete: Callable | None = None):
        """Runs traceroute in the background, streaming results."""
        self.run_background_task(self._execute_trace_in_thread, target, on_complete=on_complete)

    def _execute_trace_in_thread(self, target: str):
        for line in app_logic.run_traceroute(target):
            self.context.task_queue.put({'type': 'ui_update', 'func': lambda l=line: self.context.queue_handler.handle_traceroute_update(l)})

    def fetch_wifi_networks(self, on_complete: Callable | None = None):
        """Fetches available Wi-Fi networks in the background."""
        self.run_background_task(self._execute_fetch_wifi_in_thread, on_complete=on_complete)

    def _execute_fetch_wifi_in_thread(self):
        data = app_logic.list_wifi_networks()
        current_ssid = (app_logic.get_current_wifi_details() or {}).get('ssid')
        self.context.task_queue.put({'type': 'wifi_list_success', 'data': data, 'current_ssid': current_ssid})

class UIWindowsHandler(BaseActionHandler):
    """Handles opening and managing UI windows."""
    def __init__(self, context: 'AppContext', get_selected_adapter_name_func: Callable[[], str | None]):
        super().__init__(context, get_selected_adapter_name_func)

    def open_netstat_window(self):
        NetstatWindow(self.context)

    def open_traceroute_window(self):
        TracerouteWindow(self.context)

    def open_wifi_window(self):
        WifiConnectWindow(self.context)

    def open_publish_dialog(self):
        """Opens the publish dialog."""
        self.context.status_var.set(get_string('publish_checking_auth'))
        is_ok, message = self.app_logic.check_github_cli_auth()
        if is_ok:
            self.context.status_var.set(get_string('publish_ready'))
            PublishDialog(self.context)
        else:
            logger.error("GitHub CLI auth check failed: %s", message)
            self.context.status_var.set(get_string('publish_auth_failed'))
            messagebox.showerror(get_string('publish_auth_failed_title'), message)

class GitHubActionsHandler(BaseActionHandler):
    """Handles actions related to GitHub integration."""
    def __init__(self, context: 'AppContext', get_selected_adapter_name_func: Callable[[], str | None]):
        super().__init__(context, get_selected_adapter_name_func)

    def publish_release(self, repo: str, tag: str, title: str, notes: str, on_complete: Callable | None = None, on_error: Callable | None = None):
        """
        Validates assets and starts the background task for creating a GitHub release.
        
        Args:
            repo: The repository name (e.g., 'owner/repo').
            tag: The git tag for the release (e.g., 'v1.3.1').
            title: The title of the release.
            notes: The release notes content.
            on_complete: An optional callback to run on the UI thread after successful completion.
            on_error: An optional callback to run on the UI thread if an error occurs.
        """
        # Find the assets to upload. The build script places them in the 'dist' folder.
        version = tag.lstrip('v')
        dist_path = app_logic.get_dist_path()

        # Find assets dynamically instead of constructing an expected filename.
        # This is more robust if the version is changed in the dialog.
        installer_path = next(dist_path.glob('*-setup.exe'), None)
        exe_path = dist_path / "NetPilot.exe"

        assets_to_upload = []
        # Prioritize the installer. If it exists, upload only that.
        # Otherwise, fall back to uploading the standalone executable.
        if installer_path and installer_path.is_file():
            assets_to_upload.append(str(installer_path))
        elif exe_path.is_file():
            assets_to_upload.append(str(exe_path))

        if not assets_to_upload:
            # Provide a more generic error message since we don't know the exact expected name anymore.
            messagebox.showerror("Asset Not Found", f"Could not find a release file (installer or .exe) to upload in the 'dist' directory.\n\nPlease run the build script first.")
            return

        self.run_background_task(self._execute_publish_in_thread, repo, tag, title, notes, assets_to_upload, on_complete=on_complete, on_error=on_error)

    def _execute_publish_in_thread(self, repo: str, tag: str, title: str, notes: str, asset_paths: list[str] | None = None):
        release_url = app_logic.create_github_release(tag, title, notes, repo, asset_paths)
        
        # After a successful release, update the local VERSION file with the new tag.
        try:
            from logger_setup import get_project_or_exe_root
            version_path = get_project_or_exe_root() / "VERSION"
            new_version = tag.lstrip('v')
            version_path.write_text(new_version, encoding="utf-8")
            logger.info("Successfully updated VERSION file to %s after release.", new_version)
        except (IOError, FileNotFoundError) as e:
            logger.error("Failed to update VERSION file after release: %s", e)
            
        self.context.task_queue.put({'type': 'publish_success', 'url': release_url, 'tag': tag})

    def generate_changelog_and_update_dialog(self, version: str, update_callback: Callable[[str], None]):
        """
        Runs the changelog generation in a background thread and uses a callback
        to update the publish dialog's text widget upon completion.
        """
        self.run_background_task(self._execute_generate_changelog_in_thread, version, update_callback)

    def _execute_generate_changelog_in_thread(self, version: str, update_callback: Callable[[str], None]):
        """
        Worker function that calls the changelog generation logic and then
        schedules the UI update via the queue.
        """
        # This reuses the logic from the build script.
        # Note: This creates a dependency on a function inside build.py.
        from build import generate_changelog
        generate_changelog(version)
        changelog_content = (Path.cwd() / "CHANGELOG.md").read_text(encoding='utf-8')
        self.context.task_queue.put({'type': 'ui_update', 'func': lambda: update_callback(changelog_content)})

class ActionHandler:
    """
    Main facade for all UI actions. It instantiates and delegates to specialized
    sub-handlers for better organization.
    """
    def __init__(self, context, get_selected_adapter_name_func: Callable[[], str | None]):
        self.network = NetworkActionsHandler(context, get_selected_adapter_name_func)
        self.diagnostics = DiagnosticsActionsHandler(context, get_selected_adapter_name_func)
        self.windows = UIWindowsHandler(context, get_selected_adapter_name_func)
        self.github = GitHubActionsHandler(context, get_selected_adapter_name_func)

        # For convenience, expose the generic run_background_task at the top level
        self.run_background_task = self.network.run_background_task

    # Expose methods from sub-handlers for direct access, e.g., self.action_handler.toggle_adapter()
    def __getattr__(self, name):
        if hasattr(self.network, name): return getattr(self.network, name)
        if hasattr(self.diagnostics, name): return getattr(self.diagnostics, name)
        if hasattr(self.windows, name): return getattr(self.windows, name)
        if hasattr(self.github, name): return getattr(self.github, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

================================================================================
FILE: gui/adapter_details_frame.py
================================================================================

import tkinter as tk
from tkinter import ttk
from localization import get_string

from .utils import format_speed


class AdapterDetailsFrame(ttk.LabelFrame):
    """
    A frame that displays the details of a selected network adapter and provides
    action buttons (Connect/Disconnect).
    """

    def __init__(self, parent, on_connect_callback, on_disconnect_callback, on_status_update_callback, **kwargs):
        super().__init__(parent, text=get_string('adapter_details_title'), **kwargs)
        self.on_connect_callback = on_connect_callback
        self.on_disconnect_callback = on_disconnect_callback
        self.on_status_update_callback = on_status_update_callback

        # Data-driven structure for UI elements.
        # Each tuple contains: (Display Label, Data Key, Optional Formatter Function)
        self.detail_map = [ # The first element is now a localization key
            ('details_description', 'InterfaceDescription'),
            ('details_mac', 'MacAddress'),
            ('details_ipv4', 'IPv4Address'),
            ('details_ipv6', 'IPv6Address'),
            ('details_link_speed', 'LinkSpeed', lambda speed: f"{int(speed) / 1_000_000:.0f} Mbps" if isinstance(speed, (int, float)) else (speed or "0")),
            ('details_download_speed', 'download_speed', format_speed), # Special key for polled data
            ('details_upload_speed', 'upload_speed', format_speed),     # Special key for polled data
            ('details_driver_version', 'DriverVersion'),
            ('details_driver_date', 'DriverDate'),
        ]

        self.details_labels = {}
        self.clicked_widget = None
        self._create_context_menu()
        self._create_widgets()

    def _create_widgets(self):
        # Build labels dynamically from the detail_map
        for i, (label_key, *_) in enumerate(self.detail_map): # Use * to unpack remaining elements
            display_label = get_string(label_key)
            ttk.Label(self, text=f"{display_label}:").grid(row=i, column=0, sticky=tk.W, padx=5, pady=2)
            value_label = ttk.Label(self, text="-", anchor=tk.W)
            value_label.bind("<Button-3>", self._show_context_menu) # Bind right-click
            value_label.grid(row=i, column=1, sticky=tk.W, padx=5, pady=2)
            self.details_labels[label_key] = value_label

        action_button_frame = ttk.Frame(self)
        action_button_frame.grid(row=len(self.detail_map), column=0, columnspan=2, pady=5)
        self.connect_button = ttk.Button(action_button_frame, text=get_string('button_connect'), command=self.on_connect_callback, state=tk.DISABLED)
        self.connect_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=5)
        self.disconnect_button = ttk.Button(action_button_frame, text=get_string('button_disconnect'), command=self.on_disconnect_callback, state=tk.DISABLED)
        self.disconnect_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=5)

    def _create_context_menu(self):
        """Creates the right-click context menu for copying text."""
        self.context_menu = tk.Menu(self, tearoff=0)
        self.context_menu.add_command(label=get_string('context_menu_copy'), command=self._copy_to_clipboard)

    def _show_context_menu(self, event):
        """Displays the context menu at the cursor's position."""
        self.clicked_widget = event.widget
        self.context_menu.post(event.x_root, event.y_root)

    def _copy_to_clipboard(self):
        """Copies the text from the right-clicked label to the clipboard."""
        if self.clicked_widget:
            text_to_copy = self.clicked_widget.cget("text")
            if text_to_copy and text_to_copy != "-":
                self.clipboard_clear()
                self.clipboard_append(text_to_copy)
                self.on_status_update_callback(get_string('status_copied_to_clipboard', text=text_to_copy))

    def update_details(self, adapter):
        """Populates the detail labels with data from an adapter dictionary."""
        for detail_config in self.detail_map:
            label_key, data_key, formatter = (detail_config + (None,))[:3] # Unpack with default for formatter
            
            # Skip polled speed fields in this initial update
            if data_key in ['download_speed', 'upload_speed']: continue
            
            raw_value = adapter.get(data_key)
            display_value = formatter(raw_value) if formatter and raw_value is not None else (raw_value or '-')
            if label_key in self.details_labels:
                self.details_labels[label_key].config(text=display_value)

        # Reset speeds, they are updated by the poller
        self.update_speeds(0, 0)

    def update_button_states(self, admin_state: str | None):
        """Updates the Connect/Disconnect button states based on adapter status."""
        if admin_state == 'Disabled':
            self.connect_button.config(state=tk.NORMAL)
            self.disconnect_button.config(state=tk.DISABLED)
        elif admin_state == 'Enabled':
            self.connect_button.config(state=tk.DISABLED)
            self.disconnect_button.config(state=tk.NORMAL)
        else:
            self.connect_button.config(state=tk.DISABLED)
            self.disconnect_button.config(state=tk.DISABLED)

    def update_speeds(self, download_bps: float, upload_bps: float):
        """Formats and updates only the speed-related labels."""
        self.details_labels["details_download_speed"].config(text=format_speed(download_bps) if download_bps is not None else '-')
        self.details_labels["details_upload_speed"].config(text=format_speed(upload_bps) if upload_bps is not None else '-')

    def clear(self):
        """Resets all detail labels and buttons to their default state."""
        for label in self.details_labels.values():
            label.config(text="-")
        self.update_button_states(None)

================================================================================
FILE: gui/adapter_list_frame.py
================================================================================

import tkinter as tk
from tkinter import ttk

from localization import get_string


class AdapterListFrame(ttk.LabelFrame):
    """
    A frame that contains the list of network adapters and its associated scrollbar.
    It handles displaying the list and notifying the parent of a selection via a callback.
    """

    def __init__(self, parent, on_select_callback, **kwargs):
        super().__init__(parent, text=get_string('available_adapters_title'), **kwargs)
        self.on_select_callback = on_select_callback

        self.adapter_listbox = tk.Listbox(self, height=10)
        self.adapter_listbox.bind('<<ListboxSelect>>', self._on_select)
        self.adapter_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)

        scrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.adapter_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.adapter_listbox.config(yscrollcommand=scrollbar.set)

    def _on_select(self, event):
        """Internal handler to process selection and call the parent's callback."""
        selected_indices = self.adapter_listbox.curselection()
        if selected_indices:
            # Pass the selected index to the parent controller
            self.on_select_callback(selected_indices[0])

    def populate(self, adapters_data):
        """Clears and populates the listbox with adapter data."""
        self.adapter_listbox.delete(0, tk.END)
        if not adapters_data:
            self.adapter_listbox.insert(tk.END, get_string('no_adapters_found'))
        else:
            for adapter in adapters_data:
                display_text = f"{adapter.get('Name', 'N/A')} ({adapter.get('admin_state', 'N/A')})"
                self.adapter_listbox.insert(tk.END, display_text)

================================================================================
FILE: gui/app_context.py
================================================================================

import queue
import logging
import tkinter as tk

from .action_handler import ActionHandler
from .queue_handler import QueueHandler
from .polling_manager import PollingManager
from .main_controller import MainController
from .constants import APP_VERSION

logger = logging.getLogger(__name__)

class AppContext:
    """
    Acts as the central 'brain' of the application, holding shared state and
    orchestrating the main components (handlers, controllers).
    This non-GUI class decouples the application logic from the main window.
    """
    def __init__(self):
        self.task_queue = queue.Queue()
        self.status_var = None # Will be initialized later
        self.open_windows = {} # Tracks open Toplevel windows

        # Initialize core logic components immediately. They don't have a hard
        # dependency on the UI being fully rendered, only on the context itself.
        self.main_controller = MainController(task_queue=self.task_queue)
        self.action_handler = ActionHandler(
            context=self,
            get_selected_adapter_name_func=self.main_controller.get_selected_adapter_name
        )

        # These components have stronger dependencies on the UI and will be initialized later.
        self.queue_handler = None
        self.polling_manager = None
        self.root = None # The main tk.Tk() window
        self.diagnostics_frame = None # Will hold reference to the diagnostics UI frame

    def initialize_components(self, root, ui_frames: dict, status_var: tk.StringVar):
        """
        Initializes all the handler and controller components that depend on UI elements.
        """
        self.root = root
        self.status_var = status_var
        self.diagnostics_frame = ui_frames['diagnostics']

        self.queue_handler = QueueHandler(
            context=self,
            ui_frames=ui_frames
        )
        self.polling_manager = PollingManager(self)

        logger.info("Application context and all components initialized.")

    def get_ping_target(self) -> str:
        """Provides the current ping target from the UI to other components."""
        return self.diagnostics_frame.get_ping_target() if self.diagnostics_frame else "8.8.8.8"

    def get_app_version(self) -> str:
        """Returns the application's version string."""
        return APP_VERSION

    def register_window(self, window_instance):
        """Registers an open Toplevel window instance."""
        window_key = window_instance.__class__.__name__
        self.open_windows[window_key] = window_instance
        logger.info("Window registered: %s", window_key)

    def unregister_window(self, window_instance):
        """Unregisters a Toplevel window instance when it's closed."""
        window_key = window_instance.__class__.__name__
        if window_key in self.open_windows:
            del self.open_windows[window_key]
            logger.info("Window unregistered: %s", window_key)

================================================================================
FILE: gui/available_networks_tab.py
================================================================================

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog

from app_logic import list_wifi_networks, get_current_wifi_details, connect_to_wifi_network
from localization import get_string

class AvailableNetworksTab(ttk.Frame):
    """
    UI and logic for the 'Available Networks' tab in the Wi-Fi window.
    """
    def __init__(self, parent_notebook, window, task_queue, status_label):
        super().__init__(parent_notebook)
        self.window = window
        self.task_queue = task_queue
        self.status_label = status_label
        self.wifi_data = []

        self._create_widgets()

    def _create_widgets(self):
        tree_frame = ttk.Frame(self)
        tree_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        columns = ('ssid', 'signal', 'auth', 'encryption')
        self.tree = ttk.Treeview(tree_frame, columns=columns, show='headings')
        self.tree.heading('ssid', text=get_string('wifi_col_ssid'), command=lambda: self._sort_by_column('ssid', False))
        self.tree.heading('signal', text=get_string('wifi_col_signal'), command=lambda: self._sort_by_column('signal', True))
        self.tree.heading('auth', text=get_string('wifi_col_auth'), command=lambda: self._sort_by_column('auth', False))
        self.tree.heading('encryption', text=get_string('wifi_col_encrypt'), command=lambda: self._sort_by_column('encryption', False))
        self.tree.column('ssid', width=200); self.tree.column('signal', width=80, anchor=tk.CENTER)
        self.tree.column('auth', width=150); self.tree.column('encryption', width=100)
        self.tree.bind('<<TreeviewSelect>>', self._on_network_select)
        self.tree.bind('<Double-1>', lambda e: self.connect_to_network())
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.tree.configure(yscrollcommand=scrollbar.set)

        self.connect_frame = ttk.LabelFrame(self, text=get_string('wifi_button_connect'))
        ttk.Label(self.connect_frame, text=f"{get_string('wifi_col_password')}:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        self.password_var = tk.StringVar()
        self.password_entry = ttk.Entry(self.connect_frame, textvariable=self.password_var, show="*")
        self.password_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.EW)
        self.connect_frame.grid_columnconfigure(1, weight=1)

        action_frame = ttk.Frame(self)
        action_frame.pack(fill=tk.X)
        self.connect_button = ttk.Button(action_frame, text=get_string('wifi_button_connect'), command=self.connect_to_network, state=tk.DISABLED)
        self.disconnect_button = ttk.Button(action_frame, text=get_string('wifi_button_disconnect'), command=self.window.disconnect_from_wifi)
        self.refresh_button = ttk.Button(action_frame, text=get_string('wifi_button_refresh'), command=self.refresh_list)
        self.disconnect_button.pack(side=tk.RIGHT, padx=(5, 0)); self.connect_button.pack(side=tk.RIGHT, padx=(5, 0)); self.refresh_button.pack(side=tk.RIGHT)
        self.connect_frame.pack_forget()

    def refresh_list(self):
        self.status_label.config(text=get_string('status_refreshing_list'))
        self.set_button_state('refresh', tk.DISABLED)
        self.set_button_state('connect', tk.DISABLED)
        self.window.context.action_handler.diagnostics.fetch_wifi_networks(on_complete=self._on_refresh_complete)

    def _on_refresh_complete(self):
        self.set_button_state('refresh', tk.NORMAL)

    def populate_list(self, wifi_data, current_ssid):
        self.wifi_data = wifi_data
        self.tree.delete(*self.tree.get_children())
        if not self.wifi_data:
            self.tree.insert('', tk.END, values=(get_string('wifi_no_networks_found'), "", "", ""))
            self.tree.config(selectmode="none")
        else:
            self.tree.config(selectmode="browse")
            for i, network in enumerate(self.wifi_data):
                ssid = network.get('ssid', 'N/A')
                display_ssid = ssid + " (Connected)" if ssid and ssid == current_ssid else ssid
                self.tree.insert('', tk.END, iid=i, values=(display_ssid, f"{network.get('signal', 'N/A')}%", network.get('authentication', 'N/A'), network.get('encryption', 'N/A')))

    def _on_network_select(self, event):
        selected_item = self.tree.focus()
        if not selected_item: return
        network = self.wifi_data[int(selected_item)]
        self.status_label.config(text=f"Selected: {network['ssid']}")
        self.set_button_state('connect', tk.NORMAL)
        if network.get('authentication', '').lower() != 'open':
            self.connect_frame.pack(fill=tk.X, pady=5); self.password_entry.focus()
        else:
            self.connect_frame.pack_forget()

    def connect_to_network(self):
        selected_item = self.tree.focus()
        if not selected_item:
            messagebox.showwarning(get_string('netstat_selection_required'), get_string('wifi_select_to_connect'), parent=self.window)
            return
        network = self.wifi_data[int(selected_item)]
        ssid = network['ssid']
        authentication = network.get('authentication', 'N/A')
        encryption = network.get('encryption', 'N/A')
        
        password = None
        if network.get('authentication', '').lower() != 'open':
            password = self.password_var.get()
            if not password: # If password field is empty, but required, prompt the user.
                password = simpledialog.askstring(get_string('wifi_password_prompt_title'), get_string('wifi_password_prompt_msg', ssid=ssid), parent=self.window, show='*')
                if not password: return # User cancelled
        self.status_label.config(text=get_string('wifi_connect_status', ssid=ssid))
        self.set_button_state('connect', tk.DISABLED, get_string('wifi_connect_status', ssid='...'))
        self.set_button_state('refresh', tk.DISABLED)
        self.window._run_background_task(
            lambda: self._execute_connect_in_thread(ssid, authentication, encryption, password),
            on_complete=self.reset_connect_button
        )

    def _execute_connect_in_thread(self, ssid, auth, enc, pwd):
        """Worker function for connection."""
        connect_to_wifi_network(ssid, auth, enc, pwd)
        self.task_queue.put({'type': 'wifi_connect_success', 'ssid': ssid})

    def set_button_state(self, button_name, state, text=None):
        button = getattr(self, f"{button_name}_button", None)
        if button:
            button.config(state=state)
            if text: button.config(text=text)

    def reset_connect_button(self):
        self.set_button_state('connect', tk.NORMAL, get_string('wifi_button_connect'))
        self.set_button_state('refresh', tk.NORMAL)

    def _sort_by_column(self, col, reverse):
        data = [(self.tree.set(child, col), child) for child in self.tree.get_children('')]
        def sort_key(item):
            try: return int(item[0].replace('%', ''))
            except (ValueError, AttributeError): return -1
        data.sort(key=sort_key if col == 'signal' else None, reverse=reverse)
        for index, (val, child) in enumerate(data):
            self.tree.move(child, '', index)
        self.tree.heading(col, command=lambda: self._sort_by_column(col, not reverse))

================================================================================
FILE: gui/base_window.py
================================================================================

import tkinter as tk
import threading
from typing import Callable
import logging
from abc import ABC

from exceptions import NetworkManagerError

QUEUE_POLL_INTERVAL_MS = 100

class BaseTaskWindow(tk.Toplevel, ABC):
    """
    An abstract base class for Toplevel windows that run background tasks.

    It encapsulates the common logic for using a queue to communicate between
    a background worker thread and the Tkinter UI thread, ensuring the UI
    remains responsive.
    """
    def __init__(self, context, title: str, geometry: str):
        super().__init__(context.root)
        self.context = context
        self.task_queue = context.task_queue # Use the main application queue
        self.logger = logging.getLogger(self.__class__.__name__)

        self.title(title)
        self.geometry(geometry)
        self.transient(context.root)
        self.grab_set()

        # Register the window with the context and handle its closing
        self.context.register_window(self)
        self.protocol("WM_DELETE_WINDOW", self.destroy)

    def destroy(self):
        """Overrides the default destroy to unregister the window first."""
        self.logger.info("Destroying and unregistering window.")
        self.context.unregister_window(self)
        super().destroy()

================================================================================
FILE: gui/conftest.py
================================================================================

import pytest
import tkinter as tk

@pytest.fixture(scope="session")
def tk_root():
    """
    Provides a single, shared, hidden Tkinter root window for the entire
    test session.

    This avoids creating a new root window for every test that needs one,
    which is slow and can cause issues in some environments. It also prevents
    TclErrors in CI/CD pipelines by keeping the window withdrawn.
    """
    root = tk.Tk()
    root.withdraw()  # Hide the window
    yield root
    root.destroy()

================================================================================
FILE: gui/constants.py
================================================================================

from pathlib import Path

def _read_version():
    """Reads the version from the VERSION file."""
    try:
        # Assuming the VERSION file is in the project root, one level up from 'gui'
        version_path = Path(__file__).parent.parent / "VERSION"
        return version_path.read_text(encoding="utf-8").strip()
    except FileNotFoundError:
        return "0.0.0-dev"

APP_NAME = "NetPilot"
APP_VERSION = _read_version()
APP_AUTHOR = "Sami Turpeinen"

================================================================================
FILE: gui/diagnostics_frame.py
================================================================================

import tkinter as tk
from tkinter import ttk

from localization import get_string

DEFAULT_PING_TARGET = "8.8.8.8"

class DiagnosticsFrame(ttk.LabelFrame):
    """
    A frame that displays network diagnostic information like public IP,
    gateway latency, and allows setting a custom ping target.
    """

    def __init__(self, parent, **kwargs):
        super().__init__(parent, text=get_string('diagnostics_title'), **kwargs)

        # Data-driven structure for UI elements.
        # Each tuple contains: (Localization Key, API Key from PowerShell)
        self.diag_map = [
            ('diag_public_ip', "Public IP"),
            ('diag_gateway', "Gateway"),
            ('diag_gateway_latency', "Gateway Latency"),
            ('diag_external_latency', "External Latency"),
            ('diag_dns_servers', "DNS Servers"),
        ]

        self.diag_labels = {}
        self.ping_target_var = tk.StringVar(value=DEFAULT_PING_TARGET)
        self._create_widgets()

    def _create_widgets(self):
        # Build labels dynamically from the diag_map
        for i, (label_key, _) in enumerate(self.diag_map):
            display_text = get_string(label_key)
            ttk.Label(self, text=f"{display_text}:").grid(row=i, column=0, sticky=tk.W, padx=5, pady=2)
            value_label = ttk.Label(self, text=get_string('status_fetching'), anchor=tk.W)
            value_label.grid(row=i, column=1, sticky=tk.W, padx=5, pady=2)
            self.diag_labels[label_key] = value_label

        ttk.Label(self, text=f"{get_string('diag_ping_target')}:").grid(row=len(self.diag_map), column=0, sticky=tk.W, padx=5, pady=2)
        ping_target_entry = ttk.Entry(self, textvariable=self.ping_target_var)
        ping_target_entry.grid(row=len(self.diag_map), column=1, sticky=tk.EW, padx=5, pady=2)

        self.grid_columnconfigure(1, weight=1)

    def update_diagnostics(self, data: dict):
        """Updates the diagnostic labels with new data."""
        for label_key, api_key in self.diag_map:
            value = data.get(api_key, "N/A")
            self.diag_labels[label_key].config(text=value)

    def get_ping_target(self) -> str:
        """Returns the current value of the ping target entry."""
        return self.ping_target_var.get() or DEFAULT_PING_TARGET

================================================================================
FILE: gui/dialogs.py
================================================================================

import tkinter as tk
from tkinter import ttk, messagebox
import logging

from localization import get_string
import app_logic
from .constants import APP_VERSION
from .utils import create_tooltip

logger = logging.getLogger(__name__)

class PublishWindow(tk.Toplevel):
    """
    A dialog window for creating a new GitHub release.
    """
    def __init__(self, context, initial_repo: str = ""):
        super().__init__(context.root)
        self.context = context
        self.action_handler = context.action_handler
        self.parent = self.context.root

        self.title(get_string('publish_title'))
        self.geometry("500x450")
        self.resizable(False, False)

        self.transient(self.parent) # Keep this window on top of the main app
        self._build_ui()
        self._populate_defaults(initial_repo)

        # Center the window relative to the parent
        self.update_idletasks()
        x = self.parent.winfo_x() + (self.parent.winfo_width() // 2) - (self.winfo_width() // 2)
        y = self.parent.winfo_y() + (self.parent.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")

        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self.grab_set() # Modal behavior

    def _build_ui(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Repository ---
        repo_label = ttk.Label(main_frame, text=get_string('publish_repo'))
        repo_label.grid(row=0, column=0, sticky="w", pady=(0, 2))
        self.repo_var = tk.StringVar()
        self.repo_entry = ttk.Entry(main_frame, textvariable=self.repo_var)
        self.repo_entry.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(0, 10))

        # --- Version / Tag ---
        version_label = ttk.Label(main_frame, text=get_string('publish_version'))
        version_label.grid(row=2, column=0, sticky="w", pady=(0, 2))
        self.version_var = tk.StringVar()
        self.version_entry = ttk.Entry(main_frame, textvariable=self.version_var)
        self.version_entry.grid(row=3, column=0, sticky="ew", pady=(0, 10))
        create_tooltip(self.version_entry, get_string('publish_version_tooltip'))

        # --- Release Title ---
        title_label = ttk.Label(main_frame, text=get_string('publish_release_title'))
        title_label.grid(row=4, column=0, sticky="w", pady=(0, 2))
        self.title_var = tk.StringVar()
        self.title_entry = ttk.Entry(main_frame, textvariable=self.title_var)
        self.title_entry.grid(row=5, column=0, columnspan=2, sticky="ew", pady=(0, 10))

        # --- Release Notes ---
        notes_label = ttk.Label(main_frame, text=get_string('publish_notes'))
        notes_label.grid(row=6, column=0, sticky="w", pady=(0, 2))
        self.notes_text = tk.Text(main_frame, height=8, wrap=tk.WORD, relief=tk.SOLID, borderwidth=1)
        self.notes_text.grid(row=7, column=0, columnspan=2, sticky="nsew", pady=(0, 10))
        
        notes_hint_label = ttk.Label(main_frame, text="Leave empty to auto-generate from commits.", style="secondary.TLabel")
        notes_hint_label.grid(row=8, column=0, columnspan=2, sticky="w", pady=(0, 10))
        main_frame.master.option_add("*TCombobox*Listbox*Font", self.notes_text.cget("font"))

        # --- Buttons ---
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=8, column=0, columnspan=2, sticky="e", pady=(10, 0))

        self.publish_button = ttk.Button(button_frame, text=get_string('publish_button'), command=self._on_publish)
        self.publish_button.pack(side=tk.RIGHT, padx=(5, 0))
        self.cancel_button = ttk.Button(button_frame, text=get_string('publish_cancel'), command=self._on_close)
        self.cancel_button.pack(side=tk.RIGHT)

        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(7, weight=1) # Give weight to the Text widget

    def _populate_defaults(self, initial_repo: str):
        """Fetches and sets default values for the form fields."""
        # Set default version and title
        self.version_var.set(f"v{APP_VERSION}")
        self.title_var.set(f"Release v{APP_VERSION}")

        if initial_repo:
            self.repo_var.set(initial_repo)
            logger.info("Pre-filled repository: %s", initial_repo)
        else:
            logger.warning("Could not detect repository from git config. User must enter it manually.")

    def _on_publish(self):
        """Callback for the 'Publish' button."""
        repo = self.repo_var.get().strip()
        tag = self.version_var.get().strip()
        title = self.title_var.get().strip()
        notes = self.notes_text.get("1.0", tk.END).strip()

        if not all([repo, tag, title]):
            messagebox.showwarning(get_string('publish_missing_info'), get_string('publish_missing_info_msg'), parent=self)
            return

        # Delegate the actual publishing logic to the action handler
        self.action_handler.publish_release(repo, tag, title, notes)
        self._on_close()

    def _on_close(self):
        self.grab_release()
        self.destroy()

================================================================================
FILE: gui/Get-ActiveConnections.ps1
================================================================================

# Get process names for PID lookup
$procs = @{}
Get-CimInstance Win32_Process | ForEach-Object { $procs[$_.ProcessId] = $_.Name }
$procs[0] = 'System Idle'
$procs[4] = 'System'

# Get TCP connections
$tcp = Get-NetTCPConnection | Select-Object @{N='Proto';E={'TCP'}},
                               @{N='Local';E={-join($_.LocalAddress,':',$_.LocalPort)}},
                               @{N='Foreign';E={-join($_.RemoteAddress,':',$_.RemotePort)}},
                               State,
                               @{N='PID';E={$_.OwningProcess}},
                               @{N='ProcessName';E={$procs[$_.OwningProcess]}}

# Get UDP endpoints
$udp = Get-NetUDPEndpoint | Select-Object @{N='Proto';E={'UDP'}},
                               @{N='Local';E={-join($_.LocalAddress,':',$_.LocalPort)}},
                               @{N='Foreign';E={'*:*'}},
                               @{N='State';E={'N/A'}},
                               @{N='PID';E={$_.OwningProcess}},
                               @{N='ProcessName';E={$procs[$_.OwningProcess]}}

# Combine and filter out connections without a PID (e.g., system-level)
($tcp + $udp) | Where-Object { $_.PID -ne $null } | ConvertTo-Json -Compress

================================================================================
FILE: gui/Get-NetworkDiagnostics.ps1
================================================================================

param(
    [string]$ExternalTarget = "8.8.8.8"
)

# Get public IP
$publicIp = try { (Invoke-RestMethod -Uri 'https://api.ipify.org' -TimeoutSec 3) } catch { "Error" }

# Get network configuration details for the primary adapter
$netConfig = Get-NetIPConfiguration | Select-Object -First 1
$gateway = $netConfig.IPv4DefaultGateway
$dnsServers = $netConfig.DNSServer

# Ping gateway and external target
$gatewayLatency = "N/A"
if ($gateway) {
    $pingResult = Test-NetConnection -ComputerName $gateway -Count 1 -ErrorAction SilentlyContinue
    if ($pingResult.PingSucceeded) { $gatewayLatency = "$($pingResult.PingReplyDetails.RoundtripTime) ms" } else { $gatewayLatency = "Timeout" }
}

$externalLatency = "N/A"
if ($ExternalTarget) {
    $pingResult = Test-NetConnection -ComputerName $ExternalTarget -Count 1 -ErrorAction SilentlyContinue
    if ($pingResult.PingSucceeded) { $externalLatency = "$($pingResult.PingReplyDetails.RoundtripTime) ms" } else { $externalLatency = "Timeout" }
}

# Construct the result object
[PSCustomObject]@{
    "Public IP" = $publicIp
    "Gateway" = $gateway
    "Gateway Latency" = $gatewayLatency
    "External Latency" = $externalLatency
    "DNS Servers" = ($dnsServers | Out-String).Trim() # Convert array to string
} | ConvertTo-Json -Compress

================================================================================
FILE: gui/Get-RawNetworkStats.ps1
================================================================================

Get-NetAdapter -IncludeHidden | ForEach-Object {
  $stats = Get-NetAdapterStatistics -Name $_.Name -ErrorAction SilentlyContinue;
  [PSCustomObject]@{
    Name = $_.Name;
    ReceivedBytes = $stats.ReceivedBytes;
    SentBytes = $stats.SentBytes
  }
} | ConvertTo-Json -Compress

================================================================================
FILE: gui/main_controller.py
================================================================================

import logging
from tkinter import messagebox

from localization import get_string
from app_logic import get_adapter_details
from exceptions import NetworkManagerError

logger = logging.getLogger(__name__)

class MainController:
    """
    Handles the main application logic, data flow, and orchestration of UI components.
    Acts as the 'Controller' in a pseudo-MVC pattern for the main window.
    """
    def __init__(self, task_queue):
        self.task_queue = task_queue
        self.adapters_data = []
        self.selected_adapter_index = None

    def refresh_adapter_list(self):
        """Clears and re-populates the listbox with network adapters."""
        logger.info("Starting adapter list refresh...")
        try:
            self.task_queue.put({'type': 'status_update', 'text': get_string('status_refreshing_list')})
            self.task_queue.put({'type': 'clear_details'})
            self.adapters_data = get_adapter_details()
            self.task_queue.put({'type': 'populate_adapters', 'data': self.adapters_data})
            logger.info("Adapter list refresh completed successfully.")
        except NetworkManagerError as e:
            logger.error("Failed to get network adapters.", exc_info=True)
            self.task_queue.put({'type': 'generic_error', 'description': 'retrieving network adapters', 'error': e})
            logger.error("Adapter list refresh failed.")

    def on_adapter_select(self, selected_index: int):
        """Handler for when an adapter is selected in the listbox."""
        if not (0 <= selected_index < len(self.adapters_data)):
            logger.warning("Invalid index %d received from adapter list selection.", selected_index)
            self.selected_adapter_index = None
            return
        
        self.selected_adapter_index = selected_index
        selected_adapter = self.adapters_data[selected_index]
        
        # Send data to the queue for the UI to handle
        self.task_queue.put({'type': 'update_adapter_details', 'data': selected_adapter})

    def get_selected_adapter_name(self) -> str | None:
        """Returns the name of the currently selected adapter, or None."""
        if self.selected_adapter_index is None:
            return None
        return self.adapters_data[self.selected_adapter_index].get('Name')

    def get_speed_for_selected_adapter(self, speeds: dict) -> dict | None:
        """Gets the speed data for the currently selected adapter."""
        selected_adapter_name = self.get_selected_adapter_name()
        if not selected_adapter_name:
            return None
        adapter_speeds = speeds.get(selected_adapter_name)
        return adapter_speeds

================================================================================
FILE: gui/main_window.py
================================================================================

import tkinter as tk
from tkinter import ttk
import logging
from localization import get_string
from functools import partial
from queue import Empty

# Import helper classes
from .menu_handler import MenuHandler
from .app_context import AppContext

# Import UI components
from .adapter_details_frame import AdapterDetailsFrame
from .adapter_list_frame import AdapterListFrame
from .wifi_status_frame import WifiStatusFrame
from .diagnostics_frame import DiagnosticsFrame
 
# --- Constants for UI timings and defaults ---
QUEUE_POLL_INTERVAL_MS = 100
DIAGNOSTICS_REFRESH_INTERVAL_S = 5
SPEED_POLL_INTERVAL_S = 0.5 # Update speed twice per second for better responsiveness
DEFAULT_PING_TARGET = "8.8.8.8"

logger = logging.getLogger(__name__)

class NetworkManagerApp(tk.Tk):
    def __init__(self, context: AppContext):
        super().__init__()
        self.context = context
        # Set the root window in the context immediately, so other components can use it.
        self.context.root = self

        self._is_closing = False  # Flag to indicate if the app is closing

        self.title(get_string('app_title'))
        self.geometry("550x850")
        try:
            self.iconbitmap('icon.ico')
        except tk.TclError as e:
            logger.warning("icon.ico not found. Skipping icon. Error: %s", e)

        # --- Initialize Core UI and Context Components ---
        # The status_var is a core UI element, so it's created here.
        self.status_var = tk.StringVar(value=get_string('status_initializing'))
        self.ui_frames: dict[str, ttk.Frame] = {}

        # --- Setup UI Components ---
        self._setup_ui_frames(self.ui_frames) # Populate the ui_frames dictionary.

        # --- Initialize Handlers and Controllers ---
        # Pass the root window, frames, and the status_var to the context.
        MenuHandler(self.context).create_menu()

        # --- Finalize UI and Start Application ---
        self._create_status_bar()
        self.after(200, self._initial_load)
        self.protocol("WM_DELETE_WINDOW", self._on_closing)

    def _setup_ui_frames(self, ui_frames: dict):
        """Sets up the main UI layout and widgets."""
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ui_frames['adapter_list'] = AdapterListFrame(main_frame, on_select_callback=lambda index: self.context.main_controller.on_adapter_select(index))
        ui_frames['adapter_list'].pack(fill=tk.BOTH, expand=True, pady=5)
        ui_frames['adapter_details'] = AdapterDetailsFrame(
            main_frame,
            on_connect_callback=partial(self.context.action_handler.network.toggle_adapter, 'enable'),
            on_disconnect_callback=partial(self.context.action_handler.network.toggle_adapter, 'disable'),
            on_status_update_callback=self.status_var.set
        )
        ui_frames['adapter_details'].pack(fill=tk.X, pady=5)

        ui_frames['wifi_status'] = WifiStatusFrame(main_frame, on_disconnect_callback=self.context.action_handler.disconnect_current_wifi)
        ui_frames['wifi_status'].pack(fill=tk.X, pady=5)

        ui_frames['diagnostics'] = DiagnosticsFrame(main_frame)
        ui_frames['diagnostics'].pack(fill=tk.X, pady=5)

    def _create_status_bar(self):
        status_bar = ttk.Label(self, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W, padding=2)
        status_bar.pack(side=tk.BOTTOM, fill=tk.X)

    def _initial_load(self):
        """Sets the initial loading message and schedules the background tasks to start."""
        self.status_var.set(get_string('status_refreshing_list', default="Refreshing adapter list..."))
        # Schedule the actual background work to start after the UI has had a moment to update.
        self.after(50, self._start_background_tasks)

    def _start_background_tasks(self):
        """Starts the polling manager and the UI queue processing."""
        # The PollingManager will now start itself after a short delay.
        self.context.polling_manager.start_all(DIAGNOSTICS_REFRESH_INTERVAL_S, SPEED_POLL_INTERVAL_S)
        # Start processing the queue for UI updates.
        logger.info("Starting UI queue processing.")
        self.after(QUEUE_POLL_INTERVAL_MS, self._process_queue)

    def _process_queue(self):
        """Process messages from the worker thread queue."""
        try:
            while not self.context.task_queue.empty():
                message = self.context.task_queue.get_nowait()
                self.context.queue_handler.process_message(message)
                self.update_idletasks()

        except Empty:
            pass
        finally:
            # Only reschedule if the application is not in the process of closing
            if not self._is_closing:
                self.after(QUEUE_POLL_INTERVAL_MS, self._process_queue)

    def _on_closing(self):
        """Handles the window close event."""
        self._is_closing = True
        self.destroy()

================================================================================
FILE: gui/menu_handler.py
================================================================================

import tkinter as tk
from tkinter import messagebox
import os
import sys
import logging
import ctypes

from localization import set_language, get_string, LANG_CODE_KEY
from logger_setup import get_log_file_path
from logic.system import is_admin
from .constants import APP_VERSION, APP_AUTHOR

logger = logging.getLogger(__name__)

class MenuHandler:
    """Handles the creation and callbacks for the main application menu."""
    def __init__(self, context):
        self.context = context
        self.action_handler = self.context.action_handler
        self.app = context.root

        self.language_var = tk.StringVar(value=get_string(LANG_CODE_KEY, default='en')) # Use a key that returns 'en' or 'fi'
        # Define the menu structure as data
        self.menu_structure = [
            {
                "label": get_string('menu_tools'),
                "items": [
                    {"label": get_string('menu_reset_stack'), "command": self.action_handler.network.confirm_reset_network_stack},
                    {"label": get_string('menu_release_renew'), "command": self.action_handler.network.renew_ip},
                    {"label": get_string('menu_flush_dns'), "command": self.action_handler.network.flush_dns},
                    {"type": "separator"},
                    {"label": get_string('menu_connections'), "command": self.action_handler.windows.open_netstat_window},
                    {"label": get_string('menu_traceroute'), "command": self.action_handler.windows.open_traceroute_window},
                    {"label": get_string('menu_wifi'), "command": self.action_handler.windows.open_wifi_window},
                    {"type": "separator"},
                    {
                        "label": get_string('menu_language'),
                        "items": [
                            {"label": get_string('menu_lang_en'), "type": "radiobutton", "variable": self.language_var, "value": "en", "command": self._on_language_change},
                            {"label": get_string('menu_lang_fi'), "type": "radiobutton", "variable": self.language_var, "value": "fi", "command": self._on_language_change},
                        ]
                    },
                    {"type": "separator"},
                    {"label": get_string('menu_publish'), "command": self.action_handler.windows.open_publish_dialog},
                ]
            },
            {
                "label": get_string('menu_help'),
                "items": [
                    {"label": get_string('menu_open_log'), "command": self._open_log_file},
                    {"type": "separator"},
                    {"label": get_string('menu_about'), "command": self._show_about_dialog},
                ]
            }
        ]
        
        # Conditionally remove the "Publish" menu item if running as a packaged app.
        # The 'frozen' attribute is set by PyInstaller.
        if getattr(sys, 'frozen', False):
            logger.info("Running as a packaged app, hiding developer-only menu items.")
            tools_menu_items = self.menu_structure[0]['items']
            # Find and remove the publish item and its preceding separator by searching for the command.
            # This is more robust than relying on the label's text.
            items_to_remove = [
                item for item in tools_menu_items 
                if item.get("command") == self.action_handler.windows.open_publish_dialog
            ]
            if items_to_remove:
                # This assumes the separator is right before the publish item.
                publish_item_index = tools_menu_items.index(items_to_remove[0])
                if publish_item_index > 0 and tools_menu_items[publish_item_index - 1].get("type") == "separator":
                    del tools_menu_items[publish_item_index - 1 : publish_item_index + 1]
                else: # Fallback if separator isn't there
                    del tools_menu_items[publish_item_index]

    def create_menu(self):
        """Creates the main menu bar for the application."""
        menubar = tk.Menu(self.app)
        self._build_menu_from_data(menubar, self.menu_structure)
        self.app.config(menu=menubar)

    def _build_menu_from_data(self, parent_menu, menu_data):
        """Recursively builds a menu from a data structure."""
        for menu_item in menu_data:
            if menu_item.get("items"):  # This is a cascade menu
                new_menu = tk.Menu(parent_menu, tearoff=0)
                self._build_menu_from_data(new_menu, menu_item["items"])
                parent_menu.add_cascade(label=menu_item["label"], menu=new_menu)
            elif menu_item.get("type") == "separator":
                parent_menu.add_separator()
            elif menu_item.get("type") == "radiobutton":
                # Correctly add a radiobutton item
                parent_menu.add_radiobutton(label=menu_item["label"], variable=menu_item.get("variable"), value=menu_item.get("value"), command=menu_item.get("command"))
            else:  # This is a command item
                parent_menu.add_command(label=menu_item["label"], command=menu_item.get("command"))




    def _show_about_dialog(self):
        """Displays the about information box."""
        message_content = get_string(
            'about_message_content',
            app_name="NetPilot", version=APP_VERSION, author=APP_AUTHOR
        )
        messagebox.showinfo(get_string('about_title'), message_content)

    def _open_log_file(self):
        """Opens the log file with the default system editor."""
        log_path = get_log_file_path()
        try:
            os.startfile(log_path)
            logger.info("Opened log file: %s", log_path)
        except FileNotFoundError:
            messagebox.showerror("Error", f"Log file not found at:\n{log_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Could not open log file.\n\nError: {e}")

    def _on_language_change(self):
        """Handles the language selection change."""
        new_lang = self.language_var.get()
        # Get current language before changing it
        current_lang = get_string(LANG_CODE_KEY, default='en')

        if new_lang != current_lang:
            set_language(new_lang)
            
            # Ask the user if they want to restart now
            should_restart = messagebox.askyesno(
                get_string('language_restart_prompt_title'),
                get_string('language_restart_prompt_message'),
                parent=self.app
            )

            if should_restart:
                logger.info("User opted to restart after language change.")
                self.app.destroy() # Close the app gracefully
                # Relaunch the application
                # Note: This re-launches with the same privileges.
                # If admin was required, it should already be running as admin.
                os.execv(sys.executable, [sys.executable] + sys.argv)

================================================================================
FILE: gui/netstat_window.py
================================================================================

import tkinter as tk
from tkinter import ttk, messagebox

from app_logic import get_active_connections, terminate_process_by_pid
from localization import get_string
from exceptions import NetworkManagerError
from .base_window import BaseTaskWindow


class NetstatWindow(BaseTaskWindow):
    """A Toplevel window to display active network connections (netstat)."""

    def __init__(self, context):
        super().__init__(context, title=get_string('netstat_title'), geometry="700x500")
        self.filter_var = tk.StringVar(value="All")
        self.connections_data = []
        
        self._create_widgets()
        self.refresh_connections()

    def _create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Filter Frame ---
        filter_frame = ttk.Frame(main_frame)
        filter_frame.pack(fill=tk.X, pady=(0, 10))
        ttk.Label(filter_frame, text=get_string('netstat_filter_by')).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Radiobutton(filter_frame, text=get_string('netstat_filter_all'), variable=self.filter_var, value="All", command=self._apply_filter).pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(filter_frame, text=get_string('netstat_filter_tcp'), variable=self.filter_var, value="TCP", command=self._apply_filter).pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(filter_frame, text=get_string('netstat_filter_udp'), variable=self.filter_var, value="UDP", command=self._apply_filter).pack(side=tk.LEFT, padx=5)

        # Treeview for displaying connections
        columns = ('proto', 'local', 'foreign', 'state', 'process')
        self.tree = ttk.Treeview(main_frame, columns=columns, show='headings')
        self.tree.heading('proto', text=get_string('netstat_col_proto'), command=lambda: self._sort_by_column('proto', False))
        self.tree.heading('local', text=get_string('netstat_col_local'), command=lambda: self._sort_by_column('local', False))
        self.tree.heading('foreign', text=get_string('netstat_col_foreign'), command=lambda: self._sort_by_column('foreign', False))
        self.tree.heading('state', text=get_string('netstat_col_state'), command=lambda: self._sort_by_column('state', False))
        self.tree.heading('process', text=get_string('netstat_col_process'), command=lambda: self._sort_by_column('process', False))
        self.tree.column('proto', width=60, anchor=tk.W)
        self.tree.column('local', width=200, anchor=tk.W)
        self.tree.column('foreign', width=200, anchor=tk.W)
        self.tree.column('state', width=100, anchor=tk.W)
        self.tree.column('process', width=120, anchor=tk.W)

        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.tree.configure(yscrollcommand=scrollbar.set)

        button_frame = ttk.Frame(self)
        button_frame.pack(fill=tk.X, padx=10, pady=5)
        self.refresh_button = ttk.Button(button_frame, text=get_string('netstat_button_refresh'), command=self.refresh_connections)
        self.refresh_button.pack(side=tk.RIGHT, padx=(5, 0))
        terminate_button = ttk.Button(button_frame, text=get_string('netstat_button_terminate'), command=self._terminate_selected_process)
        terminate_button.pack(side=tk.RIGHT)

    def refresh_connections(self):
        """Starts a background thread to fetch connection data."""
        self.refresh_button.config(state=tk.DISABLED)
        self.context.action_handler.diagnostics.fetch_active_connections(on_complete=self._on_refresh_complete)

    def _on_refresh_complete(self):
        """Called when the refresh task is finished, regardless of outcome."""
        self.refresh_button.config(state=tk.NORMAL)

    def _apply_filter(self):
        """Populates the treeview based on the current data and filter."""
        for i in self.tree.get_children():
            self.tree.delete(i)
        
        filter_value = self.filter_var.get()
        for i, conn in enumerate(self.connections_data):
            conn['internal_id'] = i
            if filter_value == "All" or conn.get('Proto', '').lower() == filter_value.lower():
                self.tree.insert('', tk.END, iid=i, values=(
                    conn.get('Proto', 'N/A'),
                    conn.get('Local', 'N/A'),
                    conn.get('Foreign', 'N/A'),
                    conn.get('State', 'N/A'),
                    conn.get('ProcessName', 'N/A')
                ))

    def populate_tree(self, data):
        """Receives data and updates the tree."""
        self.connections_data = data
        self._apply_filter()

    def _sort_by_column(self, col, reverse):
        data = [(self.tree.set(child, col), child) for child in self.tree.get_children('')]
        data.sort(reverse=reverse)
        for index, (val, child) in enumerate(data):
            self.tree.move(child, '', index)
        self.tree.heading(col, command=lambda: self._sort_by_column(col, not reverse))

    def _terminate_selected_process(self):
        selected_item = self.tree.focus()
        if not selected_item:
            messagebox.showwarning(get_string('netstat_selection_required'), get_string('netstat_selection_required_msg'), parent=self)
            return

        internal_id = int(selected_item)
        selected_conn = next((c for c in self.connections_data if c.get('internal_id') == internal_id), None)

        if not selected_conn or 'PID' not in selected_conn or 'ProcessName' not in selected_conn:
            messagebox.showerror(get_string('toggle_error_title'), get_string('netstat_process_info_error'), parent=self)
            return

        pid = selected_conn['PID']
        process_name = selected_conn['ProcessName']

        prompt = get_string('netstat_terminate_confirm_prompt', process_name=process_name, pid=pid)
        if messagebox.askyesno(get_string('netstat_terminate_confirm_title'), prompt, icon='warning', parent=self):
            try:
                terminate_process_by_pid(pid)
                messagebox.showinfo(get_string('reset_stack_success_title'), get_string('netstat_terminate_success_msg', process_name=process_name, pid=pid), parent=self)
                self.refresh_connections()
            except NetworkManagerError as e:
                messagebox.showerror(get_string('netstat_terminate_failed_title'), str(e), parent=self)

================================================================================
FILE: gui/polling_manager.py
================================================================================

import threading
import subprocess
import time
import logging
import json

from app_logic import get_network_diagnostics, get_current_wifi_details

logger = logging.getLogger(__name__)

class PollingManager:
    """
    Manages background threads for continuously polling network status,
    diagnostics, and speeds.
    """
    def __init__(self, context):
        self.context = context
        self.controller = context.main_controller
        self.task_queue = context.task_queue
        self.last_stats = {}
        self.last_time = time.time()
        self.diagnostics_interval = 5
        self.speed_interval = 1
        self.is_running = False

    def start_all(self, diagnostics_interval: int, speed_interval: int):
        """Starts all polling threads."""
        self.diagnostics_interval = diagnostics_interval
        self.speed_interval = speed_interval
        # Start the polling loops after a short delay to ensure the main UI is ready.
        self.context.root.after(100, self.start_polling_threads)

    def start_polling_threads(self):
        """Starts the background threads for polling data."""
        if self.is_running: return
        self.is_running = True
        logger.info("Starting polling loops...")
        threading.Thread(target=self._poll_loop_wrapper, daemon=True).start()
        threading.Thread(target=self._speed_poll_loop_powershell, daemon=True).start()

    def _speed_poll_loop_powershell(self):
        """
        A dedicated loop that runs a single, persistent PowerShell process
        to efficiently stream network statistics.
        """
        logger.info("Starting persistent PowerShell speed polling loop.")
        ps_script = f"""
            while ($true) {{
                $stats = Get-NetAdapterStatistics -Name * -ErrorAction SilentlyContinue | Select-Object Name, ReceivedBytes, SentBytes
                $stats | ConvertTo-Json -Compress
                Start-Sleep -Milliseconds {int(self.speed_interval * 1000)}
            }}
        """
        
        process = subprocess.Popen(['powershell', '-Command', ps_script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW)

        while self.is_running and process.poll() is None:
            line = process.stdout.readline()
            if line:
                # OPTIMIZATION: Only process speeds if an adapter is actually selected in the UI.
                if self.controller.get_selected_adapter_name() is None:
                    # Sleep briefly to prevent this loop from busy-waiting and consuming CPU
                    time.sleep(self.speed_interval)
                    continue
                calculated_speeds = self._calculate_current_speeds(line)
                if calculated_speeds:
                    self.task_queue.put({'type': 'speed_update', 'data': calculated_speeds})
        logger.warning("PowerShell speed polling loop has exited.")

    def _calculate_current_speeds(self, stats_json: str) -> dict:
        """
        Parses JSON from the PowerShell stream and calculates current network speeds
        based on the delta from the last check.
        """
        try:
            stats_list = json.loads(stats_json)
            if isinstance(stats_list, dict):
                stats_list = [stats_list]
            current_stats = {
                stat['Name']: {'received': stat.get('ReceivedBytes') or 0, 'sent': stat.get('SentBytes') or 0}
                for stat in stats_list if isinstance(stat, dict) and 'Name' in stat
            }
        except (json.JSONDecodeError, TypeError):
            logger.warning("Failed to parse speed stats JSON: %s", stats_json)
            return {}

        current_time = time.time()
        time_delta = current_time - self.last_time

        calculated_speeds = self._calculate_speed_delta(current_stats, self.last_stats, time_delta)

        # Update state for the next calculation
        self.last_stats = current_stats
        self.last_time = current_time

        return calculated_speeds

    def _calculate_speed_delta(self, current_stats: dict, last_stats: dict, time_delta: float) -> dict:
        if not last_stats or not current_stats or time_delta <= 0:
            return {}

        calculated_speeds = {}
        for name, stats in current_stats.items():
            if name in last_stats:
                last = last_stats[name]
                
                current_dl_bytes = stats.get('received')
                last_dl_bytes = last.get('received')
                current_ul_bytes = stats.get('sent')
                last_ul_bytes = last.get('sent')

                # Ensure we have valid numbers to work with
                if not all(isinstance(v, (int, float)) for v in [current_dl_bytes, last_dl_bytes, current_ul_bytes, last_ul_bytes]):
                    continue # Skip this adapter if data is invalid

                dl_delta = current_dl_bytes - last_dl_bytes
                ul_delta = current_ul_bytes - last_ul_bytes

                # If delta is negative, the counter likely reset. Skip this interval.
                calculated_speeds[name] = {
                    'download': (dl_delta / time_delta) if dl_delta >= 0 else 0,
                    'upload': (ul_delta / time_delta) if ul_delta >= 0 else 0
                }
        return calculated_speeds

    def _poll_loop_wrapper(self):
        """Wrapper to handle the lifecycle of the poll loop thread."""
        stop_event = threading.Event()
        try:
            self._poll_loop(stop_event)
        finally:
            self.is_running = False
            logger.info("Main poll loop has stopped.")

    def _poll_loop(self, stop_event: threading.Event):
        """
        A single, unified polling loop that handles all heavy data fetching.
        It runs the adapter refresh once, and other tasks periodically.
        """
        logger.info("Starting main poll loop.")
        
        # --- Task 1: One-time adapter list refresh ---
        try:
            logger.info("Performing initial adapter list refresh...")
            self.controller.refresh_adapter_list()
            logger.info("...initial adapter list refresh complete.")
        except Exception:
            logger.error("Initial adapter list refresh failed.", exc_info=True)

        while self.is_running and not stop_event.is_set():
            try:
                # --- Task 2: Periodic heavy diagnostics ---
                logger.info("Starting heavy poll task cycle...")
                
                # Run diagnostics in a separate thread to not block this loop
                threading.Thread(target=self._fetch_diagnostics_and_queue, daemon=True).start()
                
                # Also fetch light tasks here to keep them in sync
                wifi_data = get_current_wifi_details()
                self.task_queue.put({'type': 'wifi_status_update', 'data': wifi_data})
            except Exception:
                logger.error("Main polling loop encountered an error.", exc_info=True)
            finally:
                stop_event.wait(self.diagnostics_interval)

    def _fetch_diagnostics_and_queue(self):
        """Fetches network diagnostics and puts the result into the task queue."""
        logger.debug("Fetching network diagnostics...")
        diag_data = get_network_diagnostics(external_target=self.context.get_ping_target())
        self.task_queue.put({'type': 'diagnostics_update', 'data': diag_data})
        logger.debug("...diagnostics fetched.")

================================================================================
FILE: gui/publish_window.py
================================================================================



================================================================================
FILE: gui/queue_handler.py
================================================================================

import tkinter as tk
from tkinter import messagebox
import logging
import os

from localization import get_string
from .wifi_queue_handler import WifiQueueHandler

logger = logging.getLogger(__name__)

class QueueHandler:
    """
    Handles messages from the background task queue, updating the UI accordingly.
    """
    def __init__(self, context, ui_frames: dict):
        self.context = context
        self.status_var = context.root.status_var
        self.controller = context.main_controller
        self.ui_frames = ui_frames
        self.wifi_handler = WifiQueueHandler(context)
        self.open_windows = context.open_windows # Shortcut
        self.handler_map = self._create_handler_map()

    def _create_handler_map(self):
        return {
            'toggle_success': self._handle_toggle_success,
            'toggle_error': self._handle_toggle_error,
            'diagnostics_update': self._handle_diagnostics_update,
            'wifi_status_update': lambda msg: self.ui_frames['wifi_status'].update_status(msg['data']),
            'status_update': lambda msg: self.status_var.set(msg['text']),
            'speed_update': self._handle_speed_update,
            'reset_stack_success': self._handle_reset_stack_success,
            'reset_stack_error': lambda msg: self._handle_generic_error("resetting network stack", msg['error']),
            'flush_dns_success': self._handle_flush_dns_success,
            'flush_dns_error': lambda msg: self._handle_generic_error("flushing DNS cache", msg['error']),
            'release_renew_success': self._handle_release_renew_success,
            'release_renew_error': lambda msg: self._handle_generic_error("renewing IP address", msg['error']),
            'disconnect_wifi_success': self._handle_disconnect_wifi_success,
            'disconnect_wifi_error': self._handle_disconnect_wifi_error,
            # Generic handlers for Toplevel windows
            'ui_update': self._handle_ui_update,
            'unhandled_error': lambda msg: self._handle_generic_error("in a background task", msg['error']),
            'generic_error': lambda msg: self._handle_generic_error(msg['description'], msg['error']),
            # New handlers for decoupled MainController
            'populate_adapters': self._handle_populate_adapters,
            'clear_details': lambda msg: self.ui_frames['adapter_details'].clear(),
            'update_adapter_details': self._handle_update_adapter_details,
        }

    def process_message(self, message):
        logger.debug("Processing queue message: %s", message.get('type'))
        # First, try to let the specialized Wi-Fi handler process the message.
        if self.wifi_handler.process_message(message):
            return # Message was handled by the Wi-Fi handler.

        # If not handled, try the main handler.
        handler = self.handler_map.get(message.get('type'))
        if handler: # type: ignore
            handler(message) # type: ignore
        else:
            logger.warning("No handler found for queue message type: %s", message['type'])

    def _handle_toggle_success(self, message):
        self.status_var.set(get_string('status_refreshing_list'))
        self.context.root.after(500, self.controller.refresh_adapter_list)

    def _handle_toggle_error(self, message):
        adapter, action, error = message['adapter_name'], message['action'], message['error']
        logger.error("Failed to toggle adapter '%s' to state '%s'.", adapter, action, exc_info=error)
        self.controller.refresh_adapter_list() # Refresh to show the actual current state

        if hasattr(error, 'code') and error.code == 'WIFI_CONNECTED_DISABLE_FAILED':
            prompt = get_string('toggle_wifi_connected_prompt', adapter=adapter)
            if messagebox.askyesno(get_string('toggle_wifi_connected_title'), prompt, icon='question'):
                self.status_var.set(get_string('status_disconnect_and_disable'))
                self.context.action_handler.network.execute_disconnect_and_disable(adapter)
            else:
                self.status_var.set(get_string('status_op_cancelled_by_user'))
        elif "is already" in str(error):
            messagebox.showinfo(get_string('toggle_info_title'), str(error))
            self.status_var.set(get_string('status_not_needed'))
        else:
            messagebox.showerror(get_string('toggle_error_title'), get_string('toggle_error_message', error=error))
            self.status_var.set(get_string('status_failed_op', adapter_name=adapter))

    def _handle_diagnostics_update(self, message):
        self.ui_frames['diagnostics'].update_diagnostics(message['data'])

    def _handle_speed_update(self, message):
        all_speeds = message['data']
        adapter_speeds = self.controller.get_speed_for_selected_adapter(all_speeds)
        
        if adapter_speeds:
            download = adapter_speeds.get('download', 0)
            upload = adapter_speeds.get('upload', 0)
            self.ui_frames['adapter_details'].update_speeds(download, upload)
        else:
            self.ui_frames['adapter_details'].update_speeds(0, 0)

    def _handle_populate_adapters(self, message):
        """Populates the adapter list and updates the status bar."""
        self.ui_frames['adapter_list'].populate(message['data'])
        self.status_var.set(get_string('status_ready_select_adapter'))

    def _handle_update_adapter_details(self, message):
        self.ui_frames['adapter_details'].update_details(message['data'])
        self.ui_frames['adapter_details'].update_button_states(message['data'].get('admin_state'))

    def _handle_reset_stack_success(self, message):
        messagebox.showinfo(get_string('reset_stack_success_title'), get_string('reset_stack_success_message'))
        self.status_var.set(get_string('status_reset_success'))

    def _handle_flush_dns_success(self, message):
        messagebox.showinfo(get_string('flush_dns_success_title'), get_string('flush_dns_success_message'))
        self.status_var.set(get_string('status_dns_flush_success'))

    def _handle_release_renew_success(self, message):
        messagebox.showinfo(get_string('release_renew_success_title'), get_string('release_renew_success_message'))
        self.status_var.set(get_string('status_ip_renew_success'))
        self.controller.refresh_adapter_list()

    def _handle_disconnect_wifi_success(self, message):
        # This can be triggered from main window or wifi window, so check for parent
        parent = self.context.open_windows.get('WifiConnectWindow') or self.context.root
        messagebox.showinfo(get_string('disconnect_wifi_success_title'), get_string('disconnect_wifi_success_message'), parent=parent)
        self.status_var.set(get_string('status_wifi_disconnected'))
        
        # Also refresh the wifi window if it's open
        self._refresh_wifi_window_if_open()

    def _handle_disconnect_wifi_error(self, message):
        self._handle_generic_error("disconnecting from Wi-Fi", message['error'])
        self.ui_frames['wifi_status'].disconnect_button.config(state=tk.NORMAL)

    def _handle_generic_error(self, action_description, error):
        # Check for specific, actionable error codes first.
        if hasattr(error, 'code') and error.code == "LOCATION_PERMISSION_DENIED":
            parent_window = self.context.open_windows.get('WifiConnectWindow') or self.context.root
            if messagebox.askyesno("Permission Required", f"{error}\n\nDo you want to open the Location Settings page now?", parent=parent_window):
                os.startfile("ms-settings:privacy-location")
            return

        messagebox.showerror("Error", f"Failed while {action_description}:\n\n{error}")
        self.status_var.set(f"Error {action_description}.")

    def _handle_ui_update(self, message):
        """Executes a function on the UI thread."""
        if callable(message.get('func')):
            message['func']()

    def handle_netstat_update(self, data):
        """Updates the Netstat window with new connection data."""
        netstat_window = self.open_windows.get('NetstatWindow')
        if netstat_window:
            netstat_window.populate_tree(data)

    def handle_traceroute_update(self, line: str):
        """Appends a line to the Traceroute window's output."""
        traceroute_window = self.open_windows.get('TracerouteWindow')
        if traceroute_window:
            traceroute_window.append_line(line)



    def _refresh_wifi_window_if_open(self):
        """Helper to refresh the Wi-Fi window's state if it is currently open."""
        wifi_window = self.context.open_windows.get('WifiConnectWindow')
        if wifi_window:
            wifi_window.status_label.config(text="Disconnected.")
            wifi_window.available_tab.refresh_list()


================================================================================
FILE: gui/saved_profiles_tab.py
================================================================================

import tkinter as tk
from tkinter import ttk, messagebox, filedialog

from app_logic import get_saved_wifi_profiles, connect_with_profile_name, delete_wifi_profile
from localization import get_string

class SavedProfilesTab(ttk.Frame):
    """
    UI and logic for the 'Saved Profiles' tab in the Wi-Fi window.
    """
    def __init__(self, parent_notebook, window, task_queue, status_label):
        super().__init__(parent_notebook)
        self.window = window
        self.task_queue = task_queue
        self.status_label = status_label

        self._create_widgets()

    def _create_widgets(self):
        tree_frame = ttk.Frame(self)
        tree_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        columns = ('ssid', 'password')
        self.tree = ttk.Treeview(tree_frame, columns=columns, show='headings')
        self.tree.heading('ssid', text=get_string('wifi_col_profile'))
        self.tree.heading('password', text=get_string('wifi_col_password'))
        self.tree.column('ssid', width=250); self.tree.column('password', width=300)
        self.tree.bind('<Double-1>', lambda e: self.connect_to_profile())
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.tree.configure(yscrollcommand=scrollbar.set)

        button_frame = ttk.Frame(self)
        button_frame.pack(fill=tk.X, pady=5)
        export_button = ttk.Button(button_frame, text=get_string('wifi_button_export'), command=self._export_profiles)
        export_button.pack(side=tk.LEFT)

        copy_button = ttk.Button(button_frame, text=get_string('wifi_button_copy_pass'), command=self._copy_password)
        delete_button = ttk.Button(button_frame, text=get_string('wifi_button_delete'), command=self.delete_profile)
        self.connect_button = ttk.Button(button_frame, text=get_string('wifi_button_connect'), command=self.connect_to_profile)
        self.disconnect_button = ttk.Button(button_frame, text=get_string('wifi_button_disconnect'), command=self.window.disconnect_from_wifi)
        copy_button.pack(side=tk.RIGHT); delete_button.pack(side=tk.RIGHT, padx=(0, 5))
        self.connect_button.pack(side=tk.RIGHT, padx=(0, 5)); self.disconnect_button.pack(side=tk.RIGHT, padx=(0, 5))

    def refresh_list(self):
        self.status_label.config(text=get_string('status_refreshing_list'))
        self.window._run_background_task(self._execute_refresh_in_thread)

    def _execute_refresh_in_thread(self):
        """Worker function to get saved profiles."""
        data = get_saved_wifi_profiles()
        self.task_queue.put({'type': 'wifi_saved_profiles_success', 'data': data})

    def populate_list(self, profiles_data):
        self.tree.delete(*self.tree.get_children())
        if not profiles_data:
            self.tree.insert('', tk.END, values=(get_string('no_adapters_found'), "")) # Re-use string
            self.tree.config(selectmode="none")
        else:
            self.tree.config(selectmode="browse")
            for profile in profiles_data:
                self.tree.insert('', tk.END, values=(profile['ssid'], profile['password']))

    def connect_to_profile(self):
        selected_item = self.tree.focus()
        if not selected_item:
            messagebox.showwarning(get_string('netstat_selection_required'), get_string('wifi_select_to_connect'), parent=self.window)
            return
        profile_name = self.tree.item(selected_item)['values'][0]
        self.status_label.config(text=get_string('wifi_connect_status', ssid=profile_name))
        self.set_button_state('connect', tk.DISABLED, get_string('wifi_connect_status', ssid='...'))
        self.window._run_background_task(
            lambda: self._execute_connect_in_thread(profile_name),
            on_complete=self.reset_connect_button
        )

    def _execute_connect_in_thread(self, profile_name):
        connect_with_profile_name(profile_name)
        self.task_queue.put({'type': 'wifi_connect_success', 'ssid': profile_name})

    def delete_profile(self):
        selected_item = self.tree.focus()
        if not selected_item:
            messagebox.showwarning(get_string('netstat_selection_required'), get_string('wifi_select_to_delete'), parent=self.window)
            return
        profile_name = self.tree.item(selected_item)['values'][0]
        if messagebox.askyesno(get_string('wifi_delete_confirm_title'), get_string('wifi_delete_confirm_msg', profile_name=profile_name), icon='warning', parent=self.window):
            self.status_label.config(text=get_string('status_disable_attempt', adapter_name=profile_name))
            self.window._run_background_task(lambda: self._execute_delete_in_thread(profile_name))

    def _execute_delete_in_thread(self, profile_name):
        delete_wifi_profile(profile_name)
        self.task_queue.put({'type': 'wifi_delete_profile_success', 'profile_name': profile_name})

    def _export_profiles(self):
        if not self.tree.get_children(): return
        filepath = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt")], initialfile="wifi_profiles.txt")
        if not filepath: return
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write("Saved Wi-Fi Profiles\n" + "=" * 30 + "\n\n")
                for item_id in self.tree.get_children():
                    ssid, password = self.tree.item(item_id)['values']
                    f.write(f"SSID:     {ssid}\nPassword: {password}\n\n")
            messagebox.showinfo(get_string('wifi_export_success_title'), get_string('wifi_export_success_msg', filepath=filepath), parent=self.window)
        except IOError as e:
            messagebox.showerror(get_string('netstat_terminate_failed_title'), f"An error occurred while writing to the file:\n{e}", parent=self.window)

    def _copy_password(self):
        selected_item = self.tree.focus()
        if not selected_item: return
        item = self.tree.item(selected_item)
        password = item['values'][1]
        if password and "N/A" not in password and "(" not in password:
            self.window.clipboard_clear(); self.window.clipboard_append(password)
            self.status_label.config(text=get_string('wifi_password_copied', profile_name=item['values'][0]))

    def set_button_state(self, button_name, state, text=None):
        button = getattr(self, f"{button_name}_button", None)
        if button: button.config(state=state); button.config(text=text) if text else None

    def reset_connect_button(self):
        self.set_button_state('connect', tk.NORMAL, get_string('wifi_button_connect'))

================================================================================
FILE: gui/traceroute_window.py
================================================================================

import tkinter as tk
from tkinter import ttk, messagebox
import logging

from app_logic import run_traceroute
from localization import get_string
from exceptions import NetworkManagerError
from .base_window import BaseTaskWindow

logger = logging.getLogger(__name__)

class TracerouteWindow(BaseTaskWindow):
    """A Toplevel window to run and display traceroute results."""

    def __init__(self, context):
        super().__init__(context, title=get_string('traceroute_title'), geometry="600x400")
        self._create_widgets()

    def _create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Input frame
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X, pady=(0, 10))
        ttk.Label(input_frame, text=get_string('traceroute_target')).pack(side=tk.LEFT, padx=(0, 5))
        self.target_var = tk.StringVar(value="8.8.8.8")
        target_entry = ttk.Entry(input_frame, textvariable=self.target_var)
        target_entry.pack(side=tk.LEFT, expand=True, fill=tk.X)
        self.start_button = ttk.Button(input_frame, text=get_string('traceroute_button_start'), command=self.start_trace)
        self.start_button.pack(side=tk.LEFT, padx=(5, 0))

        # Output text area
        text_frame = ttk.Frame(main_frame)
        text_frame.pack(fill=tk.BOTH, expand=True)
        self.output_text = tk.Text(text_frame, wrap=tk.WORD, state=tk.DISABLED, height=15)
        self.output_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=self.output_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.output_text.config(yscrollcommand=scrollbar.set)

    def start_trace(self):
        target = self.target_var.get()
        if not target:
            messagebox.showwarning(get_string('traceroute_input_required'), get_string('traceroute_input_required_msg'), parent=self)
            return

        self.start_button.config(state=tk.DISABLED)
        self.output_text.config(state=tk.NORMAL)
        self.output_text.delete('1.0', tk.END)
        # Add an immediate indicator that the process has started.
        self.append_line(get_string('traceroute_starting', target=target))
        self.append_line("-" * 40) # Visual separator

        logger.info("Starting traceroute to target: %s", target)
        self.context.action_handler.diagnostics.run_traceroute(
            target,
            on_complete=self.on_trace_done
        )

    def append_line(self, line: str):
        """Appends a line of text to the output widget."""
        # Prevent errors if the window is closed while the trace is running.
        if not self.output_text.winfo_exists():
            return
        self.output_text.config(state=tk.NORMAL)
        self.output_text.insert(tk.END, line + "\n")
        self.output_text.see(tk.END)  # Auto-scroll
        self.output_text.config(state=tk.DISABLED)

    def on_trace_done(self):
        """Re-enables the start button when the trace is complete."""
        # Check if the widget still exists before trying to configure it.
        # This prevents an error if the window was closed during the trace.
        logger.info("Traceroute task completed.")
        if self.start_button.winfo_exists():
            self.start_button.config(state=tk.NORMAL)

================================================================================
FILE: gui/utils.py
================================================================================

import tkinter as tk

class ToolTip:
    """
    Creates a tooltip for a given widget.
    """
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tooltip_window = None
        self.id = None
        self.x = self.y = 0
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(500, self.showtip)

    def unschedule(self):
        if self.id:
            self.widget.after_cancel(self.id)
        self.id = None

    def showtip(self, event=None):
        x, y, _, _ = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        self.tooltip_window = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(tw, text=self.text, justify='left',
                       background="#ffffe0", relief='solid', borderwidth=1,
                       font=("tahoma", "8", "normal"))
        label.pack(ipadx=1)

    def hidetip(self):
        tw = self.tooltip_window
        self.tooltip_window = None
        if tw:
            tw.destroy()

def create_tooltip(widget, text):
    """Factory function to create a tooltip for a widget."""
    ToolTip(widget, text)

def format_speed(Bps: float) -> str:
    """Formats speed from Bytes/sec to a readable string (kbps/Mbps)."""
    # Handle invalid or negative inputs gracefully.
    if not isinstance(Bps, (int, float)):
        raise TypeError("Speed must be a numeric value.")
    if Bps < 0:
        Bps = 0
        
    if Bps < 125000:  # Under 1 Mbps (125,000 Bytes/sec)
        return f"{Bps * 8 / 1000:.1f} kbps"
    else:
        return f"{Bps * 8 / 1000000:.2f} Mbps"

================================================================================
FILE: gui/wifi_queue_handler.py
================================================================================

import tkinter as tk
from tkinter import messagebox
import os

class WifiQueueHandler:
    """
    Handles messages from the task queue specifically for the WifiConnectWindow.
    """
    def __init__(self, context):
        self.context = context
        self.handler_map = self._create_handler_map()

    def _create_handler_map(self):
        return {
            'wifi_list_success': self._handle_list_success,
            'wifi_connect_success': self._handle_connect_success,
            'wifi_saved_profiles_success': self._handle_saved_profiles_success,
            'wifi_delete_profile_success': self._handle_delete_profile_success,
        }

    def process_message(self, msg: dict):
        """Processes a message if it's relevant to the Wi-Fi window."""
        handler = self.handler_map.get(msg['type'])
        if handler:
            handler(msg)
            return True # Message was handled
        return False # Message was not for this handler

    def _get_window(self):
        """Helper to safely get the WifiConnectWindow instance."""
        return self.context.open_windows.get('WifiConnectWindow')

    def _handle_list_success(self, msg):
        window = self._get_window()
        if window:
            window.available_tab.populate_list(msg['data'], msg.get('current_ssid'))
            window.status_label.config(text="Scan complete. Select a network.")

    def _handle_connect_success(self, msg):
        window = self._get_window()
        if window:
            messagebox.showinfo("Success", f"Successfully connected to '{msg['ssid']}'.", parent=window)
            window.status_label.config(text=f"Connected to {msg['ssid']}.")
            window.available_tab.reset_connect_button()
            window.saved_tab.reset_connect_button()
            window.available_tab.refresh_list()

    def _handle_saved_profiles_success(self, msg):
        window = self._get_window()
        if window:
            window.saved_tab.populate_list(msg['data'])
            window.status_label.config(text="Saved profiles loaded.")

    def _handle_delete_profile_success(self, msg):
        window = self._get_window()
        if window:
            messagebox.showinfo("Success", f"Profile '{msg['profile_name']}' has been deleted.", parent=window)
            window.saved_tab.refresh_list()

================================================================================
FILE: gui/wifi_status_frame.py
================================================================================

import tkinter as tk
from tkinter import ttk

from localization import get_string


class WifiStatusFrame(ttk.LabelFrame):
    """
    A frame that displays the status of the current Wi-Fi connection
    and provides a disconnect button.
    """

    def __init__(self, parent, on_disconnect_callback, **kwargs):
        super().__init__(parent, text=get_string('wifi_status_title'), **kwargs)
        self.on_disconnect_callback = on_disconnect_callback

        # Data-driven structure for UI elements.
        # Each tuple contains: (Localization Key, Data Key)
        self.status_map = [
            ('wifi_status_ssid', "ssid"),
            ('wifi_status_signal', "signal"),
            ('wifi_status_ip', "ipv4"),
        ]

        self.wifi_labels = {}
        self._create_widgets()

    def _create_widgets(self):
        self.disconnect_button = ttk.Button(self, text=get_string('wifi_button_disconnect'), command=self.on_disconnect_callback, state=tk.DISABLED)
        self.disconnect_button.grid(row=0, column=2, rowspan=len(self.status_map), padx=10, pady=5, sticky="ns")

        for i, (label_key, _) in enumerate(self.status_map):
            display_text = get_string(label_key)
            ttk.Label(self, text=f"{display_text}:").grid(row=i, column=0, sticky=tk.W, padx=5, pady=2)
            value_label = ttk.Label(self, text="N/A", anchor=tk.W)
            value_label.grid(row=i, column=1, sticky=tk.W, padx=5, pady=2)
            self.wifi_labels[label_key] = value_label
        
        self.grid_columnconfigure(1, weight=1)

    def update_status(self, wifi_data: dict | None):
        """Updates the labels with current Wi-Fi data."""
        is_connected = bool(wifi_data)
        details = wifi_data or {}
        self.disconnect_button.config(state=tk.NORMAL if is_connected else tk.DISABLED)

        for label_key, key in self.status_map:
            default_value = get_string('wifi_status_not_connected') if key == "ssid" else "-"
            value = details.get(key, default_value)
            self.wifi_labels[label_key].config(text=value)

================================================================================
FILE: gui/wifi_window.py
================================================================================

import tkinter as tk
from tkinter import ttk, messagebox

from app_logic import disconnect_wifi
from localization import get_string
from .base_window import BaseTaskWindow
from .available_networks_tab import AvailableNetworksTab
from .saved_profiles_tab import SavedProfilesTab

class WifiConnectWindow(BaseTaskWindow):
    """A Toplevel window to browse and connect to Wi-Fi networks."""

    def __init__(self, context):
        super().__init__(context, title=get_string('wifi_window_title'), geometry="800x500")

        self._create_widgets()
        self.available_tab.refresh_list() # Initial refresh

    def _create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        bottom_frame = ttk.Frame(self)
        bottom_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        self.status_label = ttk.Label(bottom_frame, text=get_string('status_initial_load')) # Re-use a generic string
        self.status_label.pack(side=tk.LEFT, expand=True, fill=tk.X)

        # Create tabs using the new dedicated classes, passing necessary dependencies
        self.available_tab = AvailableNetworksTab(self.notebook, self, self.task_queue, self.status_label)
        self.saved_tab = SavedProfilesTab(self.notebook, self, self.task_queue, self.status_label)

        self.notebook.add(self.available_tab, text=get_string('wifi_tab_available'))
        self.notebook.add(self.saved_tab, text=get_string('wifi_tab_saved'))
        self.notebook.bind("<<NotebookTabChanged>>", self._on_tab_change)

    def _on_tab_change(self, event):
        """Callback for when the notebook tab changes."""
        selected_tab_index = self.notebook.index(self.notebook.select())
        if selected_tab_index == 1: # Saved Profiles tab
            self.saved_tab.refresh_list()

    def disconnect_from_wifi(self):
        """Initiates a Wi-Fi disconnection, shared by both tabs."""
        if messagebox.askyesno(get_string('wifi_button_disconnect'), "Are you sure you want to disconnect from the current Wi-Fi network?", parent=self):
            self.status_label.config(text=get_string('status_wifi_disconnected'))
            self.available_tab.set_button_state('disconnect', tk.DISABLED)
            self.saved_tab.set_button_state('disconnect', tk.DISABLED)
            self.context.action_handler.network.disconnect_current_wifi()

    def _on_disconnect_complete(self):
        """Re-enables disconnect buttons on completion."""
        self.available_tab.set_button_state('disconnect', tk.NORMAL)
        self.saved_tab.set_button_state('disconnect', tk.NORMAL)

================================================================================
FILE: gui/__init__.py
================================================================================



================================================================================
FILE: logic/adapters.py
================================================================================

import json
import logging
import time
import os

from exceptions import NetworkManagerError
from .command_utils import run_external_ps_script, run_ps_command
from .wifi import disconnect_wifi, get_current_wifi_details

logger = logging.getLogger(__name__)

# Constants for the disconnect-and-disable workflow
DISCONNECT_TIMEOUT_SECONDS = 5
POLL_INTERVAL_SECONDS = 1

def get_adapter_details() -> list[dict]:
    """
    Retrieves detailed information for all physical network adapters by running
    an optimized external PowerShell script.
    """
    try:
        result_json = run_external_ps_script('Get-AdapterDetails.ps1')
        # If the script returns nothing, treat it as an empty list of adapters.
        if not result_json:
            return []
        adapters = json.loads(result_json)

        if not isinstance(adapters, list):
            adapters = [adapters]

        for adapter in adapters:
            # NetConnectionStatus from Win32_NetworkAdapter is the most reliable administrative state.
            # A value of 4 means 'Disabled'. All other values mean it's administratively enabled.
            adapter['admin_state'] = 'Disabled' if adapter.get('NetConnectionStatus') == 4 else 'Enabled'
        return adapters
    except (json.JSONDecodeError, NetworkManagerError) as e:
        raise NetworkManagerError(f"Failed to parse adapter details from PowerShell: {e}") from e

def _handle_adapter_status_error(error: NetworkManagerError, adapter_name: str, action: str):
    """Analyzes a NetworkManagerError and re-raises a more specific one if possible."""
    error_str = str(error).lower()  # noqa: E501

    # Check for the specific "cannot disable" error to provide a helpful hint.
    if action == 'disable' and ("cannot be disabled" in error_str or "ei voi poistaa käytöstä" in error_str):  # noqa: E501
        raise NetworkManagerError(
            f"Cannot disable '{adapter_name}' while it is connected to a Wi-Fi network.",  # noqa: E501
            code='WIFI_CONNECTED_DISABLE_FAILED'
        ) from error

    # Check for "already in state" error.
    # The message is typically "The object is already in the state 'Enabled'."
    if "object is already in the state" in error_str:
        raise NetworkManagerError(
            f"Adapter '{adapter_name}' is already {action}d.") from error

    # For all other errors, re-raise a generic but informative exception.
    raise NetworkManagerError(
        f"Failed to {action} adapter '{adapter_name}':\n{error}") from error

def set_network_adapter_status_windows(adapter_name: str, action: str):
    """
    Enables or disables a network adapter on Windows using PowerShell. This
    version does not proactively check Wi-Fi status, relying on the OS to fail
    if needed.
    """
    if action not in ['enable', 'disable']:
        raise ValueError(
            f"Invalid action '{action}'. Must be 'enable' or 'disable'.")

    # Using PowerShell is more robust than netsh for enabling/disabling.
    ps_command = action.capitalize()  # noqa: E501
    ps_script = f"{ps_command}-NetAdapter -Name '{adapter_name}' -Confirm:$false"

    try:
        run_ps_command(ps_script)
    except NetworkManagerError as e:
        _handle_adapter_status_error(e, adapter_name, action)

def disconnect_wifi_and_disable_adapter(adapter_name: str):
    """A multi-step workflow to first disconnect from Wi-Fi, then disable the
    adapter.

    Yields status messages for the UI to consume.
    """
    yield "Step 1/3: Disconnecting from Wi-Fi..."
    # This function now handles the "already disconnected" case gracefully.
    disconnect_wifi()
    yield "Step 2/3: Confirming disconnection..."
    start_time = time.time()
    while time.time() - start_time < DISCONNECT_TIMEOUT_SECONDS:
        if get_current_wifi_details() is None:
            break  # Disconnection confirmed
        time.sleep(POLL_INTERVAL_SECONDS)
    else:
        # If the loop finishes without breaking, the timeout was reached.
        raise NetworkManagerError(
            f"Failed to confirm Wi-Fi disconnection within {DISCONNECT_TIMEOUT_SECONDS} seconds.")

    yield f"Step 3/3: Disabling adapter '{adapter_name}'..."
    set_network_adapter_status_windows(adapter_name, 'disable')

    yield f"Successfully disabled '{adapter_name}'."

================================================================================
FILE: logic/command_utils.py
================================================================================

import subprocess
import logging
import base64
import os
import codecs

from exceptions import NetworkManagerError

logger = logging.getLogger(__name__)

def _decode_with_encoding(byte_string: bytes, encoding: str, errors: str = 'strict') -> str:
    """Wrapper for bytes.decode to make it patchable for tests."""
    return byte_string.decode(encoding, errors=errors)

def _safe_decode(byte_string: bytes | None) -> str:
    """Safely decodes a byte string using common encodings."""
    if not byte_string:
        return ""
    try:
        return _decode_with_encoding(byte_string, 'utf-8').strip()
    except UnicodeDecodeError:
        try:
            return _decode_with_encoding(byte_string, 'oem').strip()
        except UnicodeDecodeError:
            return _decode_with_encoding(byte_string, 'ascii', errors='replace').strip().replace('\ufffd', '?')

def run_system_command(command: list[str], error_message_prefix: str,
                       check: bool = True, cwd: str | None = None, timeout: int = 10):
    """
    A helper function to run a system command and handle errors consistently.
    Raises NetworkManagerError on failure.
    """
    # noqa: E501
    # To avoid logging a huge base64 string, shorten the log message for encoded commands.
    if "-EncodedCommand" in command:
        try:
            log_command = " ".join(command[:command.index("-EncodedCommand") + 1]) + " <...>"
        except (ValueError, IndexError):
            log_command = " ".join(command) # Fallback
        logger.debug("Executing system command: %s", log_command)
    else:
        logger.debug("Executing system command: %s", " ".join(command))
    try:
        # Use text=False to capture raw bytes and decode manually for robustness
        # Using Popen with communicate is more robust for handling timeouts with I/O.
        with subprocess.Popen(
            command,
            shell=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            creationflags=subprocess.CREATE_NO_WINDOW,
            cwd=cwd
        ) as process:
            stdout_bytes, stderr_bytes = process.communicate(timeout=timeout)
            if check and process.returncode != 0:
                # Manually raise a CalledProcessError to mimic subprocess.run's behavior.
                raise subprocess.CalledProcessError(process.returncode, command, output=stdout_bytes, stderr=stderr_bytes)
            return subprocess.CompletedProcess(command, process.returncode, stdout_bytes, stderr_bytes)
    except subprocess.CalledProcessError as e: # This will now be caught from our manual raise.
        # Safely decode output for error logging
        stdout = _safe_decode(e.stdout)
        stderr = _safe_decode(e.stderr)

        # Create a detailed message for logging
        log_message = (
            f"{error_message_prefix}\n\n"
            f"Command: {' '.join(e.cmd)}\n"
            f"Return Code: {e.returncode}\n"
            f"Stderr: {stderr}\n"
            f"Stdout: {stdout}"
        )
        logger.error("System command failed: %s", log_message)
        # Raise a cleaner error for the UI, preferring stderr if available.
        user_error_message = stderr or stdout or "An unknown error occurred."
        raise NetworkManagerError(f"{error_message_prefix}: {user_error_message}") from e
    except subprocess.TimeoutExpired as e:  # noqa: E501
        logger.error("System command timed out: %s", " ".join(command))
        raise NetworkManagerError(
            f"The operation timed out after {timeout} seconds: {' '.join(command)}") from e
    except FileNotFoundError as e:
        raise NetworkManagerError(
            f"Command '{command[0]}' not found. Is it in the system's PATH?") from e

def run_ps_command(script: str, ps_args: list[str] | None = None, stream_output: bool = False):
    """
    Runs a PowerShell script safely using -EncodedCommand.
    Optional ps_args are passed as arguments to the PowerShell script.

    Args:
        script: The PowerShell script content to run.
        ps_args: Optional list of arguments for the script.
        stream_output: If True, yields output lines as a generator.
                       If False (default), returns the entire decoded stdout string.

    Raises NetworkManagerError on failure.
    """
    logger.debug("Executing PowerShell script.")
    # type: ignore
    encoded_script = base64.b64encode(script.encode('utf-16-le')).decode('ascii')
    command = ['powershell', '-ExecutionPolicy', 'Bypass', '-EncodedCommand', encoded_script]
    if ps_args:
        command.extend(ps_args)

    if stream_output:
        return _stream_ps_command(command)
    else:
        result = run_system_command(
            command, "PowerShell script execution failed.")
        return result.stdout.decode('utf-8', errors='ignore')

def _stream_ps_command(command: list[str]):
    """Helper generator to stream output from a PowerShell command."""
    with subprocess.Popen(
        command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
        text=True, encoding='utf-8', errors='ignore',
        shell=False, creationflags=subprocess.CREATE_NO_WINDOW
    ) as process:
        if process.stdout:
            for line in iter(process.stdout.readline, ''):
                yield line.strip()

def run_external_ps_script(script_name: str, ps_args: list[str] | None = None) -> str:
    """
    Helper to read and execute an external PowerShell script from the 'scripts' directory.
    """
    try:
        # The scripts are located in the same directory as this utility file ('logic/').
        script_dir = os.path.dirname(__file__)
        script_path = os.path.join(script_dir, script_name)

        with open(script_path, 'r', encoding='utf-8') as f:
            ps_script = f.read()

        # If arguments are provided, prepend them to the script content.
        # This is the correct way to pass variables to an EncodedCommand.
        if ps_args:
            arg_string = "; ".join(ps_args)
            ps_script = f"{arg_string};\n{ps_script}"

        return run_ps_command(ps_script)
    except FileNotFoundError as e:
        raise NetworkManagerError(
            f"PowerShell script '{script_name}' not found: {e}") from e

================================================================================
FILE: logic/diagnostics.py
================================================================================

import subprocess
import re
import logging
import requests
import json

from exceptions import NetworkManagerError
from .command_utils import run_system_command, run_external_ps_script, run_ps_command

logger = logging.getLogger(__name__)

def get_network_diagnostics(external_target: str = "8.8.8.8") -> dict:
    """Gathers various network diagnostic details using native Python and system
    commands."""
    diagnostics = {
        "Public IP": "Error",
        "Gateway": "N/A",
        "Gateway Latency": "N/A",
        "External Latency": "N/A",
        "DNS Servers": "N/A",
    }

    # 1. Get Public IP using requests library (more reliable than Invoke-RestMethod)
    try:
        response = requests.get('https://api.ipify.org', timeout=2)
        response.raise_for_status()
        diagnostics["Public IP"] = response.text.strip()
    except requests.RequestException as e:
        logger.warning("Could not fetch public IP: %s", e)

    # 2. Get Gateway and DNS from ipconfig
    try:
        ipconfig_output = run_system_command(
            ['ipconfig', '/all'], "Failed to run ipconfig").stdout.decode('oem', errors='ignore')
        gateway_match = re.search(
            r"Default Gateway . . . . . . . . . : (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", ipconfig_output)
        if gateway_match:
            diagnostics["Gateway"] = gateway_match.group(1)

        # Make regex bilingual to support both "DNS Servers" and "DNS-palvelimet"
        dns_matches = re.findall(
            r"DNS(?: Servers|-palvelimet) .*: ([\d\.\s]+)", ipconfig_output)
        if dns_matches:
            # Clean up and join all found DNS servers
            all_dns = [ip.strip() for dns_block in dns_matches for ip in dns_block.split(
                '\n') if ip.strip()]
            diagnostics["DNS Servers"] = ", ".join(all_dns)
    except NetworkManagerError as e:
        logger.warning("Could not parse ipconfig output: %s", e)

    # 3. Get Latencies using system ping
    def get_latency(target: str) -> str:
        if not target or target == "0.0.0.0":
            return "N/A"
        try:
            ping_output = run_system_command(
                ['ping', '-n', '1', '-w', '1000', target], "Ping failed").stdout.decode('oem', errors='ignore')
            match = re.search(r"Average = (\d+)ms", ping_output)
            return f"{match.group(1)} ms" if match else "No Response"
        except NetworkManagerError:
            return "No Response"

    diagnostics["Gateway Latency"] = get_latency(diagnostics["Gateway"])
    diagnostics["External Latency"] = get_latency(external_target)

    return diagnostics

def get_raw_network_stats() -> dict:
    """Gets raw network traffic stats (bytes sent/received) for all interfaces."""
    try:
        stats_json = run_external_ps_script('Get-RawNetworkStats.ps1')
        stats_list = json.loads(stats_json)
        if isinstance(stats_list, dict):
            stats_list = [stats_list]
        return {
            stat['Name']: {'received': stat.get('ReceivedBytes') or 0, 'sent': stat.get('SentBytes') or 0}
            for stat in stats_list if isinstance(stat, dict) and 'Name' in stat
        }
    except (NetworkManagerError, json.JSONDecodeError) as e:
        logger.error("Failed to get raw network stats: %s", e)
        return {}

def get_active_connections() -> list[dict]:
    """Gets a list of active network connections using a single, efficient PowerShell command."""
    try:  # noqa: E501
        result_json = run_external_ps_script('Get-ActiveConnections.ps1')
        raw_data = json.loads(result_json)
        return raw_data if isinstance(raw_data, list) else ([
            raw_data] if raw_data else [])
    except (NetworkManagerError, json.JSONDecodeError) as e:
        logger.error("get_active_connections failed", exc_info=True)
        raise NetworkManagerError(
            f"Failed to get active connections via PowerShell: {e}") from e

def run_traceroute(target: str):
    """Runs a traceroute command and yields each line of output."""
    # Basic input validation to prevent command injection vulnerabilities.
    if not re.match(r"^[a-zA-Z0-9\.\-:]+$", target):
        raise NetworkManagerError(
            "Invalid target specified. Only hostnames and IP addresses are allowed.")

    # This PowerShell script streams the output of Test-NetConnection -TraceRoute
    # in a format similar to the classic tracert tool.
    ps_script = f"""
        $ProgressPreference = 'SilentlyContinue'
        Test-NetConnection -ComputerName '{target}' -TraceRoute
    """
    try:
        # We cannot use run_ps_command directly as it doesn't stream.
        # Instead, we use run_system_command's underlying Popen mechanism.
        # This is a special case where we need live output.
        for line in run_ps_command(ps_script, stream_output=True):
            yield line
    except NetworkManagerError as e:
        # Re-raise to propagate the error from the command execution.
        raise

================================================================================
FILE: logic/Get-ActiveConnections.ps1
================================================================================

# Get process names for PID lookup
$procs = @{}
Get-CimInstance Win32_Process | ForEach-Object { $procs[$_.ProcessId] = $_.Name }
$procs[0] = 'System Idle'
$procs[4] = 'System'

# Get TCP connections
$tcp = Get-NetTCPConnection | Select-Object @{N='Proto';E={'TCP'}},
                               @{N='Local';E={-join($_.LocalAddress,':',$_.LocalPort)}},
                               @{N='Foreign';E={-join($_.RemoteAddress,':',$_.RemotePort)}},
                               State,
                               @{N='PID';E={$_.OwningProcess}},
                               @{N='ProcessName';E={$procs[$_.OwningProcess]}}

# Get UDP endpoints
$udp = Get-NetUDPEndpoint | Select-Object @{N='Proto';E={'UDP'}},
                               @{N='Local';E={-join($_.LocalAddress,':',$_.LocalPort)}},
                               @{N='Foreign';E={'*:*'}},
                               @{N='State';E={'N/A'}},
                               @{N='PID';E={$_.OwningProcess}},
                               @{N='ProcessName';E={$procs[$_.OwningProcess]}}

# Combine and filter out connections without a PID (e.g., system-level)
($tcp + $udp) | Where-Object { $_.PID -ne $null } | ConvertTo-Json -Compress

================================================================================
FILE: logic/Get-AdapterDetails.ps1
================================================================================

<#
.SYNOPSIS
    Retrieves detailed information about all physical network adapters.

.DESCRIPTION
    This script queries the system for all physical network adapters using WMI/CIM.
    For each adapter, it gathers additional details like IP configuration and driver information.
    The final output is a JSON array of objects, each representing an adapter.

.OUTPUTS
    System.String
    A JSON formatted string containing the details of all physical network adapters.
    Returns an empty JSON array '[]' if no adapters are found.
#>

# Helper function to safely extract the first item from a property collection.
# This avoids errors if the property is null or empty, and reduces code repetition (DRY principle).
function Get-SafeProperty {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        $InputObject
    )
    # Select the first object from the pipeline, returning $null if the pipeline is empty.
    $InputObject | Select-Object -First 1
}

try {
    # Get-CimInstance is a modern and efficient way to query WMI.
    # We filter for physical adapters to exclude virtual ones.
    $physicalAdapters = Get-CimInstance -Class Win32_NetworkAdapter -Filter "PhysicalAdapter = TRUE" -ErrorAction Stop

    $adapterDetails = foreach ($adapter in $physicalAdapters) {
        try {
            # Find the corresponding NetAdapter to get more details.
            # If not found, an exception is thrown and caught, and we move to the next adapter.
            $netAdapter = Get-NetAdapter -InterfaceDescription $adapter.Description -ErrorAction Stop

            # Retrieve IP configuration and hardware info.
            # Using variables makes the code cleaner and easier to debug.
            # SilentlyContinue is used because a failure here should not stop processing the adapter.
            $ipConfig = $netAdapter | Get-NetIPConfiguration -All -ErrorAction SilentlyContinue
            if (-not $ipConfig) {
                Write-Warning "Could not retrieve IP configuration for adapter '$($netAdapter.Name)'."
            }

            $driverInfo = $netAdapter | Get-NetAdapterHardwareInfo -ErrorAction SilentlyContinue
            if (-not $driverInfo) {
                Write-Warning "Could not retrieve driver information for adapter '$($netAdapter.Name)'."
            }

            # Construct a custom object with the collected details.
            # Provide default null values for properties that might not exist to ensure consistent object structure.
            [PSCustomObject]@{
                Name                 = $netAdapter.Name
                InterfaceDescription = $adapter.Description
                MacAddress           = $adapter.MACAddress
                LinkSpeed            = $netAdapter.LinkSpeed
                NetConnectionStatus  = $adapter.NetConnectionStatus
                IPv4Address          = $ipConfig.IPv4Address.IPAddress | Get-SafeProperty
                IPv6Address          = $ipConfig.IPv6Address.IPAddress | Get-SafeProperty
                DriverVersion        = $driverInfo.DriverVersion | Get-SafeProperty
                DriverDate           = $driverInfo.DriverDate | Get-SafeProperty
            }
        }
        catch {
            # Log or handle the error if a specific adapter's details can't be retrieved.
            # For now, we just continue to the next adapter silently.
            Write-Warning "Could not retrieve full details for adapter with description: $($adapter.Description). Error: $($_.Exception.Message)"
        }
    }

    # Convert the final array of objects to a compressed JSON string.
    # The -Depth parameter ensures that nested objects are fully serialized.
    $adapterDetails | ConvertTo-Json -Compress -Depth 3
}
catch {
    # If the initial query for adapters fails, output an empty JSON array.
    Write-Error "Failed to retrieve network adapters. Error: $($_.Exception.Message)"
    "[]" | ConvertTo-Json
}

================================================================================
FILE: logic/Get-NetworkDiagnostics.ps1
================================================================================

# Get public IP
$publicIp = try { (Invoke-RestMethod -Uri 'https://api.ipify.org' -TimeoutSec 1) } catch { "Error" }

# Get network configuration details for the primary adapter
$netConfig = Get-NetIPConfiguration | Select-Object -First 1
# Extract the actual IP address string from the gateway object
$gatewayIp = $netConfig.IPv4DefaultGateway.NextHop
# Extract the IP addresses from the DNS server objects and join them into a single string
$dnsServerIps = ($netConfig.DNSServer.ServerAddresses | Where-Object {$_}) -join ', '

# Ping gateway and external target
$gatewayLatency = "N/A"
if ($gatewayIp) {
    # Force an ICMP ping test for accurate latency measurement.
    $pingTest = Test-NetConnection -ComputerName $gatewayIp -ConstrainInterface $netConfig.InterfaceIndex -ErrorAction SilentlyContinue
    if ($pingTest.PingSucceeded) {
        $gatewayLatency = "$($pingTest.PingReplyDetails.RoundtripTime) ms"
    } else {
        $gatewayLatency = "No Response"
    }
}

$externalLatency = "N/A"
if ($external_target) {
    # First, try a standard ICMP ping to get accurate latency.
    $pingTest = Test-NetConnection -ComputerName $external_target -ConstrainInterface $netConfig.InterfaceIndex -ErrorAction SilentlyContinue
    if ($pingTest.PingSucceeded) {
        $externalLatency = "$($pingTest.PingReplyDetails.RoundtripTime) ms"
    } else {
        $externalLatency = "No Response"
    }
}

# Construct the result object
[PSCustomObject]@{
    "Public IP"        = $publicIp
    "Gateway"          = $gatewayIp
    "Gateway Latency"  = $gatewayLatency
    "External Latency" = $externalLatency
    "DNS Servers"      = $dnsServerIps
} | ConvertTo-Json -Compress

================================================================================
FILE: logic/Get-RawNetworkStats.ps1
================================================================================

Get-NetAdapter -IncludeHidden | ForEach-Object {
  $stats = Get-NetAdapterStatistics -Name $_.Name -ErrorAction SilentlyContinue;
  [PSCustomObject]@{
    Name = $_.Name;
    ReceivedBytes = $stats.ReceivedBytes;
    SentBytes = $stats.SentBytes
  }
} | ConvertTo-Json -Compress

================================================================================
FILE: logic/system.py
================================================================================

import ctypes
import logging
import sys
import os

from exceptions import NetworkManagerError
from .command_utils import run_system_command, _safe_decode

logger = logging.getLogger(__name__)

def is_admin() -> bool:
    """Check if the script is running with administrative privileges on Windows."""
    if sys.platform != "win32":
        return False

    try:
        # Returns non-zero if admin, 0 if not.
        return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except AttributeError:
        return False

def relaunch_as_admin():
    """
    Relaunches the current script with administrative privileges using the
    'runas' verb. The current script will exit after calling this.
    """
    ctypes.windll.shell32.ShellExecuteW(
        None,           # Handle to the parent window
        "runas",        # Verb: run as administrator
        sys.executable, # The Python interpreter
        " ".join(sys.argv), # The script and its arguments
        None,           # Working directory
        1               # Show the window (SW_SHOWNORMAL)
    )

def reset_network_stack():
    """
    Resets the Winsock Catalog using 'netsh winsock reset'. This action
    requires a system reboot to complete. Raises NetworkManagerError on
    failure.
    """
    run_system_command(['netsh', 'winsock', 'reset'], "Failed to reset network stack.")

def flush_dns_cache():
    """
    Flushes the DNS resolver cache using 'ipconfig /flushdns'.
    Raises NetworkManagerError on failure.
    """
    run_system_command(['ipconfig', '/flushdns'], "Failed to flush DNS cache.")

def release_renew_ip():
    """
    Releases and renews the IP address for all adapters.
    Raises NetworkManagerError on failure.
    """
    try:
        # Step 1: Release the current IP address.
        # We use check=False because this command can fail gracefully if an adapter
        # is disconnected or has no IP, which is not a critical error.
        release_result = run_system_command(
            ['ipconfig', '/release'], "IP address release command finished.", check=False)
        if release_result.returncode != 0:
            # Decode output safely for inspection. The error is often in stderr.
            error_output = _safe_decode(
                release_result.stderr or release_result.stdout).lower()
            
            # These are common, expected "errors" that we can safely ignore.
            non_critical_errors = [
                "no operation can be performed",  # Adapter is disconnected
                "media is disconnected",  # Cable is unplugged
                "the system cannot find the file specified"  # Can occur in some virtual adapter scenarios
            ]
            if any(e in error_output for e in non_critical_errors):
                logger.info(
                    "ipconfig /release failed as expected (no address to release or media disconnected).")
            else:
                # Log any other non-zero exit codes as a warning, but don't stop the process.
                logger.warning(
                    "ipconfig /release finished with an unexpected non-zero exit code. Error: %s", error_output.strip())

        # Step 2: Renew the IP address. This is the critical step.
        run_system_command(['ipconfig', '/renew'], "Failed to renew IP address.")

    except NetworkManagerError as e:
        # Step 3: Handle specific, known errors from the 'renew' step to provide better user feedback.
        error_str = str(e).lower()
        if "unable to contact your dhcp server" in error_str:
            raise NetworkManagerError(
                "Could not renew IP address: Unable to contact the DHCP server. Please check your network connection and router.",  # noqa: E501
                code='DHCP_SERVER_UNREACHABLE'
            ) from e
        if "no adapter is in the state permissible" in error_str:
            raise NetworkManagerError(
                "Could not renew IP address: One or more network adapters are disabled. Please enable them first.",  # noqa: E501
                code='ADAPTER_DISABLED'
            ) from e
        raise # Re-raise the original, detailed exception for any other errors

def terminate_process_by_pid(pid: int):
    """
    Terminates a process by its Process ID (PID).
    Raises NetworkManagerError on failure.
    """
    if pid in [0, 4]:  # Do not allow terminating System Idle or System processes
        raise NetworkManagerError(
            "Terminating system-critical processes is not allowed.")
    try:
        run_system_command(['taskkill', '/F', '/T', '/PID', str(
            pid)], f"Failed to terminate process with PID {pid}.")
    except NetworkManagerError:
        # Re-raise to keep the original detailed message from the helper.
        raise

================================================================================
FILE: logic/wifi.py
================================================================================

import re
import json
import logging

from exceptions import NetworkManagerError
from .command_utils import run_system_command, run_ps_command

logger = logging.getLogger(__name__)

def list_wifi_networks() -> list[dict]:
    """Lists available Wi-Fi networks."""
    try:
        command = ['netsh', 'wlan', 'show', 'networks', 'mode=Bssid']
        netsh_output = run_system_command(
            command, "Failed to list Wi-Fi networks").stdout.decode('oem', errors='ignore')
        return _parse_netsh_wlan_output(netsh_output)
    except NetworkManagerError as e:
        if "no wireless interface" in str(e).lower():
            logger.warning("No wireless interface found while listing networks.")
            return []
        if "location permission" in str(e).lower():
            raise NetworkManagerError(
                "Location services must be enabled to scan for Wi-Fi networks.",
                code='LOCATION_PERMISSION_DENIED'
            ) from e
        raise

def _parse_netsh_wlan_output(output: str) -> list[dict]:
    """Parses the output of 'netsh wlan show networks mode=bssid' command. This
    version uses a single, more efficient regex to parse network blocks.
    """
    networks = []
    seen_ssids = set()

    # This regex captures all relevant details for each SSID block in one go.
    # It looks for SSID, Authentication, Encryption, and the first Signal strength found.
    pattern = re.compile(
        r"SSID \d+ : (.*?)\n"  # Capture SSID (non-greedy, can be empty)
        r".*?Authentication\s+: (.+?)\n"  # Capture Authentication
        r".*?Encryption\s+: (.+?)\n"  # Capture Encryption
        r"(?:.*?Signal\s+: (\d+)%)?",  # Optionally capture Signal
        re.DOTALL
    )

    for match in pattern.finditer(output):
        ssid, auth, enc, signal = (m.strip() if m else None for m in match.groups())

        # If SSID is empty or None, treat it as a hidden network.
        display_ssid = ssid if ssid else "(Hidden Network)"

        if display_ssid in seen_ssids:
            continue  # Skip if SSID is missing or already processed

        seen_ssids.add(display_ssid)
        networks.append({
            'ssid': display_ssid,
            'authentication': auth or "N/A",
            'encryption': enc or "N/A",
            'signal': signal or "N/A"
        })

    return networks

def get_current_wifi_details() -> dict | None:
    """Gets details of the current Wi-Fi connection."""
    logger.info("Entering get_current_wifi_details...")  # noqa: E501
    # This PowerShell script is more efficient and reliable than parsing netsh and
    # ipconfig output. It gets the active Wi-Fi adapter and its associated IP
    # configuration in one go.
    ps_script = """
        $wifi = Get-NetAdapter -Physical | Where-Object { $_.InterfaceDescription -notlike "*Virtual*" -and $_.MediaType -eq "Native 802.11" -and $_.Status -eq "Up" } | Select-Object -First 1  # noqa: E501
        if ($null -eq $wifi) { exit }

        $ipConfig = $wifi | Get-NetIPConfiguration -Detailed
        $ssidInfo = netsh.exe wlan show interfaces | Select-String -Pattern "SSID", "Signal"

        $result = @{
            interface_name = $wifi.Name
            ssid = ($ssidInfo | Where-Object { $_.Line -like "*SSID*" } | ForEach-Object { ($_.Line -split ':', 2)[1].Trim() }) -join ""  # noqa: E501
            signal = ($ssidInfo | Where-Object { $_.Line -like "*Signal*" } | ForEach-Object { ($_.Line -split ':', 2)[1].Trim() }) -join ""  # noqa: E501
            ipv4 = ($ipConfig.IPv4Address.IPAddress | Select-Object -First 1)
        }
        $result | ConvertTo-Json
    """
    try:
        result_json = run_ps_command(ps_script)
        return json.loads(result_json) if result_json else None
    except (NetworkManagerError, json.JSONDecodeError):
        return None

def disconnect_wifi():
    """Disconnects from the current Wi-Fi network."""
    try:
        run_system_command(
            ['netsh', 'wlan', 'disconnect'], "Failed to disconnect from Wi-Fi.")
    except NetworkManagerError as e:
        # It's not a critical error if the command fails because we're already
        # disconnected. We can log this for debugging but don't need to raise an
        # exception.
        error_str = str(e).lower()
        if "not connected" in error_str or "ei ole yhteydessä" in error_str:
            logger.info(
                "Attempted to disconnect, but no active Wi-Fi connection was found.")
        else:
            raise # Re-raise any other unexpected errors.

def get_saved_wifi_profiles() -> list[dict]:
    """Gets saved Wi-Fi profiles and their passwords."""
    # This PowerShell script is significantly faster than calling 'netsh' for each
    # profile in a loop. It gets all profiles and then extracts the key from each
    # profile's XML content.
    ps_script = r"""
        $profiles = (netsh.exe wlan show profiles) | Select-String "All User Profile" | ForEach-Object { $_.Line.Split(':', 2)[1].Trim() }  # noqa: E501

        $result = foreach ($p in $profiles) {
            try {
                $profileXml = [xml](netsh.exe wlan show profile name="$p" key=clear)
                $password = $profileXml.WLANProfile.MSM.security.sharedKey.keyMaterial
                [PSCustomObject]@{
                    ssid     = $p
                    password = if ($password) { $password } else { "N/A" }
                }
            } catch {
                # This can happen if we don't have permissions for a profile or it has no key  # noqa: E501
                [PSCustomObject]@{
                    ssid     = $p
                    password = "(Password not stored or accessible)"  # noqa: E501
                }
            }
        }
        $result | ConvertTo-Json -Compress
    """
    try:
        result_json = run_ps_command(ps_script)
        return json.loads(result_json) if result_json else []
    except (NetworkManagerError, json.JSONDecodeError) as e:
        logger.error(
            "Failed to get saved Wi-Fi profiles via PowerShell.", exc_info=True)
        raise NetworkManagerError(
            f"Could not retrieve saved Wi-Fi profiles: {e}") from e

================================================================================
FILE: logic/wifi_profile_manager.py
================================================================================

import tempfile
import os
import logging

from exceptions import NetworkManagerError
from .command_utils import run_system_command

logger = logging.getLogger(__name__)

def _create_wlan_profile_xml(ssid: str, authentication: str, encryption: str, password: str | None) -> str:
    """
    Generates the XML content for a WLAN profile based on security settings.
    """
    # Map netsh output to WLAN profile XML values
    auth_map = {
        "WPA2-Personal": "WPA2PSK",
        "WPA3-Personal": "WPA3SAE",
        "WPA-Personal": "WPAPSK",
        "Open": "open",
        "WEP": "open"  # WEP uses 'open' for auth and key is handled separately
    }
    # Default to AES for modern standards, TKIP for legacy, or none for open
    enc_map = {"CCMP": "AES", "TKIP": "TKIP", "None": "none", "WEP": "WEP"}

    auth_xml = auth_map.get(authentication, "WPA2PSK")  # Default to WPA2PSK if unknown
    enc_xml = enc_map.get(encryption, "AES")

    if password:
        # WEP uses a different key structure
        key_type = "networkKey" if auth_xml == "open" and enc_xml == "WEP" else "passPhrase"
        key_material_xml = f"<sharedKey><keyType>{key_type}</keyType><protected>false</protected><keyMaterial>{password}</keyMaterial></sharedKey>"  # noqa: E501
    else:
        # Ensure settings are correct for an open network
        auth_xml = "open"
        enc_xml = "none"
        key_material_xml = ""

    return f"""<?xml version="1.0"?>  # noqa: E501
<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
    <name>{ssid}</name>
    <SSIDConfig><SSID><name>{ssid}</name></SSID></SSIDConfig>
    <connectionType>ESS</connectionType>
    <connectionMode>auto</connectionMode>
    <MSM><security>
        <authEncryption><authentication>{auth_xml}</authentication><encryption>{enc_xml}</encryption><useOneX>false</useOneX></authEncryption>
        {key_material_xml}
    </security></MSM>
</WLANProfile>"""

def connect_to_wifi_network(ssid: str, authentication: str, encryption: str, password: str | None = None):
    """Connects to a Wi-Fi network by dynamically creating a profile based on
    security settings."""
    profile_xml = _create_wlan_profile_xml(ssid, authentication, encryption, password)

    try:
        with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.xml', encoding='utf-8') as tmpfile:
            tmpfile.write(profile_xml)
            profile_path = tmpfile.name
        add_command = ['netsh', 'wlan', 'add', 'profile', f'filename="{profile_path}"']
        run_system_command(
            add_command, f"Failed to add Wi-Fi profile for {ssid}")
        connect_with_profile_name(ssid)
    except NetworkManagerError as e:
        raise NetworkManagerError(
            f"Failed to create profile or connect to '{ssid}':\n{e}") from e
    finally:
        if 'profile_path' in locals() and profile_path and os.path.exists(profile_path):
            os.remove(profile_path)

def connect_with_profile_name(profile_name: str):
    """Connects to a Wi-Fi network using a saved profile name."""
    try:
        connect_cmd = ['netsh', 'wlan', 'connect', f'name="{profile_name}"']
        run_system_command(
            connect_cmd, f"Failed to connect using profile {profile_name}")
    except NetworkManagerError as e:
        error_str = str(e).lower()
        if "the network security key is not correct" in error_str:
            raise NetworkManagerError(f"Connection to '{profile_name}' failed: The password is incorrect.",  # noqa: E501
                                      code='WIFI_INVALID_KEY'
                                      ) from e
        # Add more specific checks here as they are discovered
        raise e  # Re-raise the original exception if no specific error is matched

def delete_wifi_profile(profile_name: str):
    """Deletes a saved Wi-Fi profile."""
    delete_cmd = ['netsh', 'wlan', 'delete', 'profile', f'name="{profile_name}"']
    run_system_command(
        delete_cmd, f"Failed to delete profile {profile_name}")

================================================================================
FILE: logic/__init__.py
================================================================================



================================================================================
FILE: tests/conftest.py
================================================================================

import pytest
import tkinter as tk

@pytest.fixture(scope="session")
def tk_root():
    """
    Provides a single, shared, hidden Tkinter root window for the entire
    test session.

    This avoids creating a new root window for every test that needs one,
    which is slow and can cause issues in some environments. It also prevents
    TclErrors in CI/CD pipelines by keeping the window withdrawn.
    """
    root = tk.Tk()
    root.withdraw()  # Hide the window
    yield root
    root.destroy()

================================================================================
FILE: tests/test_adapters.py
================================================================================

import unittest
from unittest.mock import patch
import json

from logic.adapters import (get_adapter_details, set_network_adapter_status_windows,
                            disconnect_wifi_and_disable_adapter)
from exceptions import NetworkManagerError

class TestSetAdapterStatus(unittest.TestCase):
    """
    Unit tests for the set_network_adapter_status_windows function.
    """

    @patch('logic.adapters.run_ps_command')
    def test_setNetworkAdapterStatus_whenActionIsEnable_shouldCallEnableNetAdapter(
            self, mock_run_ps_command):
        """Test a successful call to enable an adapter."""
        # Arrange
        adapter_name = "Wi-Fi"
        action = "enable"
        expected_script = f"Enable-NetAdapter -Name '{adapter_name}' -Confirm:$false"

        # Act
        set_network_adapter_status_windows(adapter_name, action)

        # Assert
        mock_run_ps_command.assert_called_once_with(expected_script)

    @patch('logic.adapters.run_ps_command')
    def test_setNetworkAdapterStatus_whenActionIsDisable_shouldCallDisableNetAdapter(
            self, mock_run_ps_command):
        """Test a successful call to disable an adapter."""
        # Arrange
        adapter_name = "Ethernet"
        action = "disable"
        expected_script = f"Disable-NetAdapter -Name '{adapter_name}' -Confirm:$false"

        # Act
        set_network_adapter_status_windows(adapter_name, action)

        # Assert
        mock_run_ps_command.assert_called_once_with(expected_script)

    def test_setNetworkAdapterStatus_withInvalidAction_shouldRaiseValueError(self):
        """Test that an invalid action string raises a ValueError."""
        with self.assertRaises(ValueError):
            set_network_adapter_status_windows("Wi-Fi", "destroy")

    @patch('logic.adapters.run_ps_command')
    def test_setNetworkAdapterStatus_whenAdapterIsAlreadyInState_shouldRaiseNetworkManagerError(
            self, mock_run_ps_command):
        """Test handling of the 'already in state' error from PowerShell."""
        # Arrange
        error_message = "The object is already in the state 'Enabled'."
        mock_run_ps_command.side_effect = NetworkManagerError(error_message)

        # Act & Assert
        with self.assertRaises(NetworkManagerError) as cm:
            set_network_adapter_status_windows("Wi-Fi", "enable")
        
        self.assertIn("Adapter 'Wi-Fi' is already enabled", str(cm.exception))

    @patch('logic.adapters.run_ps_command')
    def test_setNetworkAdapterStatus_whenDisablingConnectedWifi_shouldRaiseSpecificError(
            self, mock_run_ps_command):
        """Test handling of the 'cannot be disabled' error when connected."""
        # Arrange
        error_message = "The adapter cannot be disabled while it is connected."
        mock_run_ps_command.side_effect = NetworkManagerError(error_message)

        # Act & Assert
        with self.assertRaises(NetworkManagerError) as cm:
            set_network_adapter_status_windows("Wi-Fi", "disable")
        
        self.assertEqual(cm.exception.code, 'WIFI_CONNECTED_DISABLE_FAILED')
        self.assertIn("Cannot disable 'Wi-Fi' while it is connected", str(cm.exception))

    @patch('logic.adapters.run_ps_command')
    def test_setNetworkAdapterStatus_onGenericError_shouldWrapExceptionWithContext(
            self, mock_run_ps_command):
        """Test that a generic NetworkManagerError is wrapped with more context."""
        # Arrange
        original_error = NetworkManagerError("A generic PowerShell error occurred.")
        mock_run_ps_command.side_effect = original_error

        # Act & Assert
        with self.assertRaises(NetworkManagerError) as cm:
            set_network_adapter_status_windows("Wi-Fi", "disable")
        
        # Check that the new exception message contains the action and adapter name
        self.assertIn("Failed to disable adapter 'Wi-Fi'", str(cm.exception))
        # Check that the original exception is chained
        self.assertIs(cm.exception.__cause__, original_error)

class TestGetAdapterDetails(unittest.TestCase):
    """
    Unit tests for the get_adapter_details function, focusing on JSON parsing.
    """

    @patch('logic.adapters.run_external_ps_script')
    def test_getAdapterDetails_withValidJsonList_shouldParseAndReturnList(
            self, mock_run_script):
        """Test successful parsing of a JSON list of adapters."""
        # Arrange
        mock_data = [
            {'Name': 'Wi-Fi', 'NetConnectionStatus': 2}, # Enabled
            {'Name': 'Ethernet', 'NetConnectionStatus': 4} # Disabled
        ]
        mock_run_script.return_value = json.dumps(mock_data)

        # Act
        result = get_adapter_details()

        # Assert
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]['admin_state'], 'Enabled')
        self.assertEqual(result[1]['admin_state'], 'Disabled')

    @patch('logic.adapters.run_external_ps_script')
    def test_getAdapterDetails_withInvalidJson_shouldRaiseNetworkManagerError(
            self, mock_run_script):
        """Test that invalid JSON from PowerShell raises a NetworkManagerError."""
        # Arrange
        mock_run_script.return_value = "This is not valid JSON"

        # Act & Assert
        with self.assertRaises(NetworkManagerError) as cm:
            get_adapter_details()
        
        self.assertIn("Failed to parse adapter details", str(cm.exception))


class TestDisconnectAndDisable(unittest.TestCase):
    """
    Unit tests for the disconnect_wifi_and_disable_adapter workflow.
    """

    @patch('logic.adapters.set_network_adapter_status_windows')
    @patch('logic.adapters.get_current_wifi_details')
    @patch('logic.adapters.disconnect_wifi')
    @patch('time.sleep')
    def test_disconnectAndDisable_onSuccess_shouldCompleteAllSteps(
            self, mock_sleep, mock_disconnect, mock_get_details, mock_set_status):
        """Test the ideal success case where disconnect is confirmed quickly."""
        # Arrange: Simulate that after one check, the connection is gone.
        mock_get_details.side_effect = [{'ssid': 'Test'}, None]
        adapter_name = "Wi-Fi"

        # Act
        result_generator = disconnect_wifi_and_disable_adapter(adapter_name)
        messages = list(result_generator)

        # Assert
        self.assertEqual(mock_disconnect.call_count, 1)
        self.assertLessEqual(mock_get_details.call_count, 2) # Should be 2 calls
        mock_set_status.assert_called_once_with(adapter_name, 'disable')
        self.assertIn("Successfully disabled 'Wi-Fi'.", messages)

    @patch('logic.adapters.get_current_wifi_details')
    @patch('logic.adapters.disconnect_wifi')
    @patch('time.sleep')
    def test_disconnectAndDisable_whenDisconnectTimesOut_shouldRaiseError(
            self, mock_sleep, mock_disconnect, mock_get_details):
        """Test that an error is raised if disconnection is not confirmed in time."""
        # Arrange: Simulate that the connection never drops.
        mock_get_details.return_value = {'ssid': 'Test'}

        # Act & Assert
        with self.assertRaisesRegex(NetworkManagerError, "Failed to confirm Wi-Fi disconnection"):
            list(disconnect_wifi_and_disable_adapter("Wi-Fi"))

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_app_context.py
================================================================================

import unittest
from unittest.mock import Mock, patch

from gui.app_context import AppContext
from gui.main_controller import MainController
from gui.action_handler import ActionHandler

class TestAppContext(unittest.TestCase):
    """Tests for the AppContext class."""

    def setUp(self):
        """Set up a fresh AppContext for each test."""
        self.context = AppContext()

    def test_initialization(self):
        """Test that components are initialized as expected."""
        self.assertIsNotNone(self.context.task_queue)
        self.assertIsInstance(self.context.main_controller, MainController)
        self.assertIsInstance(self.context.action_handler, ActionHandler)
        self.assertIsNone(self.context.queue_handler)
        self.assertIsNone(self.context.polling_manager)

    @patch('gui.app_context.QueueHandler')
    @patch('gui.app_context.PollingManager')
    def test_initialize_components(self, mock_polling_manager, mock_queue_handler):
        """Test that UI-dependent components are initialized correctly."""
        mock_root = Mock()
        mock_status_var = Mock()
        mock_ui_frames = {'diagnostics': Mock()}

        self.context.initialize_components(mock_root, mock_ui_frames, mock_status_var)

        self.assertIs(self.context.root, mock_root)
        mock_queue_handler.assert_called_once_with(context=self.context, ui_frames=mock_ui_frames)
        mock_polling_manager.assert_called_once_with(self.context)

    def test_window_registration(self):
        """Test that window registration and unregistration works."""
        mock_window = Mock()
        mock_window.__class__.__name__ = "TestWindow"

        self.context.register_window(mock_window)
        self.assertIn("TestWindow", self.context.open_windows)
        self.assertIs(self.context.open_windows["TestWindow"], mock_window)

        self.context.unregister_window(mock_window)
        self.assertNotIn("TestWindow", self.context.open_windows)

    def test_get_ping_target(self):
        """Test that get_ping_target returns the correct value."""
        # Case 1: diagnostics_frame is not initialized (should return default)
        self.assertEqual(self.context.get_ping_target(), "8.8.8.8")

        # Case 2: diagnostics_frame is initialized and returns a value
        self.context.diagnostics_frame = Mock()
        self.context.diagnostics_frame.get_ping_target.return_value = "1.1.1.1"
        self.assertEqual(self.context.get_ping_target(), "1.1.1.1")

    def test_get_app_version(self):
        """Test that get_app_version returns a string."""
        # This test mainly ensures the method is called and doesn't crash.
        # We can patch the constant it reads to be more specific if needed.
        with patch('gui.app_context.APP_VERSION', '1.2.3-test'):
            self.assertEqual(self.context.get_app_version(), '1.2.3-test')

    def test_unregister_non_existent_window(self):
        """Test that unregistering a window that isn't registered doesn't raise an error."""
        mock_window = Mock(__class__=Mock(__name__="NonExistentWindow"))
        # This should execute without raising an exception.
        self.context.unregister_window(mock_window)

================================================================================
FILE: tests/test_command_utils.py
================================================================================

import unittest
from unittest.mock import patch, MagicMock
import subprocess

from logic.command_utils import (_safe_decode, run_system_command, run_ps_command,
                                 run_external_ps_script)
from exceptions import NetworkManagerError

class TestSafeDecode(unittest.TestCase):
    """Tests for the _safe_decode utility function."""

    def test_decode_utf8(self):
        self.assertEqual(_safe_decode(b'hello'), 'hello')

    def test_decode_oem(self):
        # Simulate a common OEM character like 'ä'
        self.assertEqual(_safe_decode(b'\x84'), 'ä')

    @patch('logic.command_utils._decode_with_encoding')
    def test_decode_fallback_to_ascii_ignore(self, mock_decode_with_encoding):
        """Test that the final ascii fallback is used if both utf-8 and oem fail."""
        # Arrange: Make the first two decode attempts (utf-8, oem) fail,
        # and the final one (ascii) succeed.
        mock_decode_with_encoding.side_effect = [
            UnicodeDecodeError('mock', b'', 0, 1, 'mock reason'), # Fails for 'utf-8'
            UnicodeDecodeError('mock', b'', 0, 1, 'mock reason'), # Fails for 'oem'
            '????' # The result of the ascii decode with replacement
        ]
        # Act & Assert
        self.assertEqual(_safe_decode(b'\xde\xad\xbe\xef'), '????')

    def test_decode_none_or_empty(self):
        """Test that None or empty bytes are handled correctly."""
        self.assertEqual(_safe_decode(None), '')
        self.assertEqual(_safe_decode(b''), '')

class TestRunSystemCommand(unittest.TestCase):
    """Tests for the run_system_command function."""

    @patch('logic.command_utils.subprocess.Popen')
    def test_command_success(self, mock_popen):
        """Test a successful command execution."""
        mock_process = MagicMock()
        mock_process.returncode = 0
        mock_process.communicate.return_value = (b'success output', b'')
        mock_popen.return_value.__enter__.return_value = mock_process

        result = run_system_command(["echo", "hello"], "Test success")

        self.assertEqual(result.returncode, 0)
        self.assertEqual(result.stdout, b'success output')

    @patch('logic.command_utils.subprocess.Popen')
    def test_command_timeout(self, mock_popen):
        """Test that a TimeoutExpired exception is caught and wrapped."""
        mock_process = MagicMock()
        mock_process.communicate.side_effect = subprocess.TimeoutExpired(cmd="ping", timeout=10)
        mock_popen.return_value.__enter__.return_value = mock_process

        with self.assertRaisesRegex(NetworkManagerError, "The operation timed out"):
            run_system_command(["ping"], "Test ping")

    @patch('logic.command_utils.subprocess.Popen')
    def test_command_file_not_found(self, mock_popen):
        """Test that a FileNotFoundError is caught and wrapped."""
        mock_popen.side_effect = FileNotFoundError

        with self.assertRaisesRegex(NetworkManagerError, "Command 'nonexistent' not found"):
            run_system_command(["nonexistent"], "Test")

    @patch('logic.command_utils.subprocess.Popen')
    def test_command_failure_with_stderr(self, mock_popen):
        """Test that a command failure with stderr raises a formatted error."""
        mock_process = MagicMock()
        mock_process.returncode = 1
        mock_process.communicate.return_value = (b'some output', b'error details')
        mock_popen.return_value.__enter__.return_value = mock_process

        with self.assertRaises(NetworkManagerError) as cm:
            run_system_command(["failing_cmd"], "Test failure")

        # The user-facing error should prioritize stderr
        self.assertIn("Test failure: error details", str(cm.exception))

    @patch('logic.command_utils.subprocess.Popen')
    def test_command_failure_without_stderr(self, mock_popen):
        """Test that a command failure without stderr falls back to a generic message."""
        mock_process = MagicMock()
        mock_process.returncode = 1
        # Simulate no output on stdout or stderr
        mock_process.communicate.return_value = (b'', b'')
        mock_popen.return_value.__enter__.return_value = mock_process

        with self.assertRaises(NetworkManagerError) as cm:
            run_system_command(["failing_cmd"], "Test failure")

        self.assertIn("An unknown error occurred.", str(cm.exception))

    @patch('logic.command_utils.subprocess.Popen')
    def test_command_failure_with_encoded_command_logging(self, mock_popen):
        """Test that EncodedCommand is not fully logged."""
        mock_process = MagicMock()
        mock_process.returncode = 1
        mock_process.communicate.return_value = (b'', b'error')
        mock_popen.return_value.__enter__.return_value = mock_process

        with self.assertLogs('logic.command_utils', level='DEBUG') as cm, \
             self.assertRaises(NetworkManagerError):
            run_system_command(["powershell", "-EncodedCommand", "longbase64string"], "Test failure")
        
        # Check that the logged command was shortened
        self.assertIn("Executing system command: powershell -EncodedCommand <...>",
                      cm.output[0])
        # Check that the full error is still logged
        self.assertIn("longbase64string", cm.output[1])

class TestRunPsCommand(unittest.TestCase):
    """Tests for PowerShell command runners."""

    @patch('logic.command_utils.run_system_command')
    def test_run_ps_command_success(self, mock_run_system):
        """Test a successful PowerShell command execution."""
        mock_run_system.return_value.stdout = b'Success'
        result = run_ps_command("Get-Process")
        self.assertEqual(result, "Success")
        self.assertIn("-EncodedCommand", mock_run_system.call_args[0][0])

    @patch('logic.command_utils.run_system_command', side_effect=NetworkManagerError("PS Error"))
    def test_run_ps_command_failure(self, mock_run_system):
        """Test that an error from run_system_command is propagated."""
        with self.assertRaisesRegex(NetworkManagerError, "PS Error"):
            run_ps_command("Get-Process")

    @patch('logic.command_utils.open', new_callable=unittest.mock.mock_open, read_data='Get-Host')
    @patch('logic.command_utils.run_ps_command')
    def test_run_external_ps_script_success(self, mock_run_ps, mock_open):
        """Test running an external script file successfully."""
        run_external_ps_script("test_script.ps1")
        mock_open.assert_called_once()
        mock_run_ps.assert_called_with('Get-Host')

    @patch('logic.command_utils.open', new_callable=unittest.mock.mock_open, read_data='Get-Host')
    @patch('logic.command_utils.run_ps_command')
    def test_run_external_ps_script_with_args(self, mock_run_ps, mock_open):
        """Test running an external script with arguments."""
        run_external_ps_script("test_script.ps1", ps_args=["$var=1"])
        # Check that the arguments are prepended to the script content
        expected_script_content = "$var=1;\nGet-Host"
        mock_run_ps.assert_called_with(expected_script_content)

    @patch('logic.command_utils.os.path.dirname', return_value='/fake/dir')
    @patch('logic.command_utils.open')
    def test_run_external_ps_script_file_not_found(self, mock_open, mock_dirname):
        """Test that a FileNotFoundError for the script file is wrapped."""
        mock_open.side_effect = FileNotFoundError
        with self.assertRaisesRegex(NetworkManagerError, "PowerShell script 'test.ps1' not found"):
            run_external_ps_script("test.ps1")

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_constants.py
================================================================================

import unittest
from unittest.mock import patch

class TestConstants(unittest.TestCase):
    """Tests for the constants module."""

    @patch('pathlib.Path.read_text', side_effect=FileNotFoundError)
    def test_read_version_file_not_found(self, mock_read_text):
        """
        Test that _read_version returns a default version string when
        the VERSION file is not found.
        """
        # We need to reload the module to re-trigger the _read_version function
        from gui import constants
        import importlib
        importlib.reload(constants)
        
        self.assertEqual(constants.APP_VERSION, "0.0.0-dev")

================================================================================
FILE: tests/test_diagnostics.py
================================================================================

import unittest
from unittest.mock import patch, MagicMock, call
import io
import json

import requests
from logic.diagnostics import run_traceroute, get_network_diagnostics, get_raw_network_stats, get_active_connections
from exceptions import NetworkManagerError

class TestTraceroute(unittest.TestCase):
    """
    Unit tests for the run_traceroute function.
    """

    @patch('logic.diagnostics.run_ps_command')
    def test_run_traceroute_success(self, mock_run_ps_command):
        """Test a successful traceroute execution, yielding each line."""
        # Arrange: Simulate the generator output from the PowerShell command.
        expected = [
            "Tracing route to 8.8.8.8",
            "  1    <1 ms    <1 ms    <1 ms  192.168.1.1",
            "  2     *        *        *     Request timed out.",
            "Trace complete."
        ]
        mock_run_ps_command.return_value = iter(expected)

        # Act: Collect the yielded lines from the function.
        result = list(run_traceroute("8.8.8.8"))

        # Assert
        self.assertEqual(result, expected)
        mock_run_ps_command.assert_called_once()
        self.assertIn("Test-NetConnection -ComputerName '8.8.8.8' -TraceRoute",  # noqa: E501
                      mock_run_ps_command.call_args[0][0])  # noqa: E501

    def test_run_traceroute_invalid_target(self):
        """Test that an invalid target raises a NetworkManagerError."""
        # Arrange: An invalid target string with special characters.
        invalid_target = "8.8.8.8; rm -rf /"

        # Act & Assert: Check that the correct exception is raised.
        with self.assertRaises(NetworkManagerError) as cm:
            # We need to consume the generator to trigger the exception.
            list(run_traceroute(invalid_target))
        
        self.assertIn("Invalid target specified", str(cm.exception))

    @patch('logic.diagnostics.run_ps_command')
    def test_run_traceroute_command_error(self, mock_run_ps_command):
        """Test that a NetworkManagerError from the command is propagated."""
        # Arrange: Configure the mock to raise NetworkManagerError.
        mock_run_ps_command.side_effect = NetworkManagerError("PowerShell execution failed.")

        # Act & Assert
        with self.assertRaises(NetworkManagerError) as cm:
            list(run_traceroute("8.8.8.8"))
        
        self.assertIn("PowerShell execution failed", str(cm.exception))

class TestDiagnosticsJsonParsing(unittest.TestCase):
    """
    Unit tests for JSON parsing in the diagnostics module.
    """

    @patch('logic.diagnostics.run_external_ps_script')
    def test_get_active_connections_invalid_json(self, mock_run_script):
        """Test that get_active_connections raises an error on invalid JSON."""
        mock_run_script.return_value = "{not-json"
        # Check that an error is logged and the correct exception is raised.
        with self.assertLogs('logic.diagnostics', level='ERROR'), self.assertRaises(NetworkManagerError):
            get_active_connections() # type: ignore

    @patch('logic.diagnostics.run_external_ps_script')
    def test_get_raw_network_stats_invalid_json(self, mock_run_script):
        """Test that get_raw_network_stats returns an empty dict on invalid JSON."""
        mock_run_script.return_value = "[{not-json}]"
        # Check that an error is logged and the function returns an empty dict.
        with self.assertLogs('logic.diagnostics', level='ERROR'):
            self.assertEqual(get_raw_network_stats(), {})

    @patch('logic.diagnostics.run_external_ps_script')
    def test_get_active_connections_single_object(self, mock_run_script):
        """Test that a single JSON object is correctly wrapped in a list."""
        # Arrange
        mock_data = {"Proto": "TCP", "Local": "127.0.0.1:123"}
        mock_run_script.return_value = json.dumps(mock_data)

        # Act
        result = get_active_connections()

        # Assert
        self.assertIsInstance(result, list)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0], mock_data)

    @patch('logic.diagnostics.run_external_ps_script')
    def test_get_active_connections_empty_response(self, mock_run_script):
        """Test that an empty JSON list from the script returns an empty list."""
        mock_run_script.return_value = "[]"
        result = get_active_connections()
        self.assertEqual(result, [])

class TestGetNetworkDiagnostics(unittest.TestCase):
    """Unit tests for the get_network_diagnostics function."""

    @patch('logic.diagnostics.run_system_command')
    @patch('logic.diagnostics.requests.get')
    def test_get_network_diagnostics_all_fail(self, mock_requests_get, mock_run_command):
        """Test that diagnostics function handles failures in all sub-tasks gracefully."""
        # Arrange: all external calls fail
        mock_requests_get.side_effect = requests.RequestException("Connection failed")
        # Simulate both ipconfig and ping failing
        mock_run_command.side_effect = NetworkManagerError(  # noqa: E501
            "Command failed")  # noqa: E501

        # Act
        result = get_network_diagnostics()

        # Assert: The function should return the default error values
        self.assertEqual(mock_run_command.call_count, 3) # ipconfig, ping gateway, ping external
        self.assertEqual(result['Public IP'], "Error")
        self.assertEqual(result['Gateway'], "N/A")
        self.assertEqual(result['DNS Servers'], "N/A")
        self.assertEqual(result['Gateway Latency'], "No Response")
        self.assertEqual(result['External Latency'], "No Response")

    @patch('logic.diagnostics.run_system_command')
    @patch('logic.diagnostics.requests.get')
    def test_get_network_diagnostics_parsing(self, mock_requests_get, mock_run_command):
        """Test successful parsing of ipconfig output."""
        # Arrange
        mock_requests_get.return_value.text = "1.2.3.4"
        ipconfig_output = """
   Default Gateway . . . . . . . . . : 192.168.1.1
   DNS Servers . . . . . . . . . . . : 8.8.8.8
                                       8.8.4.4
""".encode('oem')
        # Simulate successful ipconfig, then successful pings
        mock_run_command.side_effect = [
            MagicMock(stdout=ipconfig_output),  # for ipconfig  # noqa: E501
            MagicMock(stdout=b"Average = 10ms"),  # for gateway ping  # noqa: E501
            MagicMock(stdout=b"Average = 25ms")   # for external ping  # noqa: E501
        ]

        result = get_network_diagnostics(external_target="example.com")

        self.assertEqual(result['Gateway'], "192.168.1.1")
        self.assertEqual(result['DNS Servers'], "8.8.8.8, 8.8.4.4")
        self.assertEqual(result['Gateway Latency'], "10 ms")
        self.assertEqual(result['External Latency'], "25 ms")

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_dialogs.py
================================================================================

import unittest
from unittest.mock import Mock, patch

from gui.dialogs import PublishWindow

================================================================================
FILE: tests/test_exceptions.py
================================================================================

import unittest

from exceptions import NetworkManagerError

class TestNetworkManagerError(unittest.TestCase):
    """
    Unit tests for the NetworkManagerError custom exception.
    """

    def test_initialization_without_code(self):
        """Test that the exception initializes correctly without a code."""
        message = "A standard error occurred."
        error = NetworkManagerError(message)
        self.assertEqual(error.args[0], message)
        self.assertIsNone(error.code)

    def test_initialization_with_code(self):
        """Test that the exception initializes correctly with a code."""
        message = "A specific error occurred."
        code = "SPECIFIC_ERROR"
        error = NetworkManagerError(message, code=code)
        self.assertEqual(error.args[0], message)
        self.assertEqual(error.code, code)

    def test_str_representation_without_code(self):
        """Test the string representation when no code is provided."""
        message = "A standard error."
        error = NetworkManagerError(message)
        self.assertEqual(str(error), message)

    def test_str_representation_with_code(self):
        """Test the string representation when a code is provided."""
        message = "A specific error."
        code = "ERROR_CODE_123"
        error = NetworkManagerError(message, code=code)
        expected_str = f"{message} (code: {code})"
        self.assertEqual(str(error), expected_str)

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_github_integration.py
================================================================================

import unittest
from unittest.mock import patch, Mock, call

from github_integration import (check_github_cli_auth, get_repo_from_git_config,
                                create_github_release)
from exceptions import NetworkManagerError
from logic.command_utils import run_system_command

class TestGitHubIntegration(unittest.TestCase):
    """
    Unit tests for the github_integration module.
    """

    @patch('logic.command_utils.run_system_command')
    def test_check_auth_success(self, mock_run):
        """Test check_github_cli_auth when gh is installed and user is logged in."""
        # Arrange
        mock_run.return_value = Mock(returncode=0)

        # Act
        is_ok, message = check_github_cli_auth()

        # Assert
        self.assertTrue(is_ok)
        self.assertEqual(message, "GitHub CLI is ready.")
        mock_run.assert_called_once()
        self.assertIn("gh", mock_run.call_args[0][0])
        self.assertIn("auth", mock_run.call_args[0][0])
        self.assertIn("status", mock_run.call_args[0][0])

    @patch('logic.command_utils.run_system_command', side_effect=NetworkManagerError("gh not found"))
    def test_check_auth_gh_not_found(self, mock_run):
        """Test check_github_cli_auth when gh command is not found."""
        # Act
        is_ok, message = check_github_cli_auth()

        # Assert
        self.assertFalse(is_ok)
        self.assertIn("not installed", message)

    @patch('logic.command_utils.run_system_command', side_effect=NetworkManagerError("auth error"))
    def test_check_auth_not_logged_in(self, mock_run):
        """Test check_github_cli_auth when user is not logged in."""
        # Act
        is_ok, message = check_github_cli_auth()

        # Assert
        self.assertFalse(is_ok)
        self.assertIn("not logged in", message)

    @patch('logic.command_utils.run_system_command')
    def test_publish_success_no_asset(self, mock_run):
        """Test successful publishing of a release without an asset."""
        # Arrange
        expected_url = "https://github.com/user/repo/releases/tag/v1.0.0"
        mock_run.return_value = Mock(stdout=expected_url.encode('utf-8'))

        # Act
        result_url = create_github_release(tag="v1.0.0", repo="user/repo", title="Title", notes="Notes")

        # Assert
        self.assertEqual(result_url, expected_url)
        self.assertNotIn("asset.exe", " ".join(mock_run.call_args[0][0]))

    @patch('logic.command_utils.run_system_command')
    def test_publish_success_with_asset(self, mock_run):
        """Test successful publishing of a release with an asset."""
        # Arrange
        mock_run.return_value = Mock(stdout=b"some_url")
        asset_path = "dist/app.exe"

        # Act
        create_github_release("v1.0.0", "Title", "Notes", repo="user/repo", asset_paths=[asset_path])

        # Assert
        self.assertIn(asset_path, mock_run.call_args[0][0])

    @patch('logic.command_utils.run_system_command')
    def test_publish_fails_if_tag_exists(self, mock_run):
        """Test that a specific error is raised if the release tag already exists."""
        # Arrange
        error_output = "HTTP 422: A release with tag 'v1.0.0' already exists."
        mock_run.side_effect = NetworkManagerError(error_output, "gh release create")

        # Act & Assert
        with self.assertRaises(NetworkManagerError) as cm:
            create_github_release("v1.0.0", "Title", "Notes", repo="user/repo")
        
        self.assertIn("already exists on GitHub", str(cm.exception))

    @patch('logic.command_utils.run_system_command')
    def test_publish_fails_with_generic_error(self, mock_run):
        """Test that a generic error is wrapped correctly."""
        # Arrange
        error_output = "Some other generic error."
        mock_run.side_effect = NetworkManagerError(error_output, "gh release create")

        # Act & Assert
        with self.assertRaises(NetworkManagerError) as cm:
            create_github_release("v1.0.0", "Title", "Notes", repo="user/repo")
        
        self.assertIn(error_output, str(cm.exception))

    @patch('github_integration.get_repo_from_git_config', return_value='owner/detected')
    @patch('logic.command_utils.run_system_command')
    def test_create_release_uses_detected_repo(self, mock_run, mock_get_repo):
        """Test that create_github_release calls get_repo_from_git_config if repo is
        not provided."""
        # Act
        create_github_release("v1.0", "Title", "Notes")

        # Assert
        mock_get_repo.assert_called_once()
        # Check that the detected repo name was used in the command
        command_str = " ".join(mock_run.call_args[0][0])
        self.assertIn("--repo owner/detected", command_str)

class TestGetRepoFromGitConfig(unittest.TestCase):
    """Tests for the get_repo_from_git_config function."""

    @patch('github_integration._get_repo_from_packaged_info', return_value=None)
    @patch('logic.command_utils.run_system_command')
    def test_get_repo_from_https_url(self, mock_run, mock_packaged_info):
        """Test parsing a standard HTTPS remote URL."""
        mock_run.return_value.stdout = b"https://github.com/test-owner/test-repo.git"
        self.assertEqual(get_repo_from_git_config(), "test-owner/test-repo")

    @patch('github_integration._get_repo_from_packaged_info', return_value=None)
    @patch('logic.command_utils.run_system_command')
    def test_get_repo_from_ssh_url(self, mock_run, mock_packaged_info):
        """Test parsing a standard SSH remote URL."""
        mock_run.return_value.stdout = b"git@github.com:test-owner/test-repo.git"
        self.assertEqual(get_repo_from_git_config(), "test-owner/test-repo")

    @patch('github_integration._get_repo_from_packaged_info', return_value=None)
    @patch('logic.command_utils.run_system_command')
    def test_get_repo_from_url_without_git_suffix(self, mock_run, mock_packaged_info):
        """Test parsing a URL without the .git suffix."""
        mock_run.return_value.stdout = b"https://github.com/test-owner/test-repo"
        self.assertEqual(get_repo_from_git_config(), "test-owner/test-repo")

    @patch('github_integration._get_repo_from_packaged_info', return_value=None)
    @patch('logic.command_utils.run_system_command')
    def test_get_repo_command_fails(self, mock_run, mock_packaged_info):
        """Test that None is returned if the git command fails."""
        mock_run.side_effect = NetworkManagerError("git command failed")
        self.assertIsNone(get_repo_from_git_config())

    @patch('github_integration._get_repo_from_packaged_info', return_value=None)
    @patch('logic.command_utils.run_system_command')
    def test_get_repo_not_a_git_repo(self, mock_run, mock_packaged_info):
        """Test that None is returned if not in a git repository."""
        mock_run.side_effect = NetworkManagerError("git not found")
        self.assertIsNone(get_repo_from_git_config())

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_gui_components.py
================================================================================

import unittest
from unittest.mock import Mock, MagicMock, patch, call
import pytest
import tkinter as tk

import gui
from gui.action_handler import ActionHandler
from gui.queue_handler import QueueHandler
from gui.adapter_details_frame import AdapterDetailsFrame
from localization import get_string
from exceptions import NetworkManagerError

class TestActionHandler(unittest.TestCase):
    """Tests for the ActionHandler class."""

    def setUp(self):
        self.mock_context = Mock()
        self.mock_context.root = Mock()
        self.mock_context.task_queue = Mock()
        self.get_selected_adapter_name_func = Mock(return_value="Wi-Fi")
        self.handler = ActionHandler(self.mock_context, self.get_selected_adapter_name_func)

    @patch('gui.action_handler.threading.Thread')
    def test_run_background_task_starts_thread(self, mock_thread):
        """Test that run_background_task creates and starts a thread."""
        mock_task = Mock(__name__='mock_task')
        self.handler.network.run_background_task(mock_task, "arg1")

        mock_thread.assert_called_once()
        self.assertTrue(mock_thread.call_args[1]['daemon'])
        mock_thread.return_value.start.assert_called_once()

    @patch('gui.action_handler.threading.Thread')
    def test_run_background_task_network_manager_error(self, mock_thread):
        """Test that a NetworkManagerError is put into the queue."""
        task_func = Mock(side_effect=NetworkManagerError("Known error"), __name__='task_func')
        self.handler.network.run_background_task(task_func)

        # Get the worker function passed to the Thread target
        worker_func = mock_thread.call_args.kwargs['target']
        worker_func()  # Directly call the worker to simulate thread execution

        self.mock_context.task_queue.put.assert_called_with({'type': 'generic_error', 'description': "running task task_func", 'error': unittest.mock.ANY})

    @patch('gui.action_handler.threading.Thread')
    def test_run_background_task_unhandled_error(self, mock_thread):
        """Test that an unhandled exception is put into the queue."""
        task_func = Mock(side_effect=ValueError("Unhandled"), __name__='task_func')
        self.handler.network.run_background_task(task_func)

        # Check that the thread was started with a worker that calls the task
        # and that the unhandled_error is put to the queue.
        # This is an indirect way to test the worker's behavior.
        worker_func = mock_thread.call_args.kwargs['target']
        worker_func()  # Execute the worker

        self.mock_context.task_queue.put.assert_called_with({'type': 'unhandled_error', 'error': unittest.mock.ANY})

    @patch('gui.action_handler.threading.Thread')
    def test_run_background_task_on_complete_callback(self, mock_thread):
        """Test that the on_complete callback is called via the queue."""
        mock_task = Mock(__name__='mock_task', return_value="task_result")
        mock_on_complete = Mock(__name__='mock_on_complete')

        self.handler.network.run_background_task(mock_task, on_complete=mock_on_complete)

        # Simulate the worker running
        worker_func = mock_thread.call_args.kwargs['target']
        worker_func()

        # Assert that put was called with a dictionary containing a 'func' key
        self.mock_context.task_queue.put.assert_called_once()
        call_args = self.mock_context.task_queue.put.call_args[0][0]
        self.assertEqual(call_args['type'], 'ui_update')
        # Execute the lambda function that was passed to the queue
        call_args['func']()
        # Now, assert that our original on_complete mock was called with the task's result
        mock_on_complete.assert_called_once_with("task_result")

    @patch('gui.action_handler.messagebox.showwarning')
    @patch('gui.action_handler.messagebox.askyesno', return_value=True)
    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    def test_toggle_selected_adapter_no_selection(self, mock_run_task, mock_askyesno, mock_showwarning):
        """Test that toggle does nothing if no adapter is selected."""
        self.get_selected_adapter_name_func.return_value = None
        self.handler.network.toggle_adapter('enable')
        mock_run_task.assert_not_called()
        mock_showwarning.assert_called_once()

    @patch('gui.action_handler.messagebox.askyesno', return_value=False)
    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    def test_toggle_selected_adapter_user_cancels(self, mock_run_task, mock_askyesno):
        """Test that toggle is cancelled if user selects 'No'."""
        self.handler.network.toggle_adapter('enable')
        mock_run_task.assert_not_called()
        self.mock_context.root.status_var.set.assert_called_with(get_string('status_op_cancelled'))

    @patch('gui.action_handler.messagebox.askyesno', return_value=True)
    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    def test_toggle_selected_adapter_user_confirms(self, mock_run_task, mock_askyesno):
        """Test that toggle starts a background task if user confirms."""
        self.handler.network.toggle_adapter('enable')
        mock_run_task.assert_called_once_with(
            self.handler.network._execute_toggle_in_thread, "Wi-Fi", 'enable'
        )
        self.mock_context.root.status_var.set.assert_called()

    @patch('gui.action_handler.messagebox.askyesno', return_value=True)
    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    def test_confirm_reset_network_stack(self, mock_run_task, mock_askyesno):
        """Test that reset network stack action starts a background task."""
        self.handler.network.confirm_reset_network_stack()
        mock_askyesno.assert_called_once()
        mock_run_task.assert_called_once_with(self.handler.network._execute_reset_in_thread)
        self.mock_context.root.status_var.set.assert_called()

    @patch('gui.action_handler.messagebox.askyesno', return_value=False)
    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    def test_confirm_reset_network_stack_user_cancels(self, mock_run_task, mock_askyesno):
        """Test that reset is cancelled if user selects 'No'."""
        self.handler.network.confirm_reset_network_stack()
        mock_askyesno.assert_called_once()
        mock_run_task.assert_not_called()
        self.mock_context.root.status_var.set.assert_called_with(get_string('status_op_cancelled'))

    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    def test_flush_dns_cache(self, mock_run_task):
        """Test that flush DNS action starts a background task."""
        self.handler.network.flush_dns()
        mock_run_task.assert_called_once_with(self.handler.network._execute_flush_dns_in_thread)

    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    def test_release_renew_ip(self, mock_run_task):
        """Test that release and renew action starts a background task."""
        self.handler.network.renew_ip()
        mock_run_task.assert_called_once_with(self.handler.network._execute_release_renew_in_thread)

    @patch('gui.action_handler.app_logic.reset_network_stack')
    def test_execute_reset_in_thread(self, mock_reset):
        """Test the reset network stack worker method."""
        self.handler.network._execute_reset_in_thread()
        mock_reset.assert_called_once()
        self.mock_context.task_queue.put.assert_called_once_with({'type': 'reset_stack_success'})

    def test_execute_flush_dns_in_thread(self):
        """Test the flush DNS worker method."""
        self.handler.network._execute_flush_dns_in_thread()
        self.mock_context.task_queue.put.assert_called_once_with({'type': 'flush_dns_success'})

    def test_execute_release_renew_in_thread(self):
        """Test the release/renew IP worker method."""
        self.handler.network._execute_release_renew_in_thread()
        self.mock_context.task_queue.put.assert_called_once_with({'type': 'release_renew_success'})

    @patch('gui.action_handler.app_logic.disconnect_wifi')
    def test_execute_disconnect_wifi_in_thread(self, mock_disconnect):
        """Test the disconnect wifi worker method."""
        self.handler.network._execute_disconnect_wifi_in_thread()
        mock_disconnect.assert_called_once()
        self.mock_context.task_queue.put.assert_called_once_with({'type': 'disconnect_wifi_success'})

    @patch('gui.action_handler.messagebox.askyesno', return_value=True)
    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    def test_disconnect_current_wifi(self, mock_run_task, mock_askyesno):
        """Test that disconnect Wi-Fi action starts a background task."""
        self.handler.network.disconnect_current_wifi()
        mock_askyesno.assert_called_once()
        mock_run_task.assert_called_once_with(self.handler.network._execute_disconnect_wifi_in_thread)

    @patch('gui.action_handler.app_logic.disconnect_wifi_and_disable_adapter')
    def test_execute_disconnect_and_disable_in_thread(self, mock_disconnect_and_disable):
        """Test the disconnect and disable worker method."""
        mock_disconnect_and_disable.return_value = iter(["Step 1", "Step 2"])
        self.handler.network._execute_disconnect_and_disable_in_thread("Wi-Fi")
        
        expected_calls = [call({'type': 'status_update', 'text': "Step 1"}), call({'type': 'status_update', 'text': "Step 2"})]
        self.mock_context.task_queue.put.assert_has_calls(expected_calls)

    @patch('gui.action_handler.NetstatWindow')
    def test_show_netstat_window(self, mock_netstat_window):
        """Test that show_netstat_window creates a NetstatWindow instance."""
        self.handler.windows.open_netstat_window()
        mock_netstat_window.assert_called_once_with(self.mock_context)

    @patch('gui.action_handler.TracerouteWindow')
    def test_show_traceroute_window(self, mock_traceroute_window):
        """Test that show_traceroute_window creates a TracerouteWindow instance."""
        self.handler.windows.open_traceroute_window()
        mock_traceroute_window.assert_called_once_with(self.mock_context)

    @patch('gui.action_handler.app_logic.check_github_cli_auth', return_value=(True, ""))
    @patch('gui.action_handler.PublishDialog') 
    def test_show_publish_dialog(self, mock_publish_dialog, mock_check_auth):
        """Test that show_publish_dialog creates a PublishWindow instance."""
        self.handler.windows.open_publish_dialog()
        mock_publish_dialog.assert_called_once_with(self.mock_context)

    @patch('gui.action_handler.app_logic.check_github_cli_auth', return_value=(False, "Auth error"))
    @patch('gui.action_handler.messagebox.showerror') # messagebox is imported directly in action_handler
    @patch('gui.action_handler.PublishDialog')
    def test_show_publish_dialog_auth_fails(self, mock_publish_dialog, mock_showerror, mock_check_auth_app_logic):
        """Test that an error is shown if GitHub auth fails."""
        self.handler.windows.open_publish_dialog()
        mock_check_auth_app_logic.assert_called_once()
        mock_showerror.assert_called_once()
        mock_publish_dialog.assert_not_called()

    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    @patch('gui.action_handler.app_logic.get_dist_path')
    @patch('tkinter.messagebox.showerror') # Patch messagebox.showerror as it might be called if assets are not found
    def test_publish_release(self, mock_showerror, mock_get_dist_path, mock_run_task):
        """Test that publish_release calls the background task with correct arguments."""
        repo = "owner/repo"
        tag = "v1.0"
        title = "Title"
        notes = "Notes"

        mock_dist_path_obj = MagicMock()
        mock_get_dist_path.return_value = mock_dist_path_obj
        # Mock the __truediv__ method to handle the '/' operator
        mock_dist_path_obj.__truediv__.return_value = Mock(is_file=Mock(return_value=False))

        # Simulate finding an installer file in the 'dist' directory
        mock_dist_path_obj.glob.return_value = iter([Mock(is_file=Mock(return_value=True), __str__=Mock(return_value="dist/NetPilot-setup.exe"))])

        self.handler.github.publish_release(repo, tag, title, notes)
        
        expected_assets = ["dist/NetPilot-setup.exe"]
        mock_run_task.assert_called_once_with(self.handler.github._execute_publish_in_thread, repo, tag, title, notes, expected_assets, on_complete=None, on_error=None)

    @patch('gui.action_handler.BaseActionHandler.run_background_task')
    @patch('gui.action_handler.app_logic.get_dist_path')
    @patch('tkinter.messagebox.showerror')
    def test_publish_release_no_assets_found(self, mock_showerror, mock_get_dist_path, mock_run_task):
        """Test that an error is shown if no release assets are found."""
        repo = "owner/repo"
        tag = "v1.0"
        title = "Title"
        notes = "Notes"

        mock_dist_path_obj = MagicMock()
        mock_get_dist_path.return_value = mock_dist_path_obj
        mock_dist_path_obj.glob.return_value = iter([]) # No installer
        mock_dist_path_obj.__truediv__.return_value = Mock(is_file=Mock(return_value=False)) # No exe

        self.handler.github.publish_release(repo, tag, title, notes)
        mock_showerror.assert_called_once()
        mock_run_task.assert_not_called()
    
    @patch('app_logic.create_github_release', side_effect=NetworkManagerError("API Error"))
    def test_execute_publish_in_thread_failure(self, mock_create_release):
        """Test that an error during publishing is caught and put to the queue."""
        with self.assertRaises(NetworkManagerError):
            # The error should be re-raised inside the worker and caught by run_background_task
            self.handler.github._execute_publish_in_thread("owner/repo", "v1.0", "Title", "Notes")
        
        mock_create_release.assert_called_once()

@pytest.mark.usefixtures("tk_root")
class TestAdapterDetailsFrame(unittest.TestCase):
    """Tests for the AdapterDetailsFrame UI component."""

    def setUp(self):
        # The tk_root fixture is activated by @pytest.mark.usefixtures.
        # We access it through the request object provided by pytest.
        self.root = self.request.getfixturevalue("tk_root")
        
        self.mock_on_connect = Mock()
        self.mock_on_disconnect = Mock()
        self.mock_on_status_update = Mock()

        self.frame = AdapterDetailsFrame(
            self.root,
            on_connect_callback=self.mock_on_connect,
            on_disconnect_callback=self.mock_on_disconnect,
            on_status_update_callback=self.mock_on_status_update
        )
class TestQueueHandler(unittest.TestCase):
    """Tests for the QueueHandler class."""

    def setUp(self):
        self.mock_context = Mock()
        self.mock_context.root = Mock()
        self.mock_context.action_handler = Mock()
        self.mock_context.open_windows = {}
        self.mock_ui_frames = {
            'diagnostics': Mock(),
            'adapter_list': Mock(),
            'adapter_details': Mock(),
            'wifi_status': Mock()
        }
        self.mock_context.main_controller.refresh_adapter_list = Mock()
        self.handler = QueueHandler(self.mock_context, self.mock_ui_frames)

    def test_process_message_delegates_to_wifi_handler(self):
        """Test that Wi-Fi related messages are handled by the wifi_handler."""
        self.handler.wifi_handler.process_message = Mock(return_value=True)
        self.handler.process_message({'type': 'wifi_list_success'})
        self.handler.wifi_handler.process_message.assert_called_once()

    def test_process_message_unknown_type(self):
        """Test that an unknown message type is logged as a warning."""
        with self.assertLogs('gui.queue_handler', level='WARNING') as cm:
            self.handler.process_message({'type': 'unknown_message'})
            self.assertIn("No handler found for queue message type: unknown_message", cm.output[0])

    def test_handle_toggle_error_already_in_state(self):
        """Test info messagebox for 'already in state' errors."""
        message = {
            'type': 'toggle_error',
            'adapter_name': 'Wi-Fi',
            'action': 'enable',
            'error': NetworkManagerError("Adapter is already enabled.")
        }
        with patch('gui.queue_handler.messagebox.showinfo') as mock_showinfo:
            self.handler.process_message(message)
            mock_showinfo.assert_called_once()
            self.mock_context.root.status_var.set.assert_called()

    @patch('gui.queue_handler.messagebox.askyesno', return_value=True)
    def test_handle_toggle_error_wifi_connected(self, mock_askyesno):
        """Test the specific flow for the WIFI_CONNECTED_DISABLE_FAILED error."""
        message = {
            'type': 'toggle_error',
            'adapter_name': 'Wi-Fi',
            'action': 'disable',
            'error': NetworkManagerError("Cannot disable", code='WIFI_CONNECTED_DISABLE_FAILED')
        }
        self.handler.process_message(message)
        self.mock_context.action_handler.network.execute_disconnect_and_disable.assert_called_once_with('Wi-Fi')

    @patch('gui.queue_handler.messagebox.askyesno', return_value=False)
    def test_handle_toggle_error_wifi_connected_user_declines(self, mock_askyesno):
        """Test that nothing happens if user declines the auto-disconnect prompt."""
        message = {
            'type': 'toggle_error',
            'adapter_name': 'Wi-Fi',
            'action': 'disable',
            'error': NetworkManagerError("Cannot disable", code='WIFI_CONNECTED_DISABLE_FAILED')
        }
        self.handler.process_message(message)
        self.mock_context.action_handler.network.execute_disconnect_and_disable.assert_not_called()
        self.mock_context.root.status_var.set.assert_called()

    @patch('gui.queue_handler.messagebox.showerror')
    def test_handle_toggle_error_generic(self, mock_showerror):
        """Test the generic error path for toggle failures."""
        message = {
            'type': 'toggle_error',
            'adapter_name': 'Wi-Fi',
            'action': 'disable',
            'error': NetworkManagerError("A generic failure.")
        }
        self.handler.process_message(message)
        mock_showerror.assert_called_once()
        self.mock_context.root.status_var.set.assert_called()
        self.mock_context.main_controller.refresh_adapter_list.assert_called_once()

    def test_handle_generic_error_location_permission(self):
        """Test specific handling for location permission error."""
        message = {
            'type': 'generic_error',
            'description': 'scanning wifi',
            'error': NetworkManagerError("Enable location", code="LOCATION_PERMISSION_DENIED")
        }
        with patch('gui.queue_handler.messagebox.askyesno', return_value=True) as mock_ask, \
             patch('gui.queue_handler.os.startfile') as mock_startfile:
            self.handler.process_message(message)
            mock_ask.assert_called_once()
            mock_startfile.assert_called_once_with("ms-settings:privacy-location")

    def test_handle_generic_error_no_code(self):
        """Test the generic error handler for an error without a special code."""
        message = {
            'type': 'generic_error',
            'description': 'doing something',
            'error': NetworkManagerError("A plain error.")
        }
        with patch('gui.queue_handler.messagebox.showerror') as mock_showerror:
            self.handler.process_message(message)
            mock_showerror.assert_called_once()

    def test_handle_ui_update(self):
        """Test that a callable function in a 'ui_update' message is executed."""
        mock_func = Mock()
        message = {'type': 'ui_update', 'func': mock_func}
        self.handler.process_message(message)
        mock_func.assert_called_once()

    def test_handle_speed_update_with_selection(self):
        """Test speed update when an adapter is selected."""
        self.mock_context.main_controller.get_speed_for_selected_adapter.return_value = {'download': 100, 'upload': 50}
        message = {'type': 'speed_update', 'data': {'Wi-Fi': {'download': 100, 'upload': 50}}}
        self.handler.process_message(message)
        self.mock_ui_frames['adapter_details'].update_speeds.assert_called_once_with(100, 50)

    def test_handle_speed_update_no_selection(self):
        """Test speed update does nothing if no adapter is selected."""
        self.mock_context.main_controller.get_speed_for_selected_adapter.return_value = None
        message = {'type': 'speed_update', 'data': {'Wi-Fi': {'download': 100}}}
        self.handler.process_message(message)
        # It should reset speeds to 0
        self.mock_ui_frames['adapter_details'].update_speeds.assert_called_once_with(0, 0)

    @patch('gui.queue_handler.messagebox.showinfo')
    def test_handle_reset_stack_success(self, mock_showinfo):
        """Test the handler for a successful network stack reset."""
        self.handler.process_message({'type': 'reset_stack_success'})
        mock_showinfo.assert_called_once()
        self.assertIn("reboot your computer", mock_showinfo.call_args[0][1])

    @patch('gui.queue_handler.messagebox.showinfo')
    def test_handle_release_renew_success(self, mock_showinfo):
        """Test the handler for a successful IP renew."""
        self.handler.process_message({'type': 'release_renew_success'})
        mock_showinfo.assert_called_once()
        self.mock_context.main_controller.refresh_adapter_list.assert_called_once()

    def test_handle_diagnostics_update(self):
        """Test that diagnostics data is passed to the correct UI frame."""
        message = {'type': 'diagnostics_update', 'data': {'Public IP': '1.1.1.1'}}
        self.handler.process_message(message)
        self.mock_ui_frames['diagnostics'].update_diagnostics.assert_called_once_with(message['data'])

    def test_handle_disconnect_wifi_error(self):
        """Test that a disconnect error is handled and the button is re-enabled."""
        message = {'type': 'disconnect_wifi_error', 'error': NetworkManagerError("test error")}
        with patch('gui.queue_handler.messagebox.showerror') as mock_showerror:
            self.handler.process_message(message)
            mock_showerror.assert_called_once()

    def test_handle_toggle_success(self,):
        """Test that a toggle success message triggers a UI refresh."""
        message = {'type': 'toggle_success', 'adapter_name': 'Wi-Fi', 'action': 'enabled'}
        with patch.object(self.mock_context.root, 'after') as mock_after:
            self.handler.process_message(message)
            mock_after.assert_called_once_with(500, self.mock_context.main_controller.refresh_adapter_list)

    @patch('gui.queue_handler.messagebox.showinfo')
    def test_handle_disconnect_wifi_success_no_window_open(self, mock_showinfo):
        """Test disconnect success handler when the wifi window is not open."""
        # Arrange: Ensure no window is registered
        self.mock_context.open_windows = {}
        message = {'type': 'disconnect_wifi_success'}
        # Act
        self.handler.process_message(message)
        # Assert
        mock_showinfo.assert_called_once_with("Success", "Successfully disconnected from the Wi-Fi network.", parent=self.mock_context.root)

    def test_wifi_handler_does_nothing_if_window_not_open(self):
        """Test that Wi-Fi message handlers do nothing if the window is not open."""
        # Arrange: Ensure the wifi window is not in open_windows
        self.handler.wifi_handler.context.open_windows = {}
        
        # Act: Process messages that would normally update the window
        self.handler.process_message({'type': 'wifi_list_success', 'data': [], 'current_ssid': ''})
        self.handler.process_message({'type': 'wifi_connect_success', 'ssid': 'TestNet'})
        self.handler.process_message({'type': 'wifi_saved_profiles_success', 'data': []})
        self.handler.process_message({'type': 'wifi_delete_profile_success', 'profile_name': 'TestProfile'})
        # No assertion is needed; the test passes if no exceptions are raised.

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_localization.py
================================================================================

import unittest
from unittest.mock import patch

import localization

class TestLocalization(unittest.TestCase):
    """Tests for the localization module."""

    def tearDown(self):
        # Reset to default after each test
        localization.CURRENT_LANGUAGE = localization.DEFAULT_LANGUAGE

    @patch('localization.locale.getdefaultlocale', return_value=('fi_FI', 'cp1252'))
    def test_initialize_language_detects_fi(self, mock_getlocale):  # noqa: E501
        """Test that 'fi' is correctly detected."""
        with patch('pathlib.Path.exists', return_value=False), \
             patch('localization.configparser.ConfigParser.get', return_value=None):  # noqa: E501
            localization.initialize_language()
            self.assertEqual(localization.CURRENT_LANGUAGE, 'fi')

    @patch('localization.locale.getdefaultlocale', return_value=('en_US', 'cp1252'))
    def test_initialize_language_detects_en(self, mock_getlocale):  # noqa: E501
        """Test that 'en' is correctly detected."""
        with patch('pathlib.Path.exists', return_value=False), \
             patch('localization.configparser.ConfigParser.get', return_value=None):  # noqa: E501
            localization.initialize_language()
            self.assertEqual(localization.CURRENT_LANGUAGE, 'en')

    @patch('localization.locale.getdefaultlocale', return_value=('de_DE', 'cp1252'))
    def test_initialize_language_falls_back_to_default(self, mock_getlocale):  # noqa: E501
        """Test that an unsupported language falls back to the default ('en')."""
        with patch('pathlib.Path.exists', return_value=False), \
             patch('localization.configparser.ConfigParser.get', return_value=None):  # noqa: E501
            localization.initialize_language()
            self.assertEqual(localization.CURRENT_LANGUAGE,
                             localization.DEFAULT_LANGUAGE)

    def test_get_string_with_formatting(self):
        """Test that get_string correctly formats a string with keyword
        arguments."""
        localization.CURRENT_LANGUAGE = 'en'
        result = localization.get_string(
            'log_file_hint', log_file_path="C:\\log.txt")
        self.assertIn("C:\\log.txt", result)

    def test_get_string_missing_key(self):
        """Test that a missing key returns a placeholder."""
        self.assertEqual(localization.get_string('non_existent_key'), '<non_existent_key>')

================================================================================
FILE: tests/test_main_and_startup.py
================================================================================

import unittest
from unittest.mock import patch, Mock
import sys
import importlib

class TestMainStartup(unittest.TestCase):
    """Tests for the main.py startup and pre-flight check logic."""

    def setUp(self):
        """
        Import the 'main' module here to ensure mocks are applied correctly
        for each test, avoiding issues with module caching.
        """
        global main
        import main
        # We need to reload it in case it was imported by another test file.
        importlib.reload(main)

    @patch('main.logger_setup.setup_logging')
    @patch('main.initialize_language')
    @patch('main.is_admin', return_value=True)
    @patch('main.AppContext')
    @patch('main.NetworkManagerApp')
    def test_main_success_path(self, mock_app, mock_context, mock_is_admin, mock_init_lang, mock_logging):
        """Test the main function's successful execution path."""
        mock_app_instance = mock_app.return_value
        main.main()
        mock_is_admin.assert_called_once()
        mock_app.assert_called_once_with(mock_context.return_value)
        mock_app_instance.mainloop.assert_called_once()
 
    @patch('main.logger_setup.setup_logging')
    @patch('main.initialize_language')
    @patch('main.messagebox.showerror')
    def test_main_unsupported_os(self, mock_showerror, mock_init_lang, mock_logging):
        """Test that main exits on a non-Windows OS."""
        with patch('sys.platform', 'linux'):
            # We need to reload the module to re-trigger the platform check
            importlib.reload(main)
            main.main() # type: ignore
        mock_showerror.assert_called_once()

    @patch('main.logger_setup.setup_logging')
    @patch('main.initialize_language')
    @patch('main.is_admin', return_value=False)
    @patch('main.relaunch_as_admin')
    @patch('main.NetworkManagerApp')
    def test_main_relaunch_as_admin(self, mock_app, mock_relaunch, mock_is_admin,
                                    mock_init_lang, mock_logging):
        """Test that main attempts to relaunch if not admin."""
        main.main()
        mock_relaunch.assert_called_once()
        mock_app.assert_not_called() # The main app should not start
 
    @patch('main.logger_setup.setup_logging')
    @patch('main.initialize_language')
    @patch('main.is_admin', return_value=False)
    @patch('main.relaunch_as_admin', side_effect=Exception("Relaunch failed"))
    @patch('main.messagebox.showerror')
    def test_main_relaunch_fails(self, mock_showerror, mock_relaunch,
                                 mock_is_admin, mock_init_lang, mock_logging):
        """Test that an error is shown if relaunching fails."""
        main.main()
        mock_relaunch.assert_called_once()
        mock_showerror.assert_called_once()

    @patch('main.logger_setup.setup_logging')
    @patch('main.initialize_language')
    @patch('main.is_admin', return_value=True)
    @patch('main.NetworkManagerApp', side_effect=Exception("Generic unhandled error"))
    @patch('main.messagebox.showerror')
    def test_main_generic_exception_path(self, mock_showerror, mock_app,
                                         mock_is_admin, mock_init_lang, mock_logging):
        """Test that a generic Exception during app initialization is caught."""
        main.main()
        mock_showerror.assert_called_once()
        # Check for the actual translated title string, not the key
        self.assertIn(main.get_string("fatal_error_title"),
                      mock_showerror.call_args.args)

================================================================================
FILE: tests/test_main_controller.py
================================================================================

import unittest
from unittest.mock import Mock, patch, call
from localization import get_string
from gui.main_controller import MainController
from exceptions import NetworkManagerError
from gui.action_handler import ActionHandler

class TestMainController(unittest.TestCase):
    """
    Unit tests for the MainController class.
    """

    def setUp(self):
        """Set up a MainController instance with a mock task_queue for each test."""
        self.mock_context = Mock()
        self.mock_context.queue_handler = Mock()
        self.controller = MainController(self.mock_context)

    @patch('gui.main_controller.get_adapter_details')
    def test_refresh_adapter_list_success(self, mock_get_details):
        """Test successful refresh of the adapter list."""
        # Arrange
        mock_adapters = [{'Name': 'Wi-Fi'}, {'Name': 'Ethernet'}]
        mock_get_details.return_value = mock_adapters

        # Act
        self.controller.refresh_adapter_list()

        # Assert
        self.assertEqual(self.controller.adapters_data, mock_adapters)

    @patch('gui.main_controller.get_adapter_details')
    def test_refresh_adapter_list_failure(self, mock_get_details):
        """Test failure during adapter list refresh."""
        # Arrange
        error = NetworkManagerError("Test error")
        mock_get_details.side_effect = error

        # Act & Assert: Check that an error is logged.
        with self.assertLogs('gui.main_controller', level='ERROR'):
            self.controller.refresh_adapter_list()

    def test_on_adapter_select(self):
        """Test selecting a valid adapter."""
        # Arrange
        self.controller.adapters_data = [{'Name': 'Wi-Fi'}, {'Name': 'Ethernet'}]
        selected_index = 1

        # Act
        self.controller.on_adapter_select(selected_index)

        # Assert
        self.assertEqual(self.controller.selected_adapter_index, selected_index)

    def test_on_adapter_select_invalid_index(self):
        """Test selecting an invalid adapter index."""
        # Arrange
        self.controller.adapters_data = [{'Name': 'Wi-Fi'}]
        
        # Act & Assert: Check that a warning is logged for the invalid index.
        with self.assertLogs('gui.main_controller', level='WARNING'):
            self.controller.on_adapter_select(99) # Invalid index

        # Assert
        self.assertIsNone(self.controller.selected_adapter_index)  # noqa: E501
        self.mock_context.queue_handler.handle_adapter_details_update.assert_not_called()  # noqa: E501

    def test_get_selected_adapter_name(self):
        """Test getting the name of the selected adapter."""
        # Arrange
        self.controller.adapters_data = [
            {'Name': 'Wi-Fi'}, {'Name': 'Ethernet'}]
        self.controller.selected_adapter_index = 0

        # Act & Assert
        self.assertEqual(
            self.controller.get_selected_adapter_name(), 'Wi-Fi')
        
        # Test when nothing is selected
        self.controller.selected_adapter_index = None
        self.assertIsNone(self.controller.get_selected_adapter_name())

    def test_get_speed_for_selected_adapter(self):
        """Test getting speed data for the selected adapter."""
        self.controller.adapters_data = [{'Name': 'Wi-Fi'}]
        self.controller.selected_adapter_index = 0
        speeds = {'Wi-Fi': {'download': 123}, 'Ethernet': {'download': 456}}
 
        # Should return data for 'Wi-Fi'
        self.assertEqual(self.controller.get_speed_for_selected_adapter(
            speeds), {'download': 123})

        # Should return None if nothing is selected
        self.controller.selected_adapter_index = None
        self.assertIsNone(
            self.controller.get_speed_for_selected_adapter(speeds))

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_menu_handler.py
================================================================================



================================================================================
FILE: tests/test_polling_manager.py
================================================================================

import unittest
from unittest.mock import Mock, patch, call
import threading

import time
from gui.polling_manager import PollingManager

class TestPollingManagerSpeedCalc(unittest.TestCase):
    """
    Unit tests for the PollingManager._calculate_speed_delta method.
    """

    def setUp(self):
        """Set up a PollingManager instance for testing."""
        mock_context = Mock()
        mock_context.main_controller = Mock()
        mock_context.task_queue = Mock()
        self.polling_manager = PollingManager(context=mock_context)

    def test_normal_speed_calculation(self):
        """Test a standard, successful speed calculation over 2 seconds."""
        last_stats = {'Adapter 1': {'received': 1000, 'sent': 500}}
        current_stats = {'Adapter 1': {'received': 2000, 'sent': 750}}
        time_delta = 2.0

        # Download: (2000 - 1000) / 2.0 = 500 Bps
        # Upload:   (750 - 500) / 2.0 = 125 Bps
        expected = {'Adapter 1': {'download': 500.0, 'upload': 125.0}}

        result = self.polling_manager._calculate_speed_delta(
            current_stats, last_stats, time_delta)
        self.assertEqual(result, expected)

    def test_counter_rollover_returns_zero(self):
        """Test that a negative delta (counter rollover) results in 0 speed for
        that metric."""
        last_stats = {'Adapter 1': {'received': 5000, 'sent': 1000}}
        current_stats = {'Adapter 1': {'received': 1000,
                                       'sent': 1500}}  # 'received' counter reset
        time_delta = 1.0

        # Download speed should be 0 due to negative delta.
        # Upload speed should be calculated normally: (1500 - 1000) / 1.0 = 500 Bps
        expected = {'Adapter 1': {'download': 0.0, 'upload': 500.0}}

        result = self.polling_manager._calculate_speed_delta(
            current_stats, last_stats, time_delta)
        self.assertEqual(result, expected)

    def test_zero_time_delta(self):
        """Test that a time_delta of zero or less returns an empty dict to prevent division by zero."""
        last_stats = {'Adapter 1': {'received': 1000, 'sent': 500}}
        current_stats = {'Adapter 1': {'received': 2000, 'sent': 750}}
        
        result_zero = self.polling_manager._calculate_speed_delta(
            current_stats, last_stats, 0)
        self.assertEqual(result_zero, {})

        result_negative = self.polling_manager._calculate_speed_delta(
            current_stats, last_stats, -1.0)
        self.assertEqual(result_negative, {})

    def test_empty_or_missing_stats(self):
        """Test that empty or missing stats dictionaries are handled gracefully."""
        last_stats = {'Adapter 1': {'received': 1000, 'sent': 500}}
        current_stats = {'Adapter 1': {'received': 2000, 'sent': 750}}
 
        # No last stats available
        self.assertEqual(self.polling_manager._calculate_speed_delta(
            current_stats, {}, 1.0), {})
        # No current stats available
        self.assertEqual(
            self.polling_manager._calculate_speed_delta({}, last_stats, 1.0), {})

    def test_new_adapter_appears(self):
        """Test that a newly appeared adapter is ignored in the first calculation."""
        last_stats = {'Adapter 1': {'received': 1000, 'sent': 500}}
        current_stats = {
            'Adapter 1': {'received': 2000, 'sent': 750},
            'Adapter 2': {'received': 500, 'sent': 500} # New adapter
        }

        result = self.polling_manager._calculate_speed_delta(
            current_stats, last_stats, 1.0)
        self.assertIn('Adapter 1', result)
        self.assertNotIn('Adapter 2', result)

    def test_invalid_data_in_stats(self):
        """Test that non-numeric or missing byte counts are skipped."""
        last_stats = {'Adapter 1': {'received': 1000, 'sent': 500}}
        current_stats = {  # Invalid data
            'Adapter 1': {'received': None, 'sent': 'not-a-number'}
        }

        result = self.polling_manager._calculate_speed_delta(
            current_stats, last_stats, 1.0)
        self.assertNotIn('Adapter 1', result)

class TestCalculateCurrentSpeeds(unittest.TestCase):
    """Tests for the _calculate_current_speeds method."""

    def setUp(self):
        mock_context = Mock()
        self.polling_manager = PollingManager(context=mock_context)
        self.polling_manager.last_stats = {}
        self.polling_manager.last_time = time.time()

    def test_invalid_json_returns_empty_dict(self):
        """Test that malformed JSON input is handled gracefully."""
        with self.assertLogs('gui.polling_manager', level='WARNING'):
            result = self.polling_manager._calculate_current_speeds(
                "{not-json")
            self.assertEqual(result, {})

    def test_non_list_or_dict_json_returns_empty_dict(self):
        """Test that valid but structurally incorrect JSON is handled."""
        self.assertEqual(self.polling_manager._calculate_current_speeds("123"), {})
class TestPollingManagerLoop(unittest.TestCase):
    """
    Unit tests for the PollingManager's main polling loop.
    """

    def setUp(self):
        """Set up mocks and the PollingManager instance."""
        self.mock_context = Mock()
        self.mock_context.task_queue = Mock()
        self.mock_context.get_ping_target.return_value = "8.8.8.8"
        self.mock_context.main_controller = Mock()
        self.polling_manager = PollingManager(self.mock_context)
        self.polling_manager.start_all(diagnostics_interval=5, speed_interval=1)

    @patch('gui.polling_manager.time.time')
    @patch('gui.polling_manager.get_current_wifi_details')
    @patch('gui.polling_manager.PollingManager._fetch_diagnostics_and_queue')
    def test_first_poll_runs_all_tasks(self, mock_fetch_diag, mock_get_wifi,
                                       mock_time):
        """Test that the very first poll runs both heavy and light tasks."""
        # Arrange
        mock_time.return_value = 1000.0
        mock_get_wifi.return_value = {'ssid': 'TestNet'}

        # Act: Run the loop once. We set is_running to True and then mock the
        # stop_event.wait() call to immediately set the event, ensuring the
        # loop runs exactly once.
        stop_event = threading.Event()
        self.polling_manager.is_running = True
        with patch.object(stop_event, 'wait',
                          side_effect=lambda timeout: stop_event.set()):
            self.polling_manager._poll_loop(stop_event)

        # Assert
        # Check that all data fetching functions were called
        mock_fetch_diag.assert_called_once()
        mock_get_wifi.assert_called_once()

        # Check that all messages were put into the queue
        expected_calls = [call.put(
            {'type': 'wifi_status_update', 'data': {'ssid': 'TestNet'}}), ]
        self.mock_context.task_queue.assert_has_calls(expected_calls)

    @patch('gui.polling_manager.time.time')
    @patch('gui.polling_manager.get_current_wifi_details')
    @patch('gui.polling_manager.get_network_diagnostics')
    def test_subsequent_poll_runs_only_light_tasks(self, mock_get_diag,
                                                   mock_get_wifi, mock_time):
        """Test that a subsequent poll (before interval) only runs speed calculation."""
        # Arrange
        self.polling_manager.diagnostics_interval = 0.1 # Shorten interval for test
        # Simulate two loop runs: one at t=1000, one at t=1001
        mock_time.side_effect = [1000.0, 1001.0]
        
        # Run the loop in a thread and use an event to stop it after two iterations.
        stop_event = threading.Event()
        self.polling_manager.is_running = True  # noqa: E501
        poll_thread = threading.Thread(
            target=self.polling_manager._poll_loop, args=(stop_event,))
        poll_thread.start()
        
        # Wait long enough for two cycles
        time.sleep(self.polling_manager.diagnostics_interval * 1.5)
        
        stop_event.set() # Signal the loop to stop
        poll_thread.join(timeout=1) # Wait for the thread to finish

        # Assert
        # In the main loop, these tasks run on every iteration.
        self.assertEqual(mock_get_diag.call_count, 2)
        self.assertEqual(mock_get_wifi.call_count, 2)

    @patch('gui.polling_manager.subprocess.Popen')
    def test_speed_poll_loop_skips_when_no_adapter_selected(self, mock_popen):
        """Test that speed calculation is skipped if no adapter is
        selected."""
        # Arrange
        self.polling_manager.is_running = True
        self.mock_context.main_controller.get_selected_adapter_name.return_value = None  # noqa: E501
        
        # Mock the process to simulate it running and producing output
        mock_process = mock_popen.return_value
        # Make the loop run only once by having poll() return a value on the second call
        mock_process.poll.side_effect = [None, 0]
        mock_process.stdout.readline.return_value = '{"Name": "Wi-Fi", "ReceivedBytes": 100, "SentBytes": 50}'  # noqa: E501

        # Act: We can't easily test the loop, so we call the method directly
        # and check if the calculation part is skipped.
        with patch.object(self.polling_manager,
                          '_calculate_current_speeds') as mock_calculate:
            self.polling_manager._speed_poll_loop_powershell()
            mock_calculate.assert_not_called()

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_system.py
================================================================================

import unittest
from unittest.mock import patch, MagicMock
import sys
from logic.system import (is_admin, reset_network_stack, flush_dns_cache,
                          release_renew_ip, terminate_process_by_pid,
                          relaunch_as_admin)
from exceptions import NetworkManagerError

class TestIsAdmin(unittest.TestCase):
    """Unit tests for the is_admin function."""

    @patch('sys.platform', 'win32')
    def test_is_admin_true_on_windows_with_admin(self):
        """Test is_admin returns True on Windows when user is an admin."""
        # Mokataan ctypes-kirjaston Windows-spesifinen kutsu
        with patch('ctypes.windll.shell32.IsUserAnAdmin', return_value=1):
            self.assertTrue(is_admin())

    @patch('sys.platform', 'win32')
    def test_is_admin_false_on_windows_without_admin(self):
        """Test is_admin returns False on Windows when user is not an admin."""
        with patch('ctypes.windll.shell32.IsUserAnAdmin', return_value=0):
            self.assertFalse(is_admin())

    def test_is_admin_false_on_non_windows(self):
        """Test is_admin returns False on non-Windows platforms."""
        with patch('sys.platform', 'linux'), \
             patch('ctypes.windll', new_callable=MagicMock) as mock_windll:
            self.assertFalse(is_admin())
            mock_windll.shell32.IsUserAnAdmin.assert_not_called()
 
    @patch('sys.platform', 'win32')
    def test_is_admin_handles_attribute_error(self):
        """Test is_admin returns False if IsUserAnAdmin function is missing."""
        with patch('ctypes.windll.shell32.IsUserAnAdmin', side_effect=AttributeError):
            self.assertFalse(is_admin())

class TestSystemCommands(unittest.TestCase):
    """Unit tests for other system command functions."""

    @patch('logic.system.run_system_command')
    def test_reset_network_stack(self, mock_run):
        """Test that reset_network_stack calls the correct netsh command."""
        reset_network_stack()
        mock_run.assert_called_once_with(
            ['netsh', 'winsock', 'reset'], "Failed to reset network stack.")

    @patch('logic.system.run_system_command')
    def test_flush_dns_cache(self, mock_run):
        """Test that flush_dns_cache calls the correct ipconfig command."""
        flush_dns_cache()
        mock_run.assert_called_once_with(
            ['ipconfig', '/flushdns'], "Failed to flush DNS cache.")

    @patch('logic.system.run_system_command')
    def test_release_renew_ip_success(self, mock_run):
        """Test a successful IP release and renew sequence."""
        # Simulate both commands succeeding
        mock_run.return_value = MagicMock(returncode=0)
        release_renew_ip()

        self.assertEqual(mock_run.call_count, 2)
        mock_run.assert_any_call(
            ['ipconfig', '/release'], "IP address release command finished.", check=False)
        mock_run.assert_any_call(
            ['ipconfig', '/renew'], "Failed to renew IP address.")

    @patch('logic.system.run_system_command')
    def test_release_renew_ip_release_fails_with_other_error(self, mock_run):
        """Test that a non-critical but unexpected error in 'release' is logged as a warning."""
        # Simulate 'release' failing with a different error, and 'renew' succeeding.
        mock_run.side_effect = [
            MagicMock(returncode=1, stderr=b"some other random error"),
            MagicMock(returncode=0)
        ]
        with self.assertLogs('logic.system', level='WARNING') as cm:
            release_renew_ip()
            self.assertIn("unexpected non-zero exit code", cm.output[0])
        self.assertEqual(mock_run.call_count, 2)

    @patch('logic.system.run_system_command')
    def test_release_renew_ip_release_fails_gracefully(self, mock_run):
        """Test that renew is still called if release fails with a non-critical error."""
        # Simulate 'release' failing with a known safe error, and 'renew' succeeding.
        mock_run.side_effect = [
            MagicMock(returncode=1, stderr=b"media is disconnected"),
            MagicMock(returncode=0)
        ]

        release_renew_ip()

        self.assertEqual(mock_run.call_count, 2)
        mock_run.assert_any_call(
            ['ipconfig', '/renew'], "Failed to renew IP address.")

    @patch('logic.system.run_system_command')
    def test_release_renew_ip_renew_fails_with_dhcp_error(self, mock_run):
        """Test that a specific DHCP error during renew is correctly identified."""
        # Simulate 'release' succeeding, but 'renew' failing with a DHCP error.
        mock_run.side_effect = [
            MagicMock(returncode=0),
            NetworkManagerError("unable to contact your dhcp server")
        ]

        with self.assertRaises(NetworkManagerError) as cm:
            release_renew_ip()

        self.assertEqual(cm.exception.code, 'DHCP_SERVER_UNREACHABLE')

    @patch('logic.system.run_system_command')
    def test_release_renew_ip_renew_fails_with_adapter_disabled_error(self, mock_run):
        """Test that a specific 'adapter disabled' error during renew is
        correctly identified."""
        # Simulate 'release' succeeding, but 'renew' failing with the specific error.
        mock_run.side_effect = [
            MagicMock(returncode=0),
            NetworkManagerError("no adapter is in the state permissible")
        ]
        with self.assertRaises(NetworkManagerError) as cm:
            release_renew_ip()
        self.assertEqual(cm.exception.code, 'ADAPTER_DISABLED')

    @patch('logic.system.run_system_command')
    def test_release_renew_ip_renew_fails_with_generic_error(self, mock_run):
        """Test that a generic error during renew is re-raised."""
        # Simulate 'release' succeeding, but 'renew' failing with a generic error.
        mock_run.side_effect = [
            MagicMock(returncode=0),
            NetworkManagerError("A generic failure.")
        ]
        with self.assertRaisesRegex(NetworkManagerError, "A generic failure.") as cm:
            release_renew_ip()
        self.assertIsNone(cm.exception.code) # Ensure it's not a specific coded error

    @patch('logic.system.run_system_command')
    def test_terminate_process_by_pid_success(self, mock_run):
        """Test a successful process termination."""
        pid_to_kill = 1234
        terminate_process_by_pid(pid_to_kill)
        mock_run.assert_called_once_with(['taskkill',
                                          '/F',
                                          '/T',
                                          '/PID',
                                          str(pid_to_kill)],
                                         f"Failed to terminate process with PID {pid_to_kill}.")

    def test_terminate_process_by_pid_critical_process(self):
        """Test that terminating critical system PIDs is blocked."""
        with self.assertRaisesRegex(NetworkManagerError, "system-critical processes is not allowed"):
            terminate_process_by_pid(0)
        with self.assertRaisesRegex(NetworkManagerError, "system-critical processes is not allowed"):
            terminate_process_by_pid(4)

    @patch('logic.system.run_system_command', side_effect=NetworkManagerError("Taskkill failed."))
    def test_terminate_process_by_pid_failure(self, mock_run):
        """Test that an error from taskkill is propagated."""
        with self.assertRaisesRegex(NetworkManagerError, "Taskkill failed."):
            terminate_process_by_pid(1234)


if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_utils.py
================================================================================

import unittest

from gui.utils import format_speed

class TestFormatSpeed(unittest.TestCase):
    """Tests for the format_speed utility function."""

    def test_format_speed_kbps(self):
        self.assertEqual(format_speed(12500), "100.0 kbps")

    def test_format_speed_mbps(self):
        self.assertEqual(format_speed(1250000), "10.00 Mbps")

    def test_format_speed_negative_input(self):
        self.assertEqual(format_speed(-1000), "0.0 kbps")

    def test_format_speed_invalid_type(self):
        with self.assertRaises(TypeError):
            format_speed("not a number")

================================================================================
FILE: tests/test_wifi.py
================================================================================

import unittest
import json
from unittest.mock import patch

from logic.wifi import (_parse_netsh_wlan_output, get_current_wifi_details,
                        get_saved_wifi_profiles, list_wifi_networks, disconnect_wifi)
from exceptions import NetworkManagerError

class TestWifiParser(unittest.TestCase):
    """
    Unit tests for the _parse_netsh_wlan_output function.
    """

    def test_parse_multiple_networks(self):
        """Test parsing a standard output with multiple networks."""
        mock_output = """
Interface name : Wi-Fi
There are 2 networks currently visible.

SSID 1 : MyHomeNetwork
    Network type            : Infrastructure
    Authentication          : WPA2-Personal
    Encryption              : CCMP
    BSSID 1                 : 1a:2b:3c:4d:5e:6f
         Signal             : 99%

SSID 2 : CoffeeShop-Guest
    Network type            : Infrastructure
    Authentication          : Open
    Encryption              : None
    BSSID 1                 : aa:bb:cc:dd:ee:ff
         Signal             : 75%
"""
        expected = [
            {'ssid': 'MyHomeNetwork',
             'authentication': 'WPA2-Personal', 'encryption': 'CCMP', 'signal': '99'},
            {'ssid': 'CoffeeShop-Guest',
             'authentication': 'Open', 'encryption': 'None', 'signal': '75'}
        ]
        result = _parse_netsh_wlan_output(mock_output)
        self.assertEqual(result, expected)

    def test_parse_ignores_duplicate_ssids(self):
        """Test that duplicate SSIDs (from multiple BSSIDs) are ignored."""
        mock_output = """
SSID 1 : MyHomeNetwork
    Authentication          : WPA2-Personal
    Encryption              : CCMP
    BSSID 1                 : 1a:2b:3c:4d:5e:6f
         Signal             : 99%

SSID 2 : MyHomeNetwork
    Authentication          : WPA2-Personal
    Encryption              : CCMP
    BSSID 1                 : 1a:2b:3c:4d:5e:70
         Signal             : 50%
"""
        expected = [
            {'ssid': 'MyHomeNetwork',
             'authentication': 'WPA2-Personal', 'encryption': 'CCMP', 'signal': '99'}
        ]
        result = _parse_netsh_wlan_output(mock_output)
        self.assertEqual(result, expected)
        self.assertEqual(len(result), 1)

    def test_parse_with_missing_signal(self):
        """Test parsing a network block where signal strength is missing."""
        mock_output = """
SSID 1 : HiddenNetwork
    Authentication          : WPA2-Personal
    Encryption              : CCMP
"""
        expected = [
            {'ssid': 'HiddenNetwork',
             'authentication': 'WPA2-Personal', 'encryption': 'CCMP', 'signal': 'N/A'}
        ]
        result = _parse_netsh_wlan_output(mock_output)
        self.assertEqual(result, expected)

    def test_parse_with_empty_ssid(self):
        """Test parsing a network with an empty (hidden) SSID."""
        mock_output = """
SSID 1 : 
    Authentication          : WPA2-Personal
    Encryption              : CCMP
    BSSID 1                 : 1a:2b:3c:4d:5e:6f
         Signal             : 80%
"""
        expected = [
            {'ssid': '(Hidden Network)',
             'authentication': 'WPA2-Personal', 'encryption': 'CCMP', 'signal': '80'}
        ]
        result = _parse_netsh_wlan_output(mock_output)
        self.assertEqual(result, expected)

    def test_parse_no_networks_found(self):
        """Test parsing when no networks are found."""
        mock_output = """
Interface name : Wi-Fi
There are 0 networks currently visible.
"""
        result = _parse_netsh_wlan_output(mock_output)
        self.assertEqual(result, [])

    def test_parse_empty_input(self):
        """Test parsing an empty string."""
        result = _parse_netsh_wlan_output("")
        self.assertEqual(result, [])

class TestListWifiNetworks(unittest.TestCase):
    """Unit tests for the list_wifi_networks function."""

    @patch('logic.wifi.run_system_command')
    @patch('logic.wifi._parse_netsh_wlan_output')
    def test_list_wifi_networks_success(self, mock_parser, mock_run_command):
        """Test a successful network scan."""
        mock_run_command.return_value.stdout = b"some netsh output"
        mock_parser.return_value = [{'ssid': 'TestNet'}]
        
        result = list_wifi_networks()
        
        self.assertEqual(result, [{'ssid': 'TestNet'}])
        mock_run_command.assert_called_once()
        mock_parser.assert_called_once_with("some netsh output")

    @patch('logic.wifi.run_system_command', side_effect=NetworkManagerError("no wireless interface"))
    def test_list_wifi_networks_no_interface(self, mock_run_command):
        """Test that an empty list is returned if no wireless interface is found."""
        result = list_wifi_networks()
        self.assertEqual(result, [])

    @patch('logic.wifi.run_system_command', side_effect=NetworkManagerError("location permission"))
    def test_list_wifi_networks_location_permission_denied(self, mock_run_command):
        """Test that a specific error is raised for location permission issues."""
        with self.assertRaises(NetworkManagerError) as cm:
            list_wifi_networks()
        self.assertEqual(cm.exception.code, 'LOCATION_PERMISSION_DENIED')

    @patch('logic.wifi.run_system_command', side_effect=NetworkManagerError("generic error"))
    def test_list_wifi_networks_generic_error(self, mock_run_command):
        """Test that a generic error is re-raised."""
        with self.assertRaisesRegex(NetworkManagerError, "generic error"):
            list_wifi_networks()

class TestGetCurrentWifiDetails(unittest.TestCase):
    """
    Unit tests for the get_current_wifi_details function.
    """

    @patch('logic.wifi.run_ps_command')
    def test_success_case_returns_dict(self, mock_run_ps_command):
        """Test that a valid JSON output from PowerShell is parsed correctly."""
        # Arrange
        mock_data = {
            "interface_name": "Wi-Fi",
            "ssid": "MyTestNetwork",
            "signal": "99%",
            "ipv4": "192.168.1.123"
        }
        mock_run_ps_command.return_value = json.dumps(mock_data)

        # Act
        result = get_current_wifi_details()

        # Assert
        self.assertEqual(result, mock_data)

    @patch('logic.wifi.run_ps_command')
    def test_not_connected_returns_none(self, mock_run_ps_command):
        """Test that an empty response (not connected) results in None."""
        # Arrange
        mock_run_ps_command.return_value = "" # PS script exits without output if not connected

        # Act
        result = get_current_wifi_details()

        # Assert
        self.assertIsNone(result)

    @patch('logic.wifi.run_ps_command')
    def test_network_error_returns_none(self, mock_run_ps_command):
        """Test that a NetworkManagerError is caught and results in None."""
        # Arrange
        mock_run_ps_command.side_effect = NetworkManagerError("PS command failed")

        # Act & Assert
        self.assertIsNone(get_current_wifi_details())

    @patch('logic.wifi.run_ps_command', side_effect=json.JSONDecodeError("bad json", "", 0))
    def test_invalid_json_returns_none(self, mock_run_ps_command):
        """Test that a JSONDecodeError is caught and results in None."""
        self.assertIsNone(get_current_wifi_details())

class TestDisconnectWifi(unittest.TestCase):
    """Unit tests for the disconnect_wifi function."""

    @patch('logic.wifi.run_system_command')
    def test_disconnect_already_disconnected(self, mock_run_command):
        """Test that the 'not connected' error is handled gracefully."""
        mock_run_command.side_effect = NetworkManagerError("not connected to a network")
        # No exception should be raised
        disconnect_wifi()
        mock_run_command.assert_called_once()

    @patch('logic.wifi.run_system_command')
    def test_disconnect_generic_error(self, mock_run_command):
        """Test that a generic error during disconnect is re-raised."""
        mock_run_command.side_effect = NetworkManagerError("some other failure")
        with self.assertRaisesRegex(NetworkManagerError, "some other failure"):
            disconnect_wifi()
class TestGetSavedWifiProfiles(unittest.TestCase):
    """
    Unit tests for the get_saved_wifi_profiles function.
    """

    @patch('logic.wifi.run_ps_command')
    def test_success_case_with_profiles(self, mock_run_ps_command):
        """Test that a valid JSON output with profiles is parsed correctly."""
        # Arrange
        mock_data = [
            {"ssid": "MyHomeNetwork", "password": "MyPassword123"},
            {"ssid": "CoffeeShop-Guest", "password": "N/A"},
            {"ssid": "Work-Network", "password": "(Password not stored or accessible)"}]
        mock_run_ps_command.return_value = json.dumps(mock_data)

        # Act
        result = get_saved_wifi_profiles()

        # Assert
        self.assertEqual(result, mock_data)

    @patch('logic.wifi.run_ps_command')
    def test_no_profiles_found(self, mock_run_ps_command):
        """Test that an empty list is returned when no profiles are found."""
        # Arrange
        mock_run_ps_command.return_value = "[]"

        # Act
        result = get_saved_wifi_profiles()

        # Assert
        self.assertEqual(result, [])

    @patch('logic.wifi.run_ps_command')
    def test_network_error_raises_exception(self, mock_run_ps_command):
        """Test that a NetworkManagerError from the command is re-raised."""
        # Arrange
        mock_run_ps_command.side_effect = NetworkManagerError("PS command failed")

        # Act & Assert
        # Check that an error is logged and the correct exception is raised.
        with self.assertLogs('logic.wifi', level='ERROR'), self.assertRaises(NetworkManagerError):
            get_saved_wifi_profiles() # type: ignore

    @patch('logic.wifi.run_ps_command', side_effect=json.JSONDecodeError("bad json", "", 0))
    def test_invalid_json_raises_exception(self, mock_run_ps_command):
        """Test that a JSONDecodeError is wrapped in NetworkManagerError."""
        with self.assertLogs('logic.wifi', level='ERROR'), self.assertRaises(NetworkManagerError):
            get_saved_wifi_profiles()

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/test_wifi_profile_manager.py
================================================================================

import unittest
from unittest.mock import patch, call, mock_open

from logic.wifi_profile_manager import (_create_wlan_profile_xml,
                                        connect_to_wifi_network,
                                        connect_with_profile_name, delete_wifi_profile)
from exceptions import NetworkManagerError


class TestCreateProfileXML(unittest.TestCase):
    """
    Unit tests for the WLAN profile creation logic.
    """

    def test_create_wpa2_profile(self):
        """Test creating a profile for a WPA2-Personal network."""
        ssid = "MyWPA2Network"
        auth = "WPA2-Personal"
        enc = "CCMP"
        password = "MyPassword123"

        xml_output = _create_wlan_profile_xml(ssid, auth, enc, password)

        self.assertIn(f"<name>{ssid}</name>", xml_output)
        self.assertIn("<authentication>WPA2PSK</authentication>", xml_output)
        self.assertIn("<encryption>AES</encryption>", xml_output)
        self.assertIn("<keyType>passPhrase</keyType>", xml_output)
        self.assertIn(f"<keyMaterial>{password}</keyMaterial>", xml_output)
        self.assertIn("<protected>false</protected>", xml_output)

    def test_create_wpa3_profile(self):
        """Test creating a profile for a WPA3-Personal network."""
        ssid = "MyWPA3Network"
        auth = "WPA3-Personal"
        enc = "CCMP"
        password = "MyWPA3Password"

        xml_output = _create_wlan_profile_xml(ssid, auth, enc, password)

        self.assertIn(f"<name>{ssid}</name>", xml_output)
        self.assertIn("<authentication>WPA3SAE</authentication>", xml_output)
        self.assertIn("<encryption>AES</encryption>", xml_output)
        self.assertIn("<keyType>passPhrase</keyType>", xml_output)
        self.assertIn(f"<keyMaterial>{password}</keyMaterial>", xml_output)

    def test_create_open_profile(self):
        """Test creating a profile for an Open (unsecured) network."""
        ssid = "FreeWifi"
        auth = "Open"
        enc = "None"
        password = None

        xml_output = _create_wlan_profile_xml(ssid, auth, enc, password)

        self.assertIn(f"<name>{ssid}</name>", xml_output)
        self.assertIn("<authentication>open</authentication>", xml_output)
        self.assertIn("<encryption>none</encryption>", xml_output)
        self.assertNotIn("<sharedKey>", xml_output)

    def test_create_wep_profile(self):
        """Test creating a profile for a legacy WEP network."""
        ssid = "OldSchoolWEP"
        auth = "WEP"
        enc = "WEP"
        password = "wepkey"

        # The logic correctly maps WEP's authentication to 'open' in the XML
        xml_output = _create_wlan_profile_xml(ssid, auth, enc, password)

        self.assertIn(f"<name>{ssid}</name>", xml_output)
        self.assertIn("<authentication>open</authentication>", xml_output)
        self.assertIn("<encryption>WEP</encryption>", xml_output)
        self.assertIn("<keyType>networkKey</keyType>", xml_output)
        self.assertIn(f"<keyMaterial>{password}</keyMaterial>", xml_output)

    def test_unknown_auth_defaults_to_wpa2(self):
        """Test that an unknown authentication type defaults to WPA2-PSK."""
        ssid = "UnknownAuth"
        auth = "WPA4-Enterprise" # A hypothetical future standard
        enc = "CCMP"
        password = "somepassword"

        xml_output = _create_wlan_profile_xml(ssid, auth, enc, password)

        self.assertIn("<authentication>WPA2PSK</authentication>", xml_output)
        self.assertIn("<encryption>AES</encryption>", xml_output)
        self.assertIn("<keyType>passPhrase</keyType>", xml_output)


class TestProfileConnection(unittest.TestCase):
    """Tests for connecting to and deleting Wi-Fi profiles."""

    @patch('logic.wifi_profile_manager.os.path.exists', return_value=True)
    @patch('logic.wifi_profile_manager.os.remove')
    @patch('logic.wifi_profile_manager.run_system_command')
    @patch('logic.wifi_profile_manager.tempfile.NamedTemporaryFile')
    def test_connect_to_wifi_network_success(self, mock_tempfile, mock_run_command, mock_os_remove, mock_os_path_exists):
        """Test a successful connection workflow using a new profile."""
        # Arrange
        mock_file = mock_open()
        mock_tempfile.return_value.__enter__.return_value = mock_file.return_value
        mock_file.return_value.name = "C:\\temp\\profile.xml"

        # Act
        connect_to_wifi_network("TestSSID", "WPA2-Personal", "CCMP", "password123")

        # Assert
        # 1. A temp file was created and written to.
        mock_file().write.assert_called_once()
        self.assertIn("<name>TestSSID</name>", mock_file().write.call_args[0][0])

        # 2. `netsh wlan add profile` and `netsh wlan connect` were called.
        expected_calls = [
            call(['netsh', 'wlan', 'add', 'profile',
                  'filename="C:\\temp\\profile.xml"'], "Failed to add Wi-Fi profile for TestSSID"),
            call(['netsh', 'wlan', 'connect', 'name="TestSSID"'],
                 "Failed to connect using profile TestSSID")
        ]
        mock_run_command.assert_has_calls(expected_calls)

        # 3. The temporary file was deleted.
        mock_os_remove.assert_called_once_with("C:\\temp\\profile.xml")

    @patch('logic.wifi_profile_manager.run_system_command')
    def test_connect_with_profile_name_invalid_key(self, mock_run_command):
        """Test that an invalid key error is correctly identified and re-raised."""
        # Arrange
        error_message = "The network security key is not correct"
        mock_run_command.side_effect = NetworkManagerError(error_message)

        # Act & Assert
        with self.assertRaises(NetworkManagerError) as cm:
            connect_with_profile_name("MyProfile")

        self.assertEqual(cm.exception.code, 'WIFI_INVALID_KEY')
        self.assertIn("The password is incorrect", str(cm.exception))

    @patch('logic.wifi_profile_manager.run_system_command')
    def test_delete_wifi_profile(self, mock_run_command):
        """Test that the delete profile command is called correctly."""
        # Arrange
        profile_name = "OldProfile"

        # Act
        delete_wifi_profile(profile_name)

        # Assert
        mock_run_command.assert_called_once_with(
            ['netsh', 'wlan', 'delete', 'profile',
             f'name="{profile_name}"'], f"Failed to delete profile {profile_name}")

if __name__ == '__main__':
    unittest.main()

================================================================================
FILE: tests/__init__.py
================================================================================



